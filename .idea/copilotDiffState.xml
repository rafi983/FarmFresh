<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/add-reviews-to-all.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/add-reviews-to-all.js" />
              <option name="updatedContent" value="// Add reviews to ALL products that don't have any reviews&#10;const { MongoClient, ObjectId } = require('mongodb');&#10;&#10;async function addReviewsToAllProducts() {&#10;  const client = new MongoClient('mongodb://localhost:27017');&#10;  await client.connect();&#10;  const db = client.db('farmfresh');&#10;  &#10;  // Get ALL products&#10;  const allProducts = await db.collection('products').find({}).toArray();&#10;  console.log(`Found ${allProducts.length} total products`);&#10;  &#10;  // Get all existing reviews&#10;  const existingReviews = await db.collection('reviews').find({}).toArray();&#10;  const reviewedProductIds = [...new Set(existingReviews.map(r =&gt; r.productId))];&#10;  console.log(`Found ${existingReviews.length} existing reviews for ${reviewedProductIds.length} products`);&#10;  &#10;  // Find products that have NO reviews&#10;  const productsWithoutReviews = allProducts.filter(product =&gt; &#10;    !reviewedProductIds.includes(product._id.toString())&#10;  );&#10;  &#10;  console.log(`Found ${productsWithoutReviews.length} products WITHOUT reviews`);&#10;  console.log('Products without reviews:');&#10;  productsWithoutReviews.forEach(p =&gt; console.log(`- ${p.name} (ID: ${p._id})`));&#10;  &#10;  // Add sample reviews to products without reviews&#10;  for (const product of productsWithoutReviews) {&#10;    const ratings = [4, 4.5, 5, 3.5, 4.5]; // Random good ratings&#10;    const numReviews = Math.floor(Math.random() * 3) + 2; // 2-4 reviews per product&#10;    &#10;    const sampleReviews = [];&#10;    for (let i = 0; i &lt; numReviews; i++) {&#10;      const rating = ratings[Math.floor(Math.random() * ratings.length)];&#10;      sampleReviews.push({&#10;        productId: product._id.toString(),&#10;        userId: `sample-user-${i + 1}`,&#10;        reviewer: ['John Doe', 'Jane Smith', 'Mike Johnson', 'Sarah Wilson', 'David Brown'][i] || 'Anonymous',&#10;        rating: rating,&#10;        comment: [&#10;          `Great quality ${product.name}! Fresh and delicious.`,&#10;          `Excellent ${product.name}. Highly recommended!`,&#10;          `Good quality ${product.name}. Will buy again.`,&#10;          `Amazing ${product.name}! Worth every penny.`,&#10;          `Perfect ${product.name}. Fast delivery too!`&#10;        ][i] || `Nice ${product.name}!`,&#10;        createdAt: new Date(Date.now() - Math.random() * 30 * 24 * 60 * 60 * 1000), // Random date within last 30 days&#10;        updatedAt: new Date()&#10;      });&#10;    }&#10;    &#10;    await db.collection('reviews').insertMany(sampleReviews);&#10;    console.log(`✅ Added ${numReviews} reviews for ${product.name}`);&#10;  }&#10;  &#10;  console.log(`✅ Successfully added reviews to ${productsWithoutReviews.length} products!`);&#10;  await client.close();&#10;}&#10;&#10;addReviewsToAllProducts().catch(console.error);" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/add-reviews-to-old.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/add-reviews-to-old.js" />
              <option name="updatedContent" value="// Add sample reviews to some old products that currently have no reviews&#10;const { MongoClient, ObjectId } = require('mongodb');&#10;&#10;async function addReviewsToOldProducts() {&#10;  const client = new MongoClient('mongodb://localhost:27017');&#10;  await client.connect();&#10;  const db = client.db('farmfresh');&#10;  &#10;  // Get old products that have no reviews (excluding mango and top grain)&#10;  const oldProducts = await db.collection('products').find({&#10;    _id: { &#10;      $nin: [&#10;        new ObjectId('6889cb7ab6d22dd651140bee'), // mango&#10;        new ObjectId('688affa63c35c3c0ff9c4925')  // top grain&#10;      ]&#10;    }&#10;  }).limit(5).toArray(); // Just add reviews to first 5 old products&#10;  &#10;  console.log(`Adding sample reviews to ${oldProducts.length} old products...\n`);&#10;  &#10;  const sampleReviewers = [&#10;    'Alice Johnson', 'Bob Smith', 'Carol Davis', 'David Wilson', 'Emma Brown',&#10;    'Frank Miller', 'Grace Lee', 'Henry Taylor', 'Ivy Chen', 'Jack Anderson'&#10;  ];&#10;  &#10;  const sampleComments = [&#10;    'Excellent quality! Fresh and delicious.',&#10;    'Great product, will buy again.',&#10;    'Very satisfied with the freshness.',&#10;    'Good value for money.',&#10;    'Highly recommended!',&#10;    'Perfect quality, as expected.',&#10;    'Fresh and tasty!',&#10;    'Amazing product quality.',&#10;    'Will definitely order again.',&#10;    'Best quality I\'ve found!'&#10;  ];&#10;  &#10;  for (const product of oldProducts) {&#10;    const numReviews = Math.floor(Math.random() * 4) + 2; // 2-5 reviews per product&#10;    const reviews = [];&#10;    &#10;    for (let i = 0; i &lt; numReviews; i++) {&#10;      const rating = [4, 4.5, 5, 3.5, 4.5][Math.floor(Math.random() * 5)]; // Good ratings&#10;      const reviewer = sampleReviewers[Math.floor(Math.random() * sampleReviewers.length)];&#10;      const comment = sampleComments[Math.floor(Math.random() * sampleComments.length)];&#10;      &#10;      reviews.push({&#10;        productId: product._id.toString(),&#10;        userId: `sample-user-${i + 1}`,&#10;        reviewer: reviewer,&#10;        rating: rating,&#10;        comment: `${comment} ${product.name} exceeded my expectations!`,&#10;        createdAt: new Date(Date.now() - Math.random() * 30 * 24 * 60 * 60 * 1000), // Random date within last 30 days&#10;        updatedAt: new Date()&#10;      });&#10;    }&#10;    &#10;    await db.collection('reviews').insertMany(reviews);&#10;    console.log(`✅ Added ${numReviews} reviews to ${product.name}`);&#10;  }&#10;  &#10;  console.log(`\n Successfully added reviews to ${oldProducts.length} old products!`);&#10;  console.log('Now refresh your products page - these products should show star ratings!');&#10;  &#10;  await client.close();&#10;}&#10;&#10;addReviewsToOldProducts().catch(console.error);" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/add-sample-reviews.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/add-sample-reviews.js" />
              <option name="updatedContent" value="// Add sample reviews to existing products&#10;const { MongoClient, ObjectId } = require('mongodb');&#10;&#10;async function addSampleReviews() {&#10;  const client = new MongoClient('mongodb://localhost:27017');&#10;  await client.connect();&#10;  const db = client.db('farmfresh');&#10;  &#10;  // Get the first 3 existing products&#10;  const products = await db.collection('products').find({}).limit(3).toArray();&#10;  &#10;  console.log('Adding sample reviews to existing products...');&#10;  &#10;  for (const product of products) {&#10;    // Add 2-3 sample reviews for each product&#10;    const sampleReviews = [&#10;      {&#10;        productId: product._id.toString(),&#10;        userId: 'sample-user-1',&#10;        reviewer: 'John Doe',&#10;        rating: 4.5,&#10;        comment: `Great quality ${product.name}! Fresh and delicious.`,&#10;        createdAt: new Date(),&#10;        updatedAt: new Date()&#10;      },&#10;      {&#10;        productId: product._id.toString(),&#10;        userId: 'sample-user-2', &#10;        reviewer: 'Jane Smith',&#10;        rating: 5,&#10;        comment: `Excellent ${product.name}. Highly recommended!`,&#10;        createdAt: new Date(),&#10;        updatedAt: new Date()&#10;      },&#10;      {&#10;        productId: product._id.toString(),&#10;        userId: 'sample-user-3',&#10;        reviewer: 'Mike Johnson', &#10;        rating: 4,&#10;        comment: `Good quality ${product.name}. Will buy again.`,&#10;        createdAt: new Date(),&#10;        updatedAt: new Date()&#10;      }&#10;    ];&#10;    &#10;    await db.collection('reviews').insertMany(sampleReviews);&#10;    console.log(`✅ Added 3 reviews for ${product.name}`);&#10;  }&#10;  &#10;  console.log('✅ Sample reviews added successfully!');&#10;  await client.close();&#10;}&#10;&#10;addSampleReviews().catch(console.error);" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/api/debug/cleanup/route.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/api/debug/cleanup/route.js" />
              <option name="updatedContent" value="import { NextResponse } from &quot;next/server&quot;;&#10;import clientPromise from &quot;@/lib/mongodb&quot;;&#10;&#10;export async function POST(request) {&#10;  try {&#10;    const client = await clientPromise;&#10;    const db = client.db(&quot;farmfresh&quot;);&#10;    const collection = db.collection(&quot;products&quot;);&#10;&#10;    console.log(&quot;=== STARTING DATABASE CLEANUP ===&quot;);&#10;&#10;    // Find all products with mismatched farmer emails&#10;    const allProducts = await collection.find({}).toArray();&#10;    let fixedCount = 0;&#10;    let issuesFound = [];&#10;&#10;    for (const product of allProducts) {&#10;      const farmerEmail = product.farmerEmail;&#10;      const farmerFromObject = product.farmer?.email;&#10;      const farmerId = product.farmerId;&#10;&#10;      // Case 1: farmer.email exists but farmerEmail is missing&#10;      if (!farmerEmail &amp;&amp; farmerFromObject) {&#10;        await collection.updateOne(&#10;          { _id: product._id },&#10;          {&#10;            $set: {&#10;              farmerEmail: farmerFromObject,&#10;            },&#10;          },&#10;        );&#10;        fixedCount++;&#10;        issuesFound.push({&#10;          productId: product._id,&#10;          productName: product.name,&#10;          issue: &quot;Missing farmerEmail field&quot;,&#10;          action: `Set farmerEmail to ${farmerFromObject}`,&#10;        });&#10;      }&#10;&#10;      // Case 2: farmerEmail and farmer.email don't match&#10;      else if (&#10;        farmerEmail &amp;&amp;&#10;        farmerFromObject &amp;&amp;&#10;        farmerEmail !== farmerFromObject&#10;      ) {&#10;        // For real farmers with farmerId (like farmer_008), prioritize farmerEmail over farmer.email&#10;        // This fixes cases where Ayesha (ayesha.siddika@farmfresh.com) shows Chashi's products&#10;        if (&#10;          farmerId &amp;&amp;&#10;          (farmerId.includes(&quot;farmer_&quot;) || farmerId.match(/^[0-9a-fA-F]{24}$/))&#10;        ) {&#10;          await collection.updateOne(&#10;            { _id: product._id },&#10;            {&#10;              $set: {&#10;                &quot;farmer.email&quot;: farmerEmail,&#10;              },&#10;            },&#10;          );&#10;          fixedCount++;&#10;          issuesFound.push({&#10;            productId: product._id,&#10;            productName: product.name,&#10;            issue: `Mismatched emails: farmerEmail=${farmerEmail}, farmer.email=${farmerFromObject}`,&#10;            action: `Updated farmer.email to ${farmerEmail} (real farmer with farmerId: ${farmerId})`,&#10;          });&#10;        }&#10;        // For hardcoded farmers (no farmerId or non-standard farmerId), prioritize farmer.email&#10;        else {&#10;          await collection.updateOne(&#10;            { _id: product._id },&#10;            {&#10;              $set: {&#10;                farmerEmail: farmerFromObject,&#10;              },&#10;            },&#10;          );&#10;          fixedCount++;&#10;          issuesFound.push({&#10;            productId: product._id,&#10;            productName: product.name,&#10;            issue: `Mismatched emails: farmerEmail=${farmerEmail}, farmer.email=${farmerFromObject}`,&#10;            action: `Updated farmerEmail to ${farmerFromObject} (hardcoded farmer)`,&#10;          });&#10;        }&#10;      }&#10;    }&#10;&#10;    console.log(`=== CLEANUP COMPLETE: Fixed ${fixedCount} products ===`);&#10;    issuesFound.forEach((issue) =&gt; {&#10;      console.log(`- ${issue.productName}: ${issue.action}`);&#10;    });&#10;&#10;    return NextResponse.json({&#10;      success: true,&#10;      message: `Database cleanup completed. Fixed ${fixedCount} products.`,&#10;      fixedCount,&#10;      issuesFound,&#10;      details: &quot;Check server console for detailed logs&quot;,&#10;    });&#10;  } catch (error) {&#10;    console.error(&quot;Database cleanup error:&quot;, error);&#10;    return NextResponse.json(&#10;      { error: &quot;Database cleanup failed&quot;, message: error.message },&#10;      { status: 500 },&#10;    );&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/api/farmers/migrate/route.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/api/farmers/migrate/route.js" />
              <option name="updatedContent" value="import { NextResponse } from &quot;next/server&quot;;&#10;import clientPromise from &quot;@/lib/mongodb&quot;;&#10;&#10;export async function POST(request) {&#10;  try {&#10;    const client = await clientPromise;&#10;    const db = client.db(&quot;farmfresh&quot;);&#10;    const usersCollection = db.collection(&quot;users&quot;);&#10;    const farmersCollection = db.collection(&quot;farmers&quot;);&#10;&#10;    // Find all users with userType &quot;farmer&quot;&#10;    const farmerUsers = await usersCollection.find({ userType: &quot;farmer&quot; }).toArray();&#10;    &#10;    console.log(`Found ${farmerUsers.length} farmer users to migrate`);&#10;&#10;    let migratedCount = 0;&#10;    let skippedCount = 0;&#10;&#10;    for (const user of farmerUsers) {&#10;      // Check if farmer already exists in farmers collection&#10;      const existingFarmer = await farmersCollection.findOne({ _id: user._id });&#10;      &#10;      if (!existingFarmer) {&#10;        // Create farmer document&#10;        const farmerData = {&#10;          _id: user._id,&#10;          name: user.name || `${user.firstName} ${user.lastName}`,&#10;          email: user.email,&#10;          phone: user.phone || &quot;&quot;,&#10;          location: user.address || &quot;&quot;,&#10;          farmName: user.farmDetails?.farmName || `${user.name}'s Farm`,&#10;          specializations: user.farmDetails?.specialization ? &#10;            Array.isArray(user.farmDetails.specialization) ? &#10;              user.farmDetails.specialization : &#10;              [user.farmDetails.specialization] : &#10;            [&quot;General Farming&quot;],&#10;          farmSize: user.farmDetails?.farmSize || null,&#10;          farmSizeUnit: user.farmDetails?.farmSizeUnit || &quot;acres&quot;,&#10;          bio: user.bio || &quot;&quot;,&#10;          profilePicture: user.profilePicture || null,&#10;          rating: 0,&#10;          totalReviews: 0,&#10;          verified: false,&#10;          joinedDate: user.createdAt || new Date(),&#10;          products: [],&#10;          orders: [],&#10;          availability: {&#10;            status: &quot;available&quot;,&#10;            schedule: {&#10;              monday: { start: &quot;09:00&quot;, end: &quot;17:00&quot;, available: true },&#10;              tuesday: { start: &quot;09:00&quot;, end: &quot;17:00&quot;, available: true },&#10;              wednesday: { start: &quot;09:00&quot;, end: &quot;17:00&quot;, available: true },&#10;              thursday: { start: &quot;09:00&quot;, end: &quot;17:00&quot;, available: true },&#10;              friday: { start: &quot;09:00&quot;, end: &quot;17:00&quot;, available: true },&#10;              saturday: { start: &quot;09:00&quot;, end: &quot;15:00&quot;, available: true },&#10;              sunday: { start: &quot;10:00&quot;, end: &quot;14:00&quot;, available: false }&#10;            }&#10;          },&#10;          socialMedia: {&#10;            facebook: &quot;&quot;,&#10;            instagram: &quot;&quot;,&#10;            twitter: &quot;&quot;,&#10;            website: &quot;&quot;&#10;          },&#10;          certifications: [],&#10;          deliveryOptions: {&#10;            farmPickup: true,&#10;            localDelivery: false,&#10;            shipping: false,&#10;            deliveryRadius: 0&#10;          },&#10;          createdAt: user.createdAt || new Date(),&#10;          updatedAt: new Date()&#10;        };&#10;&#10;        // Insert farmer&#10;        await farmersCollection.insertOne(farmerData);&#10;        console.log(`✅ Migrated farmer: ${farmerData.name}`);&#10;        migratedCount++;&#10;      } else {&#10;        console.log(`⚠️  Farmer ${user.name} already exists in farmers collection`);&#10;        skippedCount++;&#10;      }&#10;    }&#10;&#10;    // Get final count&#10;    const totalFarmers = await farmersCollection.countDocuments();&#10;    &#10;    return NextResponse.json({&#10;      success: true,&#10;      message: &quot;Farmer migration completed&quot;,&#10;      results: {&#10;        farmersFound: farmerUsers.length,&#10;        migrated: migratedCount,&#10;        skipped: skippedCount,&#10;        totalFarmersInCollection: totalFarmers&#10;      }&#10;    });&#10;    &#10;  } catch (error) {&#10;    console.error(&quot;Migration error:&quot;, error);&#10;    return NextResponse.json(&#10;      { &#10;        success: false, &#10;        error: &quot;Failed to migrate farmers&quot;,&#10;        message: error.message &#10;      },&#10;      { status: 500 }&#10;    );&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/api/farmers/route.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/api/farmers/route.js" />
              <option name="originalContent" value="import { NextResponse } from &quot;next/server&quot;;&#10;import clientPromise from &quot;@/lib/mongodb&quot;;&#10;import { getServerSession } from &quot;next-auth/next&quot;;&#10;import { authOptions } from &quot;../auth/[...nextauth]/route&quot;;&#10;&#10;// Track if indexes have been initialized to avoid repeated calls&#10;let farmersIndexesInitialized = false;&#10;// Cache for database connection and collections&#10;let cachedDb = null;&#10;let cachedFarmersCollection = null;&#10;let cachedProductsCollection = null;&#10;&#10;// Response cache for identical requests (5 minutes)&#10;const responseCache = new Map();&#10;const CACHE_TTL = 5 * 60 * 1000;&#10;&#10;// Initialize indexes optimized for MongoDB Atlas performance&#10;async function initializeFarmersIndexes(db) {&#10;  if (farmersIndexesInitialized) {&#10;    return;&#10;  }&#10;&#10;  try {&#10;    const farmersCollection = db.collection(&quot;farmers&quot;);&#10;&#10;    // Check existing indexes&#10;    const existingIndexes = await farmersCollection.listIndexes().toArray();&#10;    const indexNames = existingIndexes.map((index) =&gt; index.name);&#10;&#10;    // Atlas-optimized compound indexes for farmers queries&#10;    const indexesToCreate = [&#10;      // Text search index with proper weights&#10;      {&#10;        key: {&#10;          name: &quot;text&quot;,&#10;          description: &quot;text&quot;,&#10;          location: &quot;text&quot;,&#10;          farmName: &quot;text&quot;,&#10;          specializations: &quot;text&quot;,&#10;        },&#10;        name: &quot;farmers_text_search_idx&quot;,&#10;        options: {&#10;          background: true,&#10;          weights: {&#10;            name: 10,&#10;            farmName: 8,&#10;            location: 5,&#10;            specializations: 3,&#10;            description: 1,&#10;          },&#10;        },&#10;      },&#10;      // Location-based queries&#10;      {&#10;        key: { location: 1, verified: 1 },&#10;        name: &quot;location_verified_idx&quot;,&#10;        options: { background: true },&#10;      },&#10;      // Specialization queries&#10;      {&#10;        key: { specializations: 1, verified: 1 },&#10;        name: &quot;specializations_verified_idx&quot;,&#10;        options: { background: true },&#10;      },&#10;      // Nested farmers array index&#10;      {&#10;        key: { &quot;farmers.name&quot;: 1, &quot;farmers.location&quot;: 1 },&#10;    }&#10;          { name: { $regex: search, $options: &quot;i&quot; } },&#10;          { description: { $regex: search, $options: &quot;i&quot; } },&#10;          { location: { $regex: search, $options: &quot;i&quot; } },&#10;          { farmName: { $regex: search, $options: &quot;i&quot; } },&#10;    } else {&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: { location: { $regex: location, $options: &quot;i&quot; } },&#10;      };&#10;      total: totalCount,&#10;      page,&#10;      totalPages: Math.ceil(totalCount / limit),&#10;  // Build match stage for filtering&#10;  const matchStage = { $match: { $or: [] } };&#10;    };&#10;    console.log(&quot;Atlas-optimized farmers indexes initialized successfully&quot;);&#10;  const directFarmerMatch = {};&#10;  const nestedFarmerMatch = {};&#10;&#10;  // Add search filters&#10;        name: &quot;nested_farmers_search_idx&quot;,&#10;        options: { background: true },&#10;// Optimized farmers query using aggregation pipeline&#10;      // Nested farmers array index&#10;      {&#10;        key: { &quot;farmers.name&quot;: 1, &quot;farmers.location&quot;: 1 },&#10;        name: &quot;nested_farmers_search_idx&quot;,&#10;        options: { background: true },&#10;      },&#10;    console.log(&quot;Atlas-optimized farmers indexes initialized successfully&quot;);&#10;      {&#10;        key: { &quot;farmers.name&quot;: 1, &quot;farmers.location&quot;: 1 },&#10;        name: &quot;nested_farmers_search_idx&quot;,&#10;        options: { background: true },&#10;      },&#10;    console.log(&quot;Atlas-optimized farmers indexes initialized successfully&quot;);&#10;      {&#10;        key: { &quot;farmers.name&quot;: 1, &quot;farmers.location&quot;: 1 },&#10;        name: &quot;nested_farmers_search_idx&quot;,&#10;        options: { background: true },&#10;      },&#10;    console.log(&quot;Atlas-optimized farmers indexes initialized successfully&quot;);&#10;      {&#10;        key: { &quot;farmers.name&quot;: 1, &quot;farmers.location&quot;: 1 },&#10;        name: &quot;nested_farmers_search_idx&quot;,&#10;        options: { background: true },&#10;      },&#10;      // Nested farmers array index&#10;      {&#10;        key: { &quot;farmers.name&quot;: 1, &quot;farmers.location&quot;: 1 },&#10;        name: &quot;nested_farmers_search_idx&quot;,&#10;        options: { background: true },&#10;      },&#10;    console.log(&quot;Atlas-optimized farmers indexes initialized successfully&quot;);&#10;      {&#10;        key: { &quot;farmers.name&quot;: 1, &quot;farmers.location&quot;: 1 },&#10;        name: &quot;nested_farmers_search_idx&quot;,&#10;        options: { background: true },&#10;      },&#10;    console.log(&quot;Atlas-optimized farmers indexes initialized successfully&quot;);&#10;      {&#10;        key: { &quot;farmers.name&quot;: 1, &quot;farmers.location&quot;: 1 },&#10;        name: &quot;nested_farmers_search_idx&quot;,&#10;        options: { background: true },&#10;      },&#10;    console.log(&quot;Atlas-optimized farmers indexes initialized successfully&quot;);&#10;      {&#10;        key: { &quot;farmers.name&quot;: 1, &quot;farmers.location&quot;: 1 },&#10;        name: &quot;nested_farmers_search_idx&quot;,&#10;        options: { background: true },&#10;      },&#10;      // Nested farmers array index&#10;// Optimized farmers query using aggregation pipeline&#10;        key: { &quot;farmers.name&quot;: 1, &quot;farmers.location&quot;: 1 },&#10;        name: &quot;nested_farmers_search_idx&quot;,&#10;        options: { background: true },&#10;      },&#10;    console.log(&quot;Atlas-optimized farmers indexes initialized successfully&quot;);&#10;      {&#10;        key: { &quot;farmers.name&quot;: 1, &quot;farmers.location&quot;: 1 },&#10;        name: &quot;nested_farmers_search_idx&quot;,&#10;  const pipeline = [];&#10;    console.log(&quot;Atlas-optimized farmers indexes initialized successfully&quot;);&#10;  // Build match stage for filtering&#10;  const matchStage = { $match: { $or: [] } };&#10;        options: { background: true },&#10;      },&#10;    console.log(&quot;Atlas-optimized farmers indexes initialized successfully&quot;);&#10;      {&#10;        key: { &quot;farmers.name&quot;: 1, &quot;farmers.location&quot;: 1 },&#10;// Optimized farmers query using aggregation pipeline&#10;        options: { background: true },&#10;      },&#10;      // Nested farmers array index&#10;    }&#10;          { name: { $regex: search, $options: &quot;i&quot; } },&#10;          { description: { $regex: search, $options: &quot;i&quot; } },&#10;          { location: { $regex: search, $options: &quot;i&quot; } },&#10;          { farmName: { $regex: search, $options: &quot;i&quot; } },&#10;    } else {&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: { location: { $regex: location, $options: &quot;i&quot; } },&#10;      };&#10;      total: totalCount,&#10;      page,&#10;      totalPages: Math.ceil(totalCount / limit),&#10;  // Build match stage for filtering&#10;  const matchStage = { $match: { $or: [] } };&#10;    };&#10;  // Handle both direct farmers and nested farmers structure&#10;  const directFarmerMatch = {};&#10;  const nestedFarmerMatch = {};&#10;&#10;  // Add search filters&#10;      {&#10;// Get total count for pagination&#10;  const matchStage = { $match: { $or: [] } };&#10;&#10;    directFarmerMatch.$text = { $search: search };&#10;    nestedFarmerMatch[&quot;farmers&quot;] = {&#10;      $elemMatch: {&#10;        $or: [&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;    directFarmerMatch.$text = { $search: search };&#10;    nestedFarmerMatch[&quot;farmers&quot;] = {&#10;&#10;      $elemMatch: {&#10;        $or: [&#10;  const pipeline = [];&#10;          { location: { $regex: search, $options: &quot;i&quot; } },&#10;  // Build match stage for filtering&#10;  const matchStage = { $match: { $or: [] } };&#10;          $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;        },&#10;      });&#10;  // Handle both direct farmers and nested farmers structure&#10;  const directFarmerMatch = {};&#10;  const nestedFarmerMatch = {};&#10;&#10;  // Add search filters&#10;  // If no specific filters, match all documents&#10;  if (matchStage.$match.$or.length === 0) {&#10;    matchStage.$match = {};&#10;    }&#10;          { name: { $regex: search, $options: &quot;i&quot; } },&#10;          { description: { $regex: search, $options: &quot;i&quot; } },&#10;          { location: { $regex: search, $options: &quot;i&quot; } },&#10;          { farmName: { $regex: search, $options: &quot;i&quot; } },&#10;    } else {&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: { location: { $regex: location, $options: &quot;i&quot; } },&#10;      };&#10;      total: totalCount,&#10;      page,&#10;      totalPages: Math.ceil(totalCount / limit),&#10;  // Build match stage for filtering&#10;  const matchStage = { $match: { $or: [] } };&#10;    };&#10;  // Handle both direct farmers and nested farmers structure&#10;  const directFarmerMatch = {};&#10;  const nestedFarmerMatch = {};&#10;&#10;  // Add search filters&#10;  }&#10;// Get total count for pagination&#10;  const matchStage = { $match: { $or: [] } };&#10;&#10;    directFarmerMatch.$text = { $search: search };&#10;    nestedFarmerMatch[&quot;farmers&quot;] = {&#10;      $elemMatch: {&#10;        $or: [&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;    directFarmerMatch.$text = { $search: search };&#10;    nestedFarmerMatch[&quot;farmers&quot;] = {&#10;&#10;      $elemMatch: {&#10;        $or: [&#10;    directFarmerMatch.specializations = {&#10;          { description: { $regex: search, $options: &quot;i&quot; } },&#10;          { location: { $regex: search, $options: &quot;i&quot; } },&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        specializations: {&#10;          $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;        },&#10;      });&#10;    } else {&#10;  // If no specific filters, match all documents&#10;  if (matchStage.$match.$or.length === 0) {&#10;    matchStage.$match = {};&#10;  }&#10;&#10;  pipeline.push(matchStage);&#10;&#10;  // Add facet stage for both direct and nested farmers&#10;  pipeline.push({&#10;    $facet: {&#10;      directFarmers: [&#10;        { $match: { name: { $exists: true }, location: { $exists: true } } },&#10;        { $project: { farmers: 0 } }, // Exclude nested farmers array&#10;      ],&#10;      nestedFarmers: [&#10;        { $match: { farmers: { $exists: true, $type: &quot;array&quot; } } },&#10;        { $unwind: &quot;$farmers&quot; },&#10;        { $replaceRoot: { newRoot: &quot;$farmers&quot; } },&#10;      ],&#10;    },&#10;  });&#10;&#10;  // Combine results&#10;  pipeline.push({&#10;  const pipeline = [];&#10;        const productsUpdateResult = await db.collection(&quot;products&quot;).updateMany(&#10;  // Build match stage (same as main query)&#10;  const matchStage = { $match: { $or: [] } };&#10;  pipeline.push({ $unwind: &quot;$allFarmers&quot; });&#10;  const directFarmerMatch = {};&#10;  const nestedFarmerMatch = {};&#10;&#10;&#10;  // Add sorting (by verification status, then name)&#10;    directFarmerMatch.$text = { $search: search };&#10;    nestedFarmerMatch[&quot;farmers&quot;] = {&#10;      $elemMatch: {&#10;    directFarmerMatch.specializations = {&#10;          { name: { $regex: search, $options: &quot;i&quot; } },&#10;          { description: { $regex: search, $options: &quot;i&quot; } },&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        specializations: {&#10;          $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;    directFarmerMatch.location = { $regex: location, $options: &quot;i&quot; };&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or =&#10;        nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or || [];&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        location: { $regex: location, $options: &quot;i&quot; },&#10;      });&#10;    } else {&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: { location: { $regex: location, $options: &quot;i&quot; } },&#10;      };&#10;    }&#10;  }&#10;&#10;  if (Object.keys(directFarmerMatch).length &gt; 0) {&#10;    directFarmerMatch.name = { $exists: true };&#10;    directFarmerMatch.location = { $exists: true };&#10;    matchStage.$match.$or.push(directFarmerMatch);&#10;  }&#10;&#10;  if (Object.keys(nestedFarmerMatch).length &gt; 0) {&#10;    matchStage.$match.$or.push(nestedFarmerMatch);&#10;  }&#10;&#10;      : 50; // Increased default limit to show all farmers&#10;    matchStage.$match = {};&#10;      });&#10;    const includeStats = searchParams.get(&quot;includeStats&quot;) !== &quot;false&quot;; // Default to true&#10;&#10;  pipeline.push({&#10;    $facet: {&#10;      directFarmers: [&#10;        { $match: { name: { $exists: true }, location: { $exists: true } } },&#10;        { $count: &quot;count&quot; },&#10;      ],&#10;      nestedFarmers: [&#10;        { $match: { farmers: { $exists: true, $type: &quot;array&quot; } } },&#10;        { $unwind: &quot;$farmers&quot; },&#10;        { $count: &quot;count&quot; },&#10;      ],&#10;    },&#10;  });&#10;&#10;  const result = await farmersCollection.aggregate(pipeline).toArray();&#10;&#10;  if (result.length === 0) return 0;&#10;&#10;  const directCount = result[0].directFarmers[0]?.count || 0;&#10;  const nestedCount = result[0].nestedFarmers[0]?.count || 0;&#10;&#10;  return directCount + nestedCount;&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: {&#10;          specializations: {&#10;            $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;          },&#10;        },&#10;      };&#10;    // Enhance farmers with product statistics if requested&#10;          { location: { $regex: search, $options: &quot;i&quot; } },&#10;          { farmName: { $regex: search, $options: &quot;i&quot; } },&#10;      },&#10;    };&#10;    // Get farmers using optimized aggregation pipeline&#10;      };&#10;    }&#10;          { farmName: { $regex: search, $options: &quot;i&quot; } },&#10;        ],&#10;      },&#10;    };&#10;    } else {&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: { location: { $regex: location, $options: &quot;i&quot; } },&#10;      };&#10;    }&#10;  }&#10;&#10;  // Add conditions for direct farmers&#10;      total: totalCount,&#10;      page,&#10;      totalPages: Math.ceil(totalCount / limit),&#10;      hasNextPage: page * limit &lt; totalCount,&#10;      hasPrevPage: page &gt; 1,&#10;// Get total count for pagination&#10;    matchStage.$match = {};&#10;  }&#10;&#10;  pipeline.push(matchStage);&#10;&#10;  // Add facet stage for both direct and nested farmers&#10;  pipeline.push({&#10;    $facet: {&#10;      directFarmers: [&#10;        { $match: { name: { $exists: true }, location: { $exists: true } } },&#10;&#10;        { $project: { farmers: 0 } }, // Exclude nested farmers array&#10;      ],&#10;      nestedFarmers: [&#10;        { $match: { farmers: { $exists: true, $type: &quot;array&quot; } } },&#10;        { $unwind: &quot;$farmers&quot; },&#10;        { $replaceRoot: { newRoot: &quot;$farmers&quot; } },&#10;      ],&#10;    },&#10;  });&#10;&#10;    console.error(&quot;Error fetching farmers:&quot;, error);&#10;  pipeline.push({&#10;  const pipeline = [];&#10;&#10;  // Build match stage (same as main query)&#10;  const matchStage = { $match: { $or: [] } };&#10;  pipeline.push({ $unwind: &quot;$allFarmers&quot; });&#10;  const directFarmerMatch = {};&#10;  const nestedFarmerMatch = {};&#10;&#10;&#10;  // Add sorting (by verification status, then name)&#10;    directFarmerMatch.$text = { $search: search };&#10;    nestedFarmerMatch[&quot;farmers&quot;] = {&#10;      $elemMatch: {&#10;    directFarmerMatch.specializations = {&#10;          { name: { $regex: search, $options: &quot;i&quot; } },&#10;          { description: { $regex: search, $options: &quot;i&quot; } },&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        specializations: {&#10;          $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;    directFarmerMatch.location = { $regex: location, $options: &quot;i&quot; };&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or =&#10;        nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or || [];&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        location: { $regex: location, $options: &quot;i&quot; },&#10;      });&#10;    } else {&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: { location: { $regex: location, $options: &quot;i&quot; } },&#10;      };&#10;    }&#10;  }&#10;&#10;  if (Object.keys(directFarmerMatch).length &gt; 0) {&#10;    directFarmerMatch.name = { $exists: true };&#10;    directFarmerMatch.location = { $exists: true };&#10;    matchStage.$match.$or.push(directFarmerMatch);&#10;  }&#10;&#10;  if (Object.keys(nestedFarmerMatch).length &gt; 0) {&#10;    matchStage.$match.$or.push(nestedFarmerMatch);&#10;  }&#10;&#10;      : 50; // Increased default limit to show all farmers&#10;    matchStage.$match = {};&#10;      });&#10;    const includeStats = searchParams.get(&quot;includeStats&quot;) !== &quot;false&quot;; // Default to true&#10;&#10;  pipeline.push({&#10;    $facet: {&#10;      directFarmers: [&#10;        { $match: { name: { $exists: true }, location: { $exists: true } } },&#10;        { $count: &quot;count&quot; },&#10;      ],&#10;      nestedFarmers: [&#10;        { $match: { farmers: { $exists: true, $type: &quot;array&quot; } } },&#10;        { $unwind: &quot;$farmers&quot; },&#10;        { $count: &quot;count&quot; },&#10;      ],&#10;    },&#10;  });&#10;&#10;  const result = await farmersCollection.aggregate(pipeline).toArray();&#10;&#10;  if (result.length === 0) return 0;&#10;&#10;  const directCount = result[0].directFarmers[0]?.count || 0;&#10;  const nestedCount = result[0].nestedFarmers[0]?.count || 0;&#10;&#10;  return directCount + nestedCount;&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: {&#10;          specializations: {&#10;            $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;          },&#10;        },&#10;      };&#10;    // Enhance farmers with product statistics if requested&#10;          { location: { $regex: search, $options: &quot;i&quot; } },&#10;          { farmName: { $regex: search, $options: &quot;i&quot; } },&#10;      },&#10;    };&#10;    // Get farmers using optimized aggregation pipeline&#10;      };&#10;    }&#10;          { name: { $regex: search, $options: &quot;i&quot; } },&#10;          { description: { $regex: search, $options: &quot;i&quot; } },&#10;          { location: { $regex: search, $options: &quot;i&quot; } },&#10;          { farmName: { $regex: search, $options: &quot;i&quot; } },&#10;    } else {&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: { location: { $regex: location, $options: &quot;i&quot; } },&#10;      };&#10;      total: totalCount,&#10;      page,&#10;      totalPages: Math.ceil(totalCount / limit),&#10;      hasNextPage: page * limit &lt; totalCount,&#10;      hasPrevPage: page &gt; 1,&#10;      },&#10;    };&#10;    directFarmerMatch.specializations = {&#10;  // Handle both direct farmers and nested farmers structure&#10;        const productsUpdateResult = await db.collection(&quot;products&quot;).updateMany(&#10;  const nestedFarmerMatch = {};&#10;&#10;  // Add search filters&#10;// Get total count for pagination&#10;  const matchStage = { $match: { $or: [] } };&#10;        $or: [&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;    directFarmerMatch.$text = { $search: search };&#10;    nestedFarmerMatch[&quot;farmers&quot;] = {&#10;&#10;      $elemMatch: {&#10;        $or: [&#10;    directFarmerMatch.specializations = {&#10;          { description: { $regex: search, $options: &quot;i&quot; } },&#10;          { location: { $regex: search, $options: &quot;i&quot; } },&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        specializations: {&#10;          $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;        },&#10;      });&#10;    } else {&#10;  // If no specific filters, match all documents&#10;  if (matchStage.$match.$or.length === 0) {&#10;    matchStage.$match = {};&#10;  }&#10;&#10;  pipeline.push(matchStage);&#10;&#10;  // Add facet stage for both direct and nested farmers&#10;  pipeline.push({&#10;    $facet: {&#10;      directFarmers: [&#10;        { $match: { name: { $exists: true }, location: { $exists: true } } },&#10;        { $project: { farmers: 0 } }, // Exclude nested farmers array&#10;      ],&#10;      nestedFarmers: [&#10;        { $match: { farmers: { $exists: true, $type: &quot;array&quot; } } },&#10;        { $unwind: &quot;$farmers&quot; },&#10;        { $replaceRoot: { newRoot: &quot;$farmers&quot; } },&#10;      ],&#10;    },&#10;  });&#10;&#10;  // Combine results&#10;  pipeline.push({&#10;  const pipeline = [];&#10;        const productsUpdateResult = await db.collection(&quot;products&quot;).updateMany(&#10;  // Build match stage (same as main query)&#10;  const matchStage = { $match: { $or: [] } };&#10;  pipeline.push({ $unwind: &quot;$allFarmers&quot; });&#10;  const directFarmerMatch = {};&#10;  const nestedFarmerMatch = {};&#10;&#10;&#10;  // Add sorting (by verification status, then name)&#10;    directFarmerMatch.$text = { $search: search };&#10;    nestedFarmerMatch[&quot;farmers&quot;] = {&#10;      $elemMatch: {&#10;    directFarmerMatch.specializations = {&#10;          { name: { $regex: search, $options: &quot;i&quot; } },&#10;          { description: { $regex: search, $options: &quot;i&quot; } },&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        specializations: {&#10;          $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;    directFarmerMatch.location = { $regex: location, $options: &quot;i&quot; };&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or =&#10;        nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or || [];&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        location: { $regex: location, $options: &quot;i&quot; },&#10;      });&#10;    } else {&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: { location: { $regex: location, $options: &quot;i&quot; } },&#10;      };&#10;    }&#10;  }&#10;&#10;  if (Object.keys(directFarmerMatch).length &gt; 0) {&#10;    directFarmerMatch.name = { $exists: true };&#10;    directFarmerMatch.location = { $exists: true };&#10;    matchStage.$match.$or.push(directFarmerMatch);&#10;  }&#10;&#10;  if (Object.keys(nestedFarmerMatch).length &gt; 0) {&#10;    matchStage.$match.$or.push(nestedFarmerMatch);&#10;  }&#10;&#10;  if (matchStage.$match.$or.length === 0) {&#10;      : 50; // Increased default limit to show all farmers&#10;      });&#10;    const includeStats = searchParams.get(&quot;includeStats&quot;) !== &quot;false&quot;; // Default to true&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: {&#10;          specializations: {&#10;            $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;          },&#10;        },&#10;      };&#10;    }&#10;          { location: { $regex: search, $options: &quot;i&quot; } },&#10;          { farmName: { $regex: search, $options: &quot;i&quot; } },&#10;      },&#10;    };&#10;    // Get farmers using optimized aggregation pipeline&#10;      };&#10;    }&#10;          { farmName: { $regex: search, $options: &quot;i&quot; } },&#10;        ],&#10;      },&#10;    };&#10;    directFarmerMatch.location = { $regex: location, $options: &quot;i&quot; };&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or =&#10;        nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or || [];&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        location: { $regex: location, $options: &quot;i&quot; },&#10;      });&#10;    } else {&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: { location: { $regex: location, $options: &quot;i&quot; } },&#10;      };&#10;    // Enhance farmers with product statistics if requested&#10;  }&#10;&#10;  // Add conditions for direct farmers&#10;  if (Object.keys(directFarmerMatch).length &gt; 0) {&#10;    directFarmerMatch.name = { $exists: true };&#10;    directFarmerMatch.location = { $exists: true };&#10;    matchStage.$match.$or.push(directFarmerMatch);&#10;  }&#10;&#10;  // Add conditions for nested farmers&#10;  if (Object.keys(nestedFarmerMatch).length &gt; 0) {&#10;  }&#10;&#10;  pipeline.push(matchStage);&#10;&#10;      total: totalCount,&#10;      page,&#10;      totalPages: Math.ceil(totalCount / limit),&#10;      hasNextPage: page * limit &lt; totalCount,&#10;      hasPrevPage: page &gt; 1,&#10;  });&#10;&#10;  // Combine results&#10;  pipeline.push({&#10;  const pipeline = [];&#10;&#10;  // Build match stage (same as main query)&#10;  const matchStage = { $match: { $or: [] } };&#10;  pipeline.push(matchStage);&#10;&#10;  pipeline.push({&#10;    $facet: {&#10;      directFarmers: [&#10;        { $match: { name: { $exists: true }, location: { $exists: true } } },&#10;        { $count: &quot;count&quot; },&#10;&#10;      ],&#10;      nestedFarmers: [&#10;        { $match: { farmers: { $exists: true, $type: &quot;array&quot; } } },&#10;        { $unwind: &quot;$farmers&quot; },&#10;        { $count: &quot;count&quot; },&#10;      ],&#10;    },&#10;  });&#10;&#10;  const result = await farmersCollection.aggregate(pipeline).toArray();&#10;&#10;  if (result.length === 0) return 0;&#10;&#10;  const directCount = result[0].directFarmers[0]?.count || 0;&#10;  const nestedCount = result[0].nestedFarmers[0]?.count || 0;&#10;&#10;  return directCount + nestedCount;&#10;  const directFarmerMatch = {};&#10;  const nestedFarmerMatch = {};&#10;&#10;&#10;  // Add sorting (by verification status, then name)&#10;    directFarmerMatch.$text = { $search: search };&#10;    nestedFarmerMatch[&quot;farmers&quot;] = {&#10;      $elemMatch: {&#10;    directFarmerMatch.specializations = {&#10;          { name: { $regex: search, $options: &quot;i&quot; } },&#10;          { description: { $regex: search, $options: &quot;i&quot; } },&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        specializations: {&#10;          $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;    directFarmerMatch.location = { $regex: location, $options: &quot;i&quot; };&#10;    console.error(&quot;Error fetching farmers:&quot;, error);&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or =&#10;        nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or || [];&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        location: { $regex: location, $options: &quot;i&quot; },&#10;      });&#10;    } else {&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: { location: { $regex: location, $options: &quot;i&quot; } },&#10;  if (Object.keys(directFarmerMatch).length &gt; 0) {&#10;    directFarmerMatch.name = { $exists: true };&#10;    directFarmerMatch.location = { $exists: true };&#10;    matchStage.$match.$or.push(directFarmerMatch);&#10;  }&#10;&#10;  if (Object.keys(nestedFarmerMatch).length &gt; 0) {&#10;    matchStage.$match.$or.push(nestedFarmerMatch);&#10;  }&#10;&#10;      : 50; // Increased default limit to show all farmers&#10;    matchStage.$match = {};&#10;      });&#10;    const includeStats = searchParams.get(&quot;includeStats&quot;) !== &quot;false&quot;; // Default to true&#10;&#10;  pipeline.push({&#10;    $facet: {&#10;      directFarmers: [&#10;        { $match: { name: { $exists: true }, location: { $exists: true } } },&#10;        { $count: &quot;count&quot; },&#10;      ],&#10;      nestedFarmers: [&#10;        { $match: { farmers: { $exists: true, $type: &quot;array&quot; } } },&#10;        { $unwind: &quot;$farmers&quot; },&#10;        { $count: &quot;count&quot; },&#10;      ],&#10;    },&#10;  });&#10;&#10;  const result = await farmersCollection.aggregate(pipeline).toArray();&#10;&#10;  if (result.length === 0) return 0;&#10;&#10;  const directCount = result[0].directFarmers[0]?.count || 0;&#10;  const nestedCount = result[0].nestedFarmers[0]?.count || 0;&#10;&#10;  return directCount + nestedCount;&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: {&#10;  const pipeline = [];&#10;          },&#10;        },&#10;      };&#10;    // Enhance farmers with product statistics if requested&#10;          { location: { $regex: search, $options: &quot;i&quot; } },&#10;          { farmName: { $regex: search, $options: &quot;i&quot; } },&#10;      },&#10;    };&#10;    // Get farmers using optimized aggregation pipeline&#10;&#10;  // Add facet stage for both direct and nested farmers&#10;  pipeline.push({&#10;    $facet: {&#10;      directFarmers: [&#10;        { $match: { name: { $exists: true }, location: { $exists: true } } },&#10;        { $project: { farmers: 0 } }, // Exclude nested farmers array&#10;      ],&#10;      nestedFarmers: [&#10;        { $match: { farmers: { $exists: true, $type: &quot;array&quot; } } },&#10;        { $unwind: &quot;$farmers&quot; },&#10;        { $replaceRoot: { newRoot: &quot;$farmers&quot; } },&#10;      ],&#10;    },&#10;  });&#10;&#10;  // Combine results&#10;  pipeline.push({&#10;  const pipeline = [];&#10;        const productsUpdateResult = await db.collection(&quot;products&quot;).updateMany(&#10;  // Build match stage (same as main query)&#10;  const matchStage = { $match: { $or: [] } };&#10;  pipeline.push({ $unwind: &quot;$allFarmers&quot; });&#10;  const directFarmerMatch = {};&#10;  const nestedFarmerMatch = {};&#10;&#10;&#10;  // Add sorting (by verification status, then name)&#10;    directFarmerMatch.$text = { $search: search };&#10;    nestedFarmerMatch[&quot;farmers&quot;] = {&#10;      $elemMatch: {&#10;    directFarmerMatch.specializations = {&#10;          { name: { $regex: search, $options: &quot;i&quot; } },&#10;          { description: { $regex: search, $options: &quot;i&quot; } },&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        specializations: {&#10;          $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;    directFarmerMatch.location = { $regex: location, $options: &quot;i&quot; };&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or =&#10;        nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or || [];&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        location: { $regex: location, $options: &quot;i&quot; },&#10;      });&#10;    } else {&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: { location: { $regex: location, $options: &quot;i&quot; } },&#10;      };&#10;    }&#10;  }&#10;&#10;  if (Object.keys(directFarmerMatch).length &gt; 0) {&#10;    directFarmerMatch.name = { $exists: true };&#10;    directFarmerMatch.location = { $exists: true };&#10;    matchStage.$match.$or.push(directFarmerMatch);&#10;  }&#10;&#10;  if (Object.keys(nestedFarmerMatch).length &gt; 0) {&#10;    matchStage.$match.$or.push(nestedFarmerMatch);&#10;  }&#10;&#10;  if (matchStage.$match.$or.length === 0) {&#10;      : 50; // Increased default limit to show all farmers&#10;      });&#10;    const includeStats = searchParams.get(&quot;includeStats&quot;) !== &quot;false&quot;; // Default to true&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: {&#10;          specializations: {&#10;            $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;          },&#10;        },&#10;      };&#10;    }&#10;          { location: { $regex: search, $options: &quot;i&quot; } },&#10;          { farmName: { $regex: search, $options: &quot;i&quot; } },&#10;      },&#10;    };&#10;    // Get farmers using optimized aggregation pipeline&#10;      };&#10;    }&#10;          { farmName: { $regex: search, $options: &quot;i&quot; } },&#10;        ],&#10;      },&#10;    };&#10;    directFarmerMatch.location = { $regex: location, $options: &quot;i&quot; };&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or =&#10;        nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or || [];&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        location: { $regex: location, $options: &quot;i&quot; },&#10;      });&#10;    } else {&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: { location: { $regex: location, $options: &quot;i&quot; } },&#10;      };&#10;    // Enhance farmers with product statistics if requested&#10;  }&#10;&#10;  // Add conditions for direct farmers&#10;  if (Object.keys(directFarmerMatch).length &gt; 0) {&#10;    directFarmerMatch.name = { $exists: true };&#10;    directFarmerMatch.location = { $exists: true };&#10;    matchStage.$match.$or.push(directFarmerMatch);&#10;  }&#10;&#10;  // Add conditions for nested farmers&#10;  if (Object.keys(nestedFarmerMatch).length &gt; 0) {&#10;  }&#10;&#10;  pipeline.push(matchStage);&#10;&#10;      total: totalCount,&#10;      page,&#10;      totalPages: Math.ceil(totalCount / limit),&#10;      hasNextPage: page * limit &lt; totalCount,&#10;      hasPrevPage: page &gt; 1,&#10;  });&#10;&#10;  // Combine results&#10;  pipeline.push({&#10;  const pipeline = [];&#10;&#10;  // Build match stage (same as main query)&#10;  const matchStage = { $match: { $or: [] } };&#10;  pipeline.push(matchStage);&#10;&#10;  pipeline.push({&#10;    $facet: {&#10;      directFarmers: [&#10;        { $match: { name: { $exists: true }, location: { $exists: true } } },&#10;        { $count: &quot;count&quot; },&#10;&#10;      ],&#10;      nestedFarmers: [&#10;        { $match: { farmers: { $exists: true, $type: &quot;array&quot; } } },&#10;        { $unwind: &quot;$farmers&quot; },&#10;        { $count: &quot;count&quot; },&#10;      ],&#10;    },&#10;  });&#10;&#10;  const result = await farmersCollection.aggregate(pipeline).toArray();&#10;&#10;  if (result.length === 0) return 0;&#10;&#10;  const directCount = result[0].directFarmers[0]?.count || 0;&#10;  const nestedCount = result[0].nestedFarmers[0]?.count || 0;&#10;&#10;  return directCount + nestedCount;&#10;  const directFarmerMatch = {};&#10;  const nestedFarmerMatch = {};&#10;&#10;&#10;  // Add sorting (by verification status, then name)&#10;    directFarmerMatch.$text = { $search: search };&#10;    nestedFarmerMatch[&quot;farmers&quot;] = {&#10;      $elemMatch: {&#10;    directFarmerMatch.specializations = {&#10;          { name: { $regex: search, $options: &quot;i&quot; } },&#10;          { description: { $regex: search, $options: &quot;i&quot; } },&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        specializations: {&#10;          $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;    directFarmerMatch.location = { $regex: location, $options: &quot;i&quot; };&#10;    console.error(&quot;Error fetching farmers:&quot;, error);&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or =&#10;        nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or || [];&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        location: { $regex: location, $options: &quot;i&quot; },&#10;      });&#10;    } else {&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: { location: { $regex: location, $options: &quot;i&quot; } },&#10;  if (Object.keys(directFarmerMatch).length &gt; 0) {&#10;    directFarmerMatch.name = { $exists: true };&#10;    directFarmerMatch.location = { $exists: true };&#10;    matchStage.$match.$or.push(directFarmerMatch);&#10;  }&#10;&#10;  if (Object.keys(nestedFarmerMatch).length &gt; 0) {&#10;    matchStage.$match.$or.push(nestedFarmerMatch);&#10;  }&#10;&#10;      : 50; // Increased default limit to show all farmers&#10;    matchStage.$match = {};&#10;      });&#10;    const includeStats = searchParams.get(&quot;includeStats&quot;) !== &quot;false&quot;; // Default to true&#10;&#10;  pipeline.push({&#10;    $facet: {&#10;      directFarmers: [&#10;        { $match: { name: { $exists: true }, location: { $exists: true } } },&#10;        { $count: &quot;count&quot; },&#10;      ],&#10;      nestedFarmers: [&#10;        { $match: { farmers: { $exists: true, $type: &quot;array&quot; } } },&#10;        { $unwind: &quot;$farmers&quot; },&#10;        { $count: &quot;count&quot; },&#10;      ],&#10;    },&#10;  });&#10;&#10;  const result = await farmersCollection.aggregate(pipeline).toArray();&#10;&#10;  if (result.length === 0) return 0;&#10;&#10;  const directCount = result[0].directFarmers[0]?.count || 0;&#10;  const nestedCount = result[0].nestedFarmers[0]?.count || 0;&#10;&#10;  return directCount + nestedCount;&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: {&#10;          specializations: {&#10;            $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;          },&#10;        },&#10;      };&#10;    // Enhance farmers with product statistics if requested&#10;          { location: { $regex: search, $options: &quot;i&quot; } },&#10;          { farmName: { $regex: search, $options: &quot;i&quot; } },&#10;      },&#10;    };&#10;    // Get farmers using optimized aggregation pipeline&#10;      };&#10;    }&#10;          { name: { $regex: search, $options: &quot;i&quot; } },&#10;          { description: { $regex: search, $options: &quot;i&quot; } },&#10;          { location: { $regex: search, $options: &quot;i&quot; } },&#10;          { farmName: { $regex: search, $options: &quot;i&quot; } },&#10;    } else {&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: { location: { $regex: location, $options: &quot;i&quot; } },&#10;      };&#10;      total: totalCount,&#10;      page,&#10;      totalPages: Math.ceil(totalCount / limit),&#10;      hasNextPage: page * limit &lt; totalCount,&#10;      hasPrevPage: page &gt; 1,&#10;      },&#10;    };&#10;    directFarmerMatch.specializations = {&#10;&#10;// Get total count for pagination&#10;  const matchStage = { $match: { $or: [] } };&#10;&#10;  // Handle both direct farmers and nested farmers structure&#10;        const productsUpdateResult = await db.collection(&quot;products&quot;).updateMany(&#10;  const nestedFarmerMatch = {};&#10;&#10;  // Add search filters&#10;    }&#10;  }&#10;        $or: [&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;    directFarmerMatch.$text = { $search: search };&#10;    nestedFarmerMatch[&quot;farmers&quot;] = {&#10;&#10;      $elemMatch: {&#10;        $or: [&#10;    directFarmerMatch.specializations = {&#10;          { description: { $regex: search, $options: &quot;i&quot; } },&#10;          { location: { $regex: search, $options: &quot;i&quot; } },&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        specializations: {&#10;          $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;        },&#10;      });&#10;    } else {&#10;  // If no specific filters, match all documents&#10;  if (matchStage.$match.$or.length === 0) {&#10;    matchStage.$match = {};&#10;  }&#10;&#10;  pipeline.push(matchStage);&#10;&#10;  // Add facet stage for both direct and nested farmers&#10;  pipeline.push({&#10;    $facet: {&#10;      directFarmers: [&#10;        { $match: { name: { $exists: true }, location: { $exists: true } } },&#10;        { $project: { farmers: 0 } }, // Exclude nested farmers array&#10;      ],&#10;      nestedFarmers: [&#10;        { $match: { farmers: { $exists: true, $type: &quot;array&quot; } } },&#10;        { $unwind: &quot;$farmers&quot; },&#10;        { $replaceRoot: { newRoot: &quot;$farmers&quot; } },&#10;      ],&#10;    },&#10;  });&#10;&#10;  // Combine results&#10;  pipeline.push({&#10;  const pipeline = [];&#10;        const productsUpdateResult = await db.collection(&quot;products&quot;).updateMany(&#10;  // Build match stage (same as main query)&#10;  const matchStage = { $match: { $or: [] } };&#10;  pipeline.push({ $unwind: &quot;$allFarmers&quot; });&#10;  const directFarmerMatch = {};&#10;  const nestedFarmerMatch = {};&#10;&#10;&#10;  // Add sorting (by verification status, then name)&#10;    directFarmerMatch.$text = { $search: search };&#10;    nestedFarmerMatch[&quot;farmers&quot;] = {&#10;      $elemMatch: {&#10;    directFarmerMatch.specializations = {&#10;          { name: { $regex: search, $options: &quot;i&quot; } },&#10;          { description: { $regex: search, $options: &quot;i&quot; } },&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        specializations: {&#10;          $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;    directFarmerMatch.location = { $regex: location, $options: &quot;i&quot; };&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or =&#10;        nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or || [];&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        location: { $regex: location, $options: &quot;i&quot; },&#10;      });&#10;    } else {&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: { location: { $regex: location, $options: &quot;i&quot; } },&#10;      };&#10;    }&#10;  }&#10;&#10;  if (Object.keys(directFarmerMatch).length &gt; 0) {&#10;    directFarmerMatch.name = { $exists: true };&#10;    directFarmerMatch.location = { $exists: true };&#10;    matchStage.$match.$or.push(directFarmerMatch);&#10;  }&#10;&#10;  if (Object.keys(nestedFarmerMatch).length &gt; 0) {&#10;    matchStage.$match.$or.push(nestedFarmerMatch);&#10;  }&#10;&#10;  if (matchStage.$match.$or.length === 0) {&#10;      : 50; // Increased default limit to show all farmers&#10;      });&#10;    const includeStats = searchParams.get(&quot;includeStats&quot;) !== &quot;false&quot;; // Default to true&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: {&#10;          specializations: {&#10;            $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;          },&#10;        },&#10;      };&#10;    }&#10;          { location: { $regex: search, $options: &quot;i&quot; } },&#10;          { farmName: { $regex: search, $options: &quot;i&quot; } },&#10;      },&#10;    };&#10;    // Get farmers using optimized aggregation pipeline&#10;      };&#10;    }&#10;          { farmName: { $regex: search, $options: &quot;i&quot; } },&#10;        ],&#10;      },&#10;    };&#10;    directFarmerMatch.location = { $regex: location, $options: &quot;i&quot; };&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or =&#10;        nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or || [];&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        location: { $regex: location, $options: &quot;i&quot; },&#10;      });&#10;    } else {&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: { location: { $regex: location, $options: &quot;i&quot; } },&#10;      };&#10;    // Enhance farmers with product statistics if requested&#10;  }&#10;&#10;  // Add conditions for direct farmers&#10;  if (Object.keys(directFarmerMatch).length &gt; 0) {&#10;    directFarmerMatch.name = { $exists: true };&#10;    directFarmerMatch.location = { $exists: true };&#10;    matchStage.$match.$or.push(directFarmerMatch);&#10;  }&#10;&#10;  // Add conditions for nested farmers&#10;  if (Object.keys(nestedFarmerMatch).length &gt; 0) {&#10;  }&#10;&#10;  pipeline.push(matchStage);&#10;&#10;      total: totalCount,&#10;      page,&#10;      totalPages: Math.ceil(totalCount / limit),&#10;      hasNextPage: page * limit &lt; totalCount,&#10;      hasPrevPage: page &gt; 1,&#10;  });&#10;&#10;  // Combine results&#10;  pipeline.push({&#10;  const pipeline = [];&#10;&#10;  // Build match stage (same as main query)&#10;  const matchStage = { $match: { $or: [] } };&#10;  pipeline.push(matchStage);&#10;&#10;  pipeline.push({&#10;    $facet: {&#10;      directFarmers: [&#10;        { $match: { name: { $exists: true }, location: { $exists: true } } },&#10;        { $count: &quot;count&quot; },&#10;&#10;      ],&#10;      nestedFarmers: [&#10;        { $match: { farmers: { $exists: true, $type: &quot;array&quot; } } },&#10;        { $unwind: &quot;$farmers&quot; },&#10;        { $count: &quot;count&quot; },&#10;      ],&#10;    },&#10;  });&#10;&#10;  const result = await farmersCollection.aggregate(pipeline).toArray();&#10;&#10;  if (result.length === 0) return 0;&#10;&#10;  const directCount = result[0].directFarmers[0]?.count || 0;&#10;  const nestedCount = result[0].nestedFarmers[0]?.count || 0;&#10;&#10;  return directCount + nestedCount;&#10;  const directFarmerMatch = {};&#10;  const nestedFarmerMatch = {};&#10;&#10;&#10;  // Add sorting (by verification status, then name)&#10;    directFarmerMatch.$text = { $search: search };&#10;    nestedFarmerMatch[&quot;farmers&quot;] = {&#10;      $elemMatch: {&#10;    directFarmerMatch.specializations = {&#10;          { name: { $regex: search, $options: &quot;i&quot; } },&#10;          { description: { $regex: search, $options: &quot;i&quot; } },&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        specializations: {&#10;          $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;    directFarmerMatch.location = { $regex: location, $options: &quot;i&quot; };&#10;    console.error(&quot;Error fetching farmers:&quot;, error);&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or =&#10;        nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or || [];&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        location: { $regex: location, $options: &quot;i&quot; },&#10;      });&#10;    } else {&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: { location: { $regex: location, $options: &quot;i&quot; } },&#10;  if (Object.keys(directFarmerMatch).length &gt; 0) {&#10;    directFarmerMatch.name = { $exists: true };&#10;    directFarmerMatch.location = { $exists: true };&#10;    matchStage.$match.$or.push(directFarmerMatch);&#10;  }&#10;&#10;  if (Object.keys(nestedFarmerMatch).length &gt; 0) {&#10;    matchStage.$match.$or.push(nestedFarmerMatch);&#10;  }&#10;&#10;      : 50; // Increased default limit to show all farmers&#10;    matchStage.$match = {};&#10;      });&#10;    const includeStats = searchParams.get(&quot;includeStats&quot;) !== &quot;false&quot;; // Default to true&#10;&#10;  pipeline.push({&#10;    $facet: {&#10;      directFarmers: [&#10;        { $match: { name: { $exists: true }, location: { $exists: true } } },&#10;        { $count: &quot;count&quot; },&#10;      ],&#10;      nestedFarmers: [&#10;        { $match: { farmers: { $exists: true, $type: &quot;array&quot; } } },&#10;        { $unwind: &quot;$farmers&quot; },&#10;        { $count: &quot;count&quot; },&#10;      ],&#10;    },&#10;  });&#10;&#10;  const result = await farmersCollection.aggregate(pipeline).toArray();&#10;&#10;  if (result.length === 0) return 0;&#10;&#10;  const directCount = result[0].directFarmers[0]?.count || 0;&#10;  const nestedCount = result[0].nestedFarmers[0]?.count || 0;&#10;&#10;  return directCount + nestedCount;&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: {&#10;  const pipeline = [];&#10;          },&#10;        },&#10;      };&#10;    // Enhance farmers with product statistics if requested&#10;          { location: { $regex: search, $options: &quot;i&quot; } },&#10;          { farmName: { $regex: search, $options: &quot;i&quot; } },&#10;      },&#10;    };&#10;    // Get farmers using optimized aggregation pipeline&#10;        options: { background: true },&#10;      },&#10;  const pipeline = [];&#10;// Optimized farmers query using aggregation pipeline&#10;  // Build match stage for filtering&#10;  const matchStage = { $match: { $or: [] } };&#10;    console.log(&quot;Atlas-optimized farmers indexes initialized successfully&quot;);&#10;      {&#10;        key: { &quot;farmers.name&quot;: 1, &quot;farmers.location&quot;: 1 },&#10;        name: &quot;nested_farmers_search_idx&quot;,&#10;  // Handle both direct farmers and nested farmers structure&#10;  const directFarmerMatch = {};&#10;  const nestedFarmerMatch = {};&#10;&#10;  // Add search filters&#10;      },&#10;// Get total count for pagination&#10;  const matchStage = { $match: { $or: [] } };&#10;&#10;    directFarmerMatch.$text = { $search: search };&#10;    nestedFarmerMatch[&quot;farmers&quot;] = {&#10;      $elemMatch: {&#10;        $or: [&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;    directFarmerMatch.$text = { $search: search };&#10;    nestedFarmerMatch[&quot;farmers&quot;] = {&#10;&#10;      $elemMatch: {&#10;        $or: [&#10;    directFarmerMatch.specializations = {&#10;          { description: { $regex: search, $options: &quot;i&quot; } },&#10;          { location: { $regex: search, $options: &quot;i&quot; } },&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        specializations: {&#10;          $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;        },&#10;      });&#10;    } else {&#10;  // If no specific filters, match all documents&#10;  if (matchStage.$match.$or.length === 0) {&#10;    matchStage.$match = {};&#10;  }&#10;&#10;  pipeline.push(matchStage);&#10;&#10;  // Add facet stage for both direct and nested farmers&#10;  pipeline.push({&#10;    $facet: {&#10;  const pipeline = [];&#10;        { $project: { farmers: 0 } }, // Exclude nested farmers array&#10;  // Build match stage for filtering&#10;  const matchStage = { $match: { $or: [] } };&#10;        { $unwind: &quot;$farmers&quot; },&#10;        { $replaceRoot: { newRoot: &quot;$farmers&quot; } },&#10;      ],&#10;  // Handle both direct farmers and nested farmers structure&#10;  const directFarmerMatch = {};&#10;  const nestedFarmerMatch = {};&#10;&#10;  // Add search filters&#10;  });&#10;&#10;  // Combine results&#10;    }&#10;          { name: { $regex: search, $options: &quot;i&quot; } },&#10;          { description: { $regex: search, $options: &quot;i&quot; } },&#10;          { location: { $regex: search, $options: &quot;i&quot; } },&#10;          { farmName: { $regex: search, $options: &quot;i&quot; } },&#10;    } else {&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: { location: { $regex: location, $options: &quot;i&quot; } },&#10;      };&#10;      total: totalCount,&#10;      page,&#10;      totalPages: Math.ceil(totalCount / limit),&#10;  // Build match stage for filtering&#10;  const matchStage = { $match: { $or: [] } };&#10;    };&#10;  // Handle both direct farmers and nested farmers structure&#10;  const directFarmerMatch = {};&#10;  const nestedFarmerMatch = {};&#10;&#10;  // Add search filters&#10;  pipeline.push({&#10;// Get total count for pagination&#10;  const matchStage = { $match: { $or: [] } };&#10;&#10;    directFarmerMatch.$text = { $search: search };&#10;    nestedFarmerMatch[&quot;farmers&quot;] = {&#10;      $elemMatch: {&#10;        $or: [&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;    directFarmerMatch.$text = { $search: search };&#10;    nestedFarmerMatch[&quot;farmers&quot;] = {&#10;&#10;      $elemMatch: {&#10;        $or: [&#10;    directFarmerMatch.specializations = {&#10;          { description: { $regex: search, $options: &quot;i&quot; } },&#10;          { location: { $regex: search, $options: &quot;i&quot; } },&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        specializations: {&#10;          $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;        },&#10;      });&#10;    } else {&#10;  // If no specific filters, match all documents&#10;  if (matchStage.$match.$or.length === 0) {&#10;    matchStage.$match = {};&#10;  }&#10;&#10;  pipeline.push(matchStage);&#10;&#10;  // Add facet stage for both direct and nested farmers&#10;  pipeline.push({&#10;    $facet: {&#10;      directFarmers: [&#10;        { $match: { name: { $exists: true }, location: { $exists: true } } },&#10;        { $project: { farmers: 0 } }, // Exclude nested farmers array&#10;      ],&#10;      nestedFarmers: [&#10;        { $match: { farmers: { $exists: true, $type: &quot;array&quot; } } },&#10;        { $unwind: &quot;$farmers&quot; },&#10;        { $replaceRoot: { newRoot: &quot;$farmers&quot; } },&#10;      ],&#10;    },&#10;  });&#10;&#10;  // Combine results&#10;  pipeline.push({&#10;  const pipeline = [];&#10;        const productsUpdateResult = await db.collection(&quot;products&quot;).updateMany(&#10;  // Build match stage (same as main query)&#10;  const matchStage = { $match: { $or: [] } };&#10;  pipeline.push({ $unwind: &quot;$allFarmers&quot; });&#10;  const directFarmerMatch = {};&#10;  const nestedFarmerMatch = {};&#10;&#10;&#10;  // Add sorting (by verification status, then name)&#10;    directFarmerMatch.$text = { $search: search };&#10;    nestedFarmerMatch[&quot;farmers&quot;] = {&#10;      $elemMatch: {&#10;    directFarmerMatch.specializations = {&#10;          { name: { $regex: search, $options: &quot;i&quot; } },&#10;          { description: { $regex: search, $options: &quot;i&quot; } },&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        specializations: {&#10;          $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;    directFarmerMatch.location = { $regex: location, $options: &quot;i&quot; };&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or =&#10;        nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or || [];&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        location: { $regex: location, $options: &quot;i&quot; },&#10;      });&#10;    } else {&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: { location: { $regex: location, $options: &quot;i&quot; } },&#10;      };&#10;    }&#10;  }&#10;&#10;  if (Object.keys(directFarmerMatch).length &gt; 0) {&#10;    directFarmerMatch.name = { $exists: true };&#10;    directFarmerMatch.location = { $exists: true };&#10;    matchStage.$match.$or.push(directFarmerMatch);&#10;  }&#10;&#10;  if (Object.keys(nestedFarmerMatch).length &gt; 0) {&#10;    matchStage.$match.$or.push(nestedFarmerMatch);&#10;  }&#10;&#10;      : 50; // Increased default limit to show all farmers&#10;    matchStage.$match = {};&#10;      });&#10;    const includeStats = searchParams.get(&quot;includeStats&quot;) !== &quot;false&quot;; // Default to true&#10;&#10;  pipeline.push({&#10;    $facet: {&#10;      directFarmers: [&#10;        { $match: { name: { $exists: true }, location: { $exists: true } } },&#10;        { $count: &quot;count&quot; },&#10;      ],&#10;      nestedFarmers: [&#10;        { $match: { farmers: { $exists: true, $type: &quot;array&quot; } } },&#10;        { $unwind: &quot;$farmers&quot; },&#10;        { $count: &quot;count&quot; },&#10;      ],&#10;    },&#10;  });&#10;&#10;  const result = await farmersCollection.aggregate(pipeline).toArray();&#10;&#10;  if (result.length === 0) return 0;&#10;&#10;  const directCount = result[0].directFarmers[0]?.count || 0;&#10;  const nestedCount = result[0].nestedFarmers[0]?.count || 0;&#10;&#10;  return directCount + nestedCount;&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: {&#10;          specializations: {&#10;            $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;          },&#10;        },&#10;      };&#10;    // Enhance farmers with product statistics if requested&#10;          { location: { $regex: search, $options: &quot;i&quot; } },&#10;          { farmName: { $regex: search, $options: &quot;i&quot; } },&#10;      },&#10;    };&#10;    // Get farmers using optimized aggregation pipeline&#10;      };&#10;    }&#10;          { farmName: { $regex: search, $options: &quot;i&quot; } },&#10;        ],&#10;      },&#10;    };&#10;    } else {&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: { location: { $regex: location, $options: &quot;i&quot; } },&#10;      };&#10;    }&#10;  }&#10;&#10;  // Add conditions for direct farmers&#10;      total: totalCount,&#10;      page,&#10;      totalPages: Math.ceil(totalCount / limit),&#10;      hasNextPage: page * limit &lt; totalCount,&#10;      hasPrevPage: page &gt; 1,&#10;// Get total count for pagination&#10;    matchStage.$match = {};&#10;  }&#10;&#10;  pipeline.push(matchStage);&#10;&#10;  // Add facet stage for both direct and nested farmers&#10;  pipeline.push({&#10;    $facet: {&#10;      directFarmers: [&#10;        { $match: { name: { $exists: true }, location: { $exists: true } } },&#10;&#10;        { $project: { farmers: 0 } }, // Exclude nested farmers array&#10;      ],&#10;      nestedFarmers: [&#10;        { $match: { farmers: { $exists: true, $type: &quot;array&quot; } } },&#10;        { $unwind: &quot;$farmers&quot; },&#10;        { $replaceRoot: { newRoot: &quot;$farmers&quot; } },&#10;      ],&#10;    },&#10;  });&#10;&#10;    console.error(&quot;Error fetching farmers:&quot;, error);&#10;  pipeline.push({&#10;  const pipeline = [];&#10;&#10;  // Build match stage (same as main query)&#10;  const matchStage = { $match: { $or: [] } };&#10;  pipeline.push({ $unwind: &quot;$allFarmers&quot; });&#10;  const directFarmerMatch = {};&#10;  const nestedFarmerMatch = {};&#10;&#10;&#10;  // Add sorting (by verification status, then name)&#10;    directFarmerMatch.$text = { $search: search };&#10;    nestedFarmerMatch[&quot;farmers&quot;] = {&#10;      $elemMatch: {&#10;    directFarmerMatch.specializations = {&#10;          { name: { $regex: search, $options: &quot;i&quot; } },&#10;          { description: { $regex: search, $options: &quot;i&quot; } },&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        specializations: {&#10;          $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;    directFarmerMatch.location = { $regex: location, $options: &quot;i&quot; };&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or =&#10;        nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or || [];&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        location: { $regex: location, $options: &quot;i&quot; },&#10;      });&#10;    } else {&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: { location: { $regex: location, $options: &quot;i&quot; } },&#10;      };&#10;    }&#10;  }&#10;&#10;  if (Object.keys(directFarmerMatch).length &gt; 0) {&#10;    directFarmerMatch.name = { $exists: true };&#10;    directFarmerMatch.location = { $exists: true };&#10;    matchStage.$match.$or.push(directFarmerMatch);&#10;  }&#10;&#10;  if (Object.keys(nestedFarmerMatch).length &gt; 0) {&#10;    matchStage.$match.$or.push(nestedFarmerMatch);&#10;  }&#10;&#10;      : 50; // Increased default limit to show all farmers&#10;    matchStage.$match = {};&#10;      });&#10;    const includeStats = searchParams.get(&quot;includeStats&quot;) !== &quot;false&quot;; // Default to true&#10;&#10;  pipeline.push({&#10;    $facet: {&#10;      directFarmers: [&#10;        { $match: { name: { $exists: true }, location: { $exists: true } } },&#10;        { $count: &quot;count&quot; },&#10;      ],&#10;      nestedFarmers: [&#10;        { $match: { farmers: { $exists: true, $type: &quot;array&quot; } } },&#10;        { $unwind: &quot;$farmers&quot; },&#10;        { $count: &quot;count&quot; },&#10;      ],&#10;    },&#10;  });&#10;&#10;  const result = await farmersCollection.aggregate(pipeline).toArray();&#10;&#10;  if (result.length === 0) return 0;&#10;&#10;  const directCount = result[0].directFarmers[0]?.count || 0;&#10;  const nestedCount = result[0].nestedFarmers[0]?.count || 0;&#10;&#10;  return directCount + nestedCount;&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: {&#10;          specializations: {&#10;            $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;          },&#10;        },&#10;      };&#10;    // Enhance farmers with product statistics if requested&#10;          { location: { $regex: search, $options: &quot;i&quot; } },&#10;          { farmName: { $regex: search, $options: &quot;i&quot; } },&#10;      },&#10;    };&#10;    // Get farmers using optimized aggregation pipeline&#10;      };&#10;    }&#10;          { name: { $regex: search, $options: &quot;i&quot; } },&#10;          { description: { $regex: search, $options: &quot;i&quot; } },&#10;          { location: { $regex: search, $options: &quot;i&quot; } },&#10;          { farmName: { $regex: search, $options: &quot;i&quot; } },&#10;    } else {&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: { location: { $regex: location, $options: &quot;i&quot; } },&#10;      };&#10;      total: totalCount,&#10;      page,&#10;      totalPages: Math.ceil(totalCount / limit),&#10;      hasNextPage: page * limit &lt; totalCount,&#10;      hasPrevPage: page &gt; 1,&#10;      },&#10;    };&#10;    directFarmerMatch.specializations = {&#10;  // Handle both direct farmers and nested farmers structure&#10;        const productsUpdateResult = await db.collection(&quot;products&quot;).updateMany(&#10;  const nestedFarmerMatch = {};&#10;&#10;  // Add search filters&#10;// Get total count for pagination&#10;  const matchStage = { $match: { $or: [] } };&#10;        $or: [&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;    directFarmerMatch.$text = { $search: search };&#10;    nestedFarmerMatch[&quot;farmers&quot;] = {&#10;&#10;      $elemMatch: {&#10;        $or: [&#10;    directFarmerMatch.specializations = {&#10;          { description: { $regex: search, $options: &quot;i&quot; } },&#10;          { location: { $regex: search, $options: &quot;i&quot; } },&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        specializations: {&#10;          $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;        },&#10;      });&#10;    } else {&#10;  // If no specific filters, match all documents&#10;  if (matchStage.$match.$or.length === 0) {&#10;    matchStage.$match = {};&#10;  }&#10;&#10;  pipeline.push(matchStage);&#10;&#10;  // Add facet stage for both direct and nested farmers&#10;  pipeline.push({&#10;    $facet: {&#10;      directFarmers: [&#10;        { $match: { name: { $exists: true }, location: { $exists: true } } },&#10;        { $project: { farmers: 0 } }, // Exclude nested farmers array&#10;      ],&#10;      nestedFarmers: [&#10;        { $match: { farmers: { $exists: true, $type: &quot;array&quot; } } },&#10;        { $unwind: &quot;$farmers&quot; },&#10;        { $replaceRoot: { newRoot: &quot;$farmers&quot; } },&#10;      ],&#10;    },&#10;  });&#10;&#10;  // Combine results&#10;  pipeline.push({&#10;  const pipeline = [];&#10;        const productsUpdateResult = await db.collection(&quot;products&quot;).updateMany(&#10;  // Build match stage (same as main query)&#10;  const matchStage = { $match: { $or: [] } };&#10;  pipeline.push({ $unwind: &quot;$allFarmers&quot; });&#10;  const directFarmerMatch = {};&#10;  const nestedFarmerMatch = {};&#10;&#10;&#10;  // Add sorting (by verification status, then name)&#10;    directFarmerMatch.$text = { $search: search };&#10;    nestedFarmerMatch[&quot;farmers&quot;] = {&#10;      $elemMatch: {&#10;    directFarmerMatch.specializations = {&#10;          { name: { $regex: search, $options: &quot;i&quot; } },&#10;          { description: { $regex: search, $options: &quot;i&quot; } },&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        specializations: {&#10;          $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;    directFarmerMatch.location = { $regex: location, $options: &quot;i&quot; };&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or =&#10;        nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or || [];&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        location: { $regex: location, $options: &quot;i&quot; },&#10;      });&#10;    } else {&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: { location: { $regex: location, $options: &quot;i&quot; } },&#10;      };&#10;    }&#10;  }&#10;&#10;  if (Object.keys(directFarmerMatch).length &gt; 0) {&#10;    directFarmerMatch.name = { $exists: true };&#10;    directFarmerMatch.location = { $exists: true };&#10;    matchStage.$match.$or.push(directFarmerMatch);&#10;  }&#10;&#10;  if (Object.keys(nestedFarmerMatch).length &gt; 0) {&#10;    matchStage.$match.$or.push(nestedFarmerMatch);&#10;  }&#10;&#10;  if (matchStage.$match.$or.length === 0) {&#10;      : 50; // Increased default limit to show all farmers&#10;      });&#10;    const includeStats = searchParams.get(&quot;includeStats&quot;) !== &quot;false&quot;; // Default to true&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: {&#10;          specializations: {&#10;            $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;          },&#10;        },&#10;      };&#10;    }&#10;          { location: { $regex: search, $options: &quot;i&quot; } },&#10;          { farmName: { $regex: search, $options: &quot;i&quot; } },&#10;      },&#10;    };&#10;    // Get farmers using optimized aggregation pipeline&#10;      };&#10;    }&#10;          { farmName: { $regex: search, $options: &quot;i&quot; } },&#10;        ],&#10;      },&#10;    };&#10;    directFarmerMatch.location = { $regex: location, $options: &quot;i&quot; };&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or =&#10;        nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or || [];&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        location: { $regex: location, $options: &quot;i&quot; },&#10;      });&#10;    } else {&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: { location: { $regex: location, $options: &quot;i&quot; } },&#10;      };&#10;    // Enhance farmers with product statistics if requested&#10;  }&#10;&#10;  // Add conditions for direct farmers&#10;  if (Object.keys(directFarmerMatch).length &gt; 0) {&#10;    directFarmerMatch.name = { $exists: true };&#10;    directFarmerMatch.location = { $exists: true };&#10;    matchStage.$match.$or.push(directFarmerMatch);&#10;  }&#10;&#10;  // Add conditions for nested farmers&#10;  if (Object.keys(nestedFarmerMatch).length &gt; 0) {&#10;  }&#10;&#10;  pipeline.push(matchStage);&#10;&#10;      total: totalCount,&#10;      page,&#10;      totalPages: Math.ceil(totalCount / limit),&#10;      hasNextPage: page * limit &lt; totalCount,&#10;      hasPrevPage: page &gt; 1,&#10;  });&#10;&#10;  // Combine results&#10;  pipeline.push({&#10;  const pipeline = [];&#10;&#10;  // Build match stage (same as main query)&#10;  const matchStage = { $match: { $or: [] } };&#10;  pipeline.push(matchStage);&#10;&#10;  pipeline.push({&#10;    $facet: {&#10;      directFarmers: [&#10;        { $match: { name: { $exists: true }, location: { $exists: true } } },&#10;        { $count: &quot;count&quot; },&#10;&#10;      ],&#10;      nestedFarmers: [&#10;        { $match: { farmers: { $exists: true, $type: &quot;array&quot; } } },&#10;        { $unwind: &quot;$farmers&quot; },&#10;        { $count: &quot;count&quot; },&#10;      ],&#10;    },&#10;  });&#10;&#10;  const result = await farmersCollection.aggregate(pipeline).toArray();&#10;&#10;  if (result.length === 0) return 0;&#10;&#10;  const directCount = result[0].directFarmers[0]?.count || 0;&#10;  const nestedCount = result[0].nestedFarmers[0]?.count || 0;&#10;&#10;  return directCount + nestedCount;&#10;  const directFarmerMatch = {};&#10;  const nestedFarmerMatch = {};&#10;&#10;&#10;  // Add sorting (by verification status, then name)&#10;    directFarmerMatch.$text = { $search: search };&#10;    nestedFarmerMatch[&quot;farmers&quot;] = {&#10;      $elemMatch: {&#10;    directFarmerMatch.specializations = {&#10;          { name: { $regex: search, $options: &quot;i&quot; } },&#10;          { description: { $regex: search, $options: &quot;i&quot; } },&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        specializations: {&#10;          $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;    directFarmerMatch.location = { $regex: location, $options: &quot;i&quot; };&#10;    console.error(&quot;Error fetching farmers:&quot;, error);&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or =&#10;        nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or || [];&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        location: { $regex: location, $options: &quot;i&quot; },&#10;      });&#10;    } else {&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: { location: { $regex: location, $options: &quot;i&quot; } },&#10;  if (Object.keys(directFarmerMatch).length &gt; 0) {&#10;    directFarmerMatch.name = { $exists: true };&#10;    directFarmerMatch.location = { $exists: true };&#10;    matchStage.$match.$or.push(directFarmerMatch);&#10;  }&#10;&#10;  if (Object.keys(nestedFarmerMatch).length &gt; 0) {&#10;    matchStage.$match.$or.push(nestedFarmerMatch);&#10;  }&#10;&#10;      : 50; // Increased default limit to show all farmers&#10;    matchStage.$match = {};&#10;      });&#10;    const includeStats = searchParams.get(&quot;includeStats&quot;) !== &quot;false&quot;; // Default to true&#10;&#10;  pipeline.push({&#10;    $facet: {&#10;      directFarmers: [&#10;        { $match: { name: { $exists: true }, location: { $exists: true } } },&#10;        { $count: &quot;count&quot; },&#10;      ],&#10;      nestedFarmers: [&#10;        { $match: { farmers: { $exists: true, $type: &quot;array&quot; } } },&#10;        { $unwind: &quot;$farmers&quot; },&#10;        { $count: &quot;count&quot; },&#10;      ],&#10;    },&#10;  });&#10;&#10;  const result = await farmersCollection.aggregate(pipeline).toArray();&#10;&#10;  if (result.length === 0) return 0;&#10;&#10;  const directCount = result[0].directFarmers[0]?.count || 0;&#10;  const nestedCount = result[0].nestedFarmers[0]?.count || 0;&#10;&#10;  return directCount + nestedCount;&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: {&#10;  const pipeline = [];&#10;          },&#10;        },&#10;      };&#10;    // Enhance farmers with product statistics if requested&#10;          { location: { $regex: search, $options: &quot;i&quot; } },&#10;          { farmName: { $regex: search, $options: &quot;i&quot; } },&#10;      },&#10;    };&#10;    // Get farmers using optimized aggregation pipeline&#10;  // Build match stage (same as main query)&#10;  const matchStage = { $match: { $or: [] } };&#10;  pipeline.push({ $unwind: &quot;$allFarmers&quot; });&#10;  const directFarmerMatch = {};&#10;  const nestedFarmerMatch = {};&#10;&#10;&#10;  // Add sorting (by verification status, then name)&#10;    directFarmerMatch.$text = { $search: search };&#10;    nestedFarmerMatch[&quot;farmers&quot;] = {&#10;      $elemMatch: {&#10;    directFarmerMatch.specializations = {&#10;          { name: { $regex: search, $options: &quot;i&quot; } },&#10;          { description: { $regex: search, $options: &quot;i&quot; } },&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        specializations: {&#10;          $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;    directFarmerMatch.location = { $regex: location, $options: &quot;i&quot; };&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or =&#10;        nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or || [];&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        location: { $regex: location, $options: &quot;i&quot; },&#10;      });&#10;    } else {&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: { location: { $regex: location, $options: &quot;i&quot; } },&#10;      };&#10;    }&#10;  }&#10;&#10;  if (Object.keys(directFarmerMatch).length &gt; 0) {&#10;    directFarmerMatch.name = { $exists: true };&#10;    directFarmerMatch.location = { $exists: true };&#10;    matchStage.$match.$or.push(directFarmerMatch);&#10;  }&#10;&#10;  if (Object.keys(nestedFarmerMatch).length &gt; 0) {&#10;    matchStage.$match.$or.push(nestedFarmerMatch);&#10;  }&#10;&#10;  if (matchStage.$match.$or.length === 0) {&#10;      : 50; // Increased default limit to show all farmers&#10;      });&#10;    const includeStats = searchParams.get(&quot;includeStats&quot;) !== &quot;false&quot;; // Default to true&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: {&#10;          specializations: {&#10;            $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;          },&#10;        },&#10;      };&#10;    }&#10;          { location: { $regex: search, $options: &quot;i&quot; } },&#10;          { farmName: { $regex: search, $options: &quot;i&quot; } },&#10;      },&#10;    };&#10;    // Get farmers using optimized aggregation pipeline&#10;      };&#10;    }&#10;          { farmName: { $regex: search, $options: &quot;i&quot; } },&#10;        ],&#10;      },&#10;    };&#10;    directFarmerMatch.location = { $regex: location, $options: &quot;i&quot; };&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or =&#10;        nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or || [];&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        location: { $regex: location, $options: &quot;i&quot; },&#10;      });&#10;    } else {&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: { location: { $regex: location, $options: &quot;i&quot; } },&#10;      };&#10;    // Enhance farmers with product statistics if requested&#10;  }&#10;&#10;  // Add conditions for direct farmers&#10;  if (Object.keys(directFarmerMatch).length &gt; 0) {&#10;    directFarmerMatch.name = { $exists: true };&#10;    directFarmerMatch.location = { $exists: true };&#10;    matchStage.$match.$or.push(directFarmerMatch);&#10;  }&#10;&#10;  // Add conditions for nested farmers&#10;  if (Object.keys(nestedFarmerMatch).length &gt; 0) {&#10;  }&#10;&#10;  pipeline.push(matchStage);&#10;&#10;      total: totalCount,&#10;      page,&#10;      totalPages: Math.ceil(totalCount / limit),&#10;      hasNextPage: page * limit &lt; totalCount,&#10;      hasPrevPage: page &gt; 1,&#10;  });&#10;&#10;  // Combine results&#10;  pipeline.push({&#10;  const pipeline = [];&#10;&#10;  // Build match stage (same as main query)&#10;  const matchStage = { $match: { $or: [] } };&#10;  pipeline.push(matchStage);&#10;&#10;  pipeline.push({&#10;    $facet: {&#10;      directFarmers: [&#10;        { $match: { name: { $exists: true }, location: { $exists: true } } },&#10;        { $count: &quot;count&quot; },&#10;&#10;      ],&#10;      nestedFarmers: [&#10;        { $match: { farmers: { $exists: true, $type: &quot;array&quot; } } },&#10;        { $unwind: &quot;$farmers&quot; },&#10;        { $count: &quot;count&quot; },&#10;      ],&#10;    },&#10;  });&#10;&#10;  const result = await farmersCollection.aggregate(pipeline).toArray();&#10;&#10;  if (result.length === 0) return 0;&#10;&#10;  const directCount = result[0].directFarmers[0]?.count || 0;&#10;  const nestedCount = result[0].nestedFarmers[0]?.count || 0;&#10;&#10;  return directCount + nestedCount;&#10;  const directFarmerMatch = {};&#10;  const nestedFarmerMatch = {};&#10;&#10;&#10;  // Add sorting (by verification status, then name)&#10;    directFarmerMatch.$text = { $search: search };&#10;    nestedFarmerMatch[&quot;farmers&quot;] = {&#10;      $elemMatch: {&#10;    directFarmerMatch.specializations = {&#10;          { name: { $regex: search, $options: &quot;i&quot; } },&#10;          { description: { $regex: search, $options: &quot;i&quot; } },&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        specializations: {&#10;          $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;    directFarmerMatch.location = { $regex: location, $options: &quot;i&quot; };&#10;    console.error(&quot;Error fetching farmers:&quot;, error);&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or =&#10;        nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or || [];&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        location: { $regex: location, $options: &quot;i&quot; },&#10;      });&#10;    } else {&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: { location: { $regex: location, $options: &quot;i&quot; } },&#10;  if (Object.keys(directFarmerMatch).length &gt; 0) {&#10;    directFarmerMatch.name = { $exists: true };&#10;    directFarmerMatch.location = { $exists: true };&#10;    matchStage.$match.$or.push(directFarmerMatch);&#10;  }&#10;&#10;  if (Object.keys(nestedFarmerMatch).length &gt; 0) {&#10;    matchStage.$match.$or.push(nestedFarmerMatch);&#10;  }&#10;&#10;      : 50; // Increased default limit to show all farmers&#10;    matchStage.$match = {};&#10;      });&#10;    const includeStats = searchParams.get(&quot;includeStats&quot;) !== &quot;false&quot;; // Default to true&#10;&#10;  pipeline.push({&#10;    $facet: {&#10;      directFarmers: [&#10;        { $match: { name: { $exists: true }, location: { $exists: true } } },&#10;        { $count: &quot;count&quot; },&#10;      ],&#10;      nestedFarmers: [&#10;        { $match: { farmers: { $exists: true, $type: &quot;array&quot; } } },&#10;        { $unwind: &quot;$farmers&quot; },&#10;        { $count: &quot;count&quot; },&#10;      ],&#10;    },&#10;  });&#10;&#10;  const result = await farmersCollection.aggregate(pipeline).toArray();&#10;&#10;  if (result.length === 0) return 0;&#10;&#10;  const directCount = result[0].directFarmers[0]?.count || 0;&#10;  const nestedCount = result[0].nestedFarmers[0]?.count || 0;&#10;&#10;  return directCount + nestedCount;&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: {&#10;          specializations: {&#10;            $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;          },&#10;        },&#10;      };&#10;    // Enhance farmers with product statistics if requested&#10;          { location: { $regex: search, $options: &quot;i&quot; } },&#10;          { farmName: { $regex: search, $options: &quot;i&quot; } },&#10;      },&#10;    };&#10;    // Get farmers using optimized aggregation pipeline&#10;      };&#10;    }&#10;          { name: { $regex: search, $options: &quot;i&quot; } },&#10;          { description: { $regex: search, $options: &quot;i&quot; } },&#10;          { location: { $regex: search, $options: &quot;i&quot; } },&#10;          { farmName: { $regex: search, $options: &quot;i&quot; } },&#10;    } else {&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: { location: { $regex: location, $options: &quot;i&quot; } },&#10;      };&#10;      total: totalCount,&#10;      page,&#10;      totalPages: Math.ceil(totalCount / limit),&#10;      hasNextPage: page * limit &lt; totalCount,&#10;      hasPrevPage: page &gt; 1,&#10;      },&#10;    };&#10;    directFarmerMatch.specializations = {&#10;&#10;// Get total count for pagination&#10;  const matchStage = { $match: { $or: [] } };&#10;&#10;  // Handle both direct farmers and nested farmers structure&#10;        const productsUpdateResult = await db.collection(&quot;products&quot;).updateMany(&#10;  const nestedFarmerMatch = {};&#10;&#10;  // Add search filters&#10;    }&#10;  }&#10;        $or: [&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;    directFarmerMatch.$text = { $search: search };&#10;    nestedFarmerMatch[&quot;farmers&quot;] = {&#10;&#10;      $elemMatch: {&#10;        $or: [&#10;    directFarmerMatch.specializations = {&#10;          { description: { $regex: search, $options: &quot;i&quot; } },&#10;          { location: { $regex: search, $options: &quot;i&quot; } },&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        specializations: {&#10;          $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;        },&#10;      });&#10;    } else {&#10;  // If no specific filters, match all documents&#10;  if (matchStage.$match.$or.length === 0) {&#10;    matchStage.$match = {};&#10;  }&#10;&#10;  pipeline.push(matchStage);&#10;&#10;  // Add facet stage for both direct and nested farmers&#10;  pipeline.push({&#10;    $facet: {&#10;      directFarmers: [&#10;        { $match: { name: { $exists: true }, location: { $exists: true } } },&#10;        { $project: { farmers: 0 } }, // Exclude nested farmers array&#10;      ],&#10;      nestedFarmers: [&#10;        { $match: { farmers: { $exists: true, $type: &quot;array&quot; } } },&#10;        { $unwind: &quot;$farmers&quot; },&#10;        { $replaceRoot: { newRoot: &quot;$farmers&quot; } },&#10;      ],&#10;    },&#10;  });&#10;&#10;  // Combine results&#10;  pipeline.push({&#10;  const pipeline = [];&#10;        const productsUpdateResult = await db.collection(&quot;products&quot;).updateMany(&#10;  // Build match stage (same as main query)&#10;  const matchStage = { $match: { $or: [] } };&#10;  pipeline.push({ $unwind: &quot;$allFarmers&quot; });&#10;  const directFarmerMatch = {};&#10;  const nestedFarmerMatch = {};&#10;&#10;&#10;  // Add sorting (by verification status, then name)&#10;    directFarmerMatch.$text = { $search: search };&#10;    nestedFarmerMatch[&quot;farmers&quot;] = {&#10;      $elemMatch: {&#10;    directFarmerMatch.specializations = {&#10;          { name: { $regex: search, $options: &quot;i&quot; } },&#10;          { description: { $regex: search, $options: &quot;i&quot; } },&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        specializations: {&#10;          $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;    directFarmerMatch.location = { $regex: location, $options: &quot;i&quot; };&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or =&#10;        nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or || [];&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        location: { $regex: location, $options: &quot;i&quot; },&#10;      });&#10;    } else {&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: { location: { $regex: location, $options: &quot;i&quot; } },&#10;      };&#10;    }&#10;  }&#10;&#10;  if (Object.keys(directFarmerMatch).length &gt; 0) {&#10;    directFarmerMatch.name = { $exists: true };&#10;    directFarmerMatch.location = { $exists: true };&#10;    matchStage.$match.$or.push(directFarmerMatch);&#10;  }&#10;&#10;  if (Object.keys(nestedFarmerMatch).length &gt; 0) {&#10;    matchStage.$match.$or.push(nestedFarmerMatch);&#10;  }&#10;&#10;  if (matchStage.$match.$or.length === 0) {&#10;      : 50; // Increased default limit to show all farmers&#10;      });&#10;    const includeStats = searchParams.get(&quot;includeStats&quot;) !== &quot;false&quot;; // Default to true&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: {&#10;          specializations: {&#10;            $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;          },&#10;        },&#10;      };&#10;    }&#10;          { location: { $regex: search, $options: &quot;i&quot; } },&#10;          { farmName: { $regex: search, $options: &quot;i&quot; } },&#10;      },&#10;    };&#10;    // Get farmers using optimized aggregation pipeline&#10;      };&#10;    }&#10;          { farmName: { $regex: search, $options: &quot;i&quot; } },&#10;        ],&#10;      },&#10;    };&#10;    directFarmerMatch.location = { $regex: location, $options: &quot;i&quot; };&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or =&#10;        nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or || [];&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        location: { $regex: location, $options: &quot;i&quot; },&#10;      });&#10;    } else {&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: { location: { $regex: location, $options: &quot;i&quot; } },&#10;      };&#10;    // Enhance farmers with product statistics if requested&#10;  }&#10;&#10;  // Add conditions for direct farmers&#10;  if (Object.keys(directFarmerMatch).length &gt; 0) {&#10;    directFarmerMatch.name = { $exists: true };&#10;    directFarmerMatch.location = { $exists: true };&#10;    matchStage.$match.$or.push(directFarmerMatch);&#10;  }&#10;&#10;  // Add conditions for nested farmers&#10;  if (Object.keys(nestedFarmerMatch).length &gt; 0) {&#10;  }&#10;&#10;  pipeline.push(matchStage);&#10;&#10;      total: totalCount,&#10;      page,&#10;      totalPages: Math.ceil(totalCount / limit),&#10;      hasNextPage: page * limit &lt; totalCount,&#10;      hasPrevPage: page &gt; 1,&#10;  });&#10;&#10;  // Combine results&#10;  pipeline.push({&#10;  const pipeline = [];&#10;&#10;  // Build match stage (same as main query)&#10;  const matchStage = { $match: { $or: [] } };&#10;  pipeline.push(matchStage);&#10;&#10;  pipeline.push({&#10;    $facet: {&#10;      directFarmers: [&#10;        { $match: { name: { $exists: true }, location: { $exists: true } } },&#10;        { $count: &quot;count&quot; },&#10;&#10;      ],&#10;      nestedFarmers: [&#10;        { $match: { farmers: { $exists: true, $type: &quot;array&quot; } } },&#10;        { $unwind: &quot;$farmers&quot; },&#10;        { $count: &quot;count&quot; },&#10;      ],&#10;    },&#10;  });&#10;&#10;  const result = await farmersCollection.aggregate(pipeline).toArray();&#10;&#10;  if (result.length === 0) return 0;&#10;&#10;  const directCount = result[0].directFarmers[0]?.count || 0;&#10;  const nestedCount = result[0].nestedFarmers[0]?.count || 0;&#10;&#10;  return directCount + nestedCount;&#10;  const directFarmerMatch = {};&#10;  const nestedFarmerMatch = {};&#10;&#10;&#10;  // Add sorting (by verification status, then name)&#10;    directFarmerMatch.$text = { $search: search };&#10;    nestedFarmerMatch[&quot;farmers&quot;] = {&#10;      $elemMatch: {&#10;    directFarmerMatch.specializations = {&#10;          { name: { $regex: search, $options: &quot;i&quot; } },&#10;          { description: { $regex: search, $options: &quot;i&quot; } },&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        specializations: {&#10;          $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;    directFarmerMatch.location = { $regex: location, $options: &quot;i&quot; };&#10;    console.error(&quot;Error fetching farmers:&quot;, error);&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or =&#10;        nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or || [];&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        location: { $regex: location, $options: &quot;i&quot; },&#10;      });&#10;    } else {&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: { location: { $regex: location, $options: &quot;i&quot; } },&#10;  if (Object.keys(directFarmerMatch).length &gt; 0) {&#10;    directFarmerMatch.name = { $exists: true };&#10;    directFarmerMatch.location = { $exists: true };&#10;    matchStage.$match.$or.push(directFarmerMatch);&#10;  }&#10;&#10;  if (Object.keys(nestedFarmerMatch).length &gt; 0) {&#10;    matchStage.$match.$or.push(nestedFarmerMatch);&#10;  }&#10;&#10;      : 50; // Increased default limit to show all farmers&#10;    matchStage.$match = {};&#10;      });&#10;    const includeStats = searchParams.get(&quot;includeStats&quot;) !== &quot;false&quot;; // Default to true&#10;&#10;  pipeline.push({&#10;    $facet: {&#10;      directFarmers: [&#10;        { $match: { name: { $exists: true }, location: { $exists: true } } },&#10;        { $count: &quot;count&quot; },&#10;      ],&#10;      nestedFarmers: [&#10;        { $match: { farmers: { $exists: true, $type: &quot;array&quot; } } },&#10;        { $unwind: &quot;$farmers&quot; },&#10;        { $count: &quot;count&quot; },&#10;      ],&#10;    },&#10;  });&#10;&#10;  const result = await farmersCollection.aggregate(pipeline).toArray();&#10;&#10;  if (result.length === 0) return 0;&#10;&#10;  // Handle both direct farmers and nested farmers structure&#10;  const directFarmerMatch = {};&#10;  const nestedFarmerMatch = {};&#10;&#10;  // Add search filters&#10;  const nestedCount = result[0].nestedFarmers[0]?.count || 0;&#10;&#10;  return directCount + nestedCount;&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: {&#10;  const pipeline = [];&#10;          },&#10;        },&#10;      };&#10;    // Enhance farmers with product statistics if requested&#10;          { location: { $regex: search, $options: &quot;i&quot; } },&#10;          { farmName: { $regex: search, $options: &quot;i&quot; } },&#10;      },&#10;    };&#10;    // Get farmers using optimized aggregation pipeline&#10;        key: { &quot;farmers.name&quot;: 1, &quot;farmers.location&quot;: 1 },&#10;        name: &quot;nested_farmers_search_idx&quot;,&#10;        options: { background: true },&#10;      },&#10;      // Nested farmers array index&#10;      {&#10;        key: { &quot;farmers.name&quot;: 1, &quot;farmers.location&quot;: 1 },&#10;        name: &quot;nested_farmers_search_idx&quot;,&#10;        options: { background: true },&#10;      },&#10;      // Nested farmers array index&#10;      {&#10;        key: { &quot;farmers.name&quot;: 1, &quot;farmers.location&quot;: 1 },&#10;        name: &quot;nested_farmers_search_idx&quot;,&#10;        options: { background: true },&#10;      },&#10;    console.log(&quot;Atlas-optimized farmers indexes initialized successfully&quot;);&#10;      {&#10;        key: { &quot;farmers.name&quot;: 1, &quot;farmers.location&quot;: 1 },&#10;        name: &quot;nested_farmers_search_idx&quot;,&#10;        options: { background: true },&#10;      },&#10;    console.log(&quot;Atlas-optimized farmers indexes initialized successfully&quot;);&#10;      {&#10;        key: { &quot;farmers.name&quot;: 1, &quot;farmers.location&quot;: 1 },&#10;        name: &quot;nested_farmers_search_idx&quot;,&#10;        options: { background: true },&#10;      },&#10;      // Nested farmers array index&#10;      {&#10;        key: { &quot;farmers.name&quot;: 1, &quot;farmers.location&quot;: 1 },&#10;        name: &quot;nested_farmers_search_idx&quot;,&#10;        options: { background: true },&#10;      },&#10;    console.log(&quot;Atlas-optimized farmers indexes initialized successfully&quot;);&#10;      {&#10;        key: { &quot;farmers.name&quot;: 1, &quot;farmers.location&quot;: 1 },&#10;        name: &quot;nested_farmers_search_idx&quot;,&#10;        options: { background: true },&#10;      },&#10;    console.log(&quot;Atlas-optimized farmers indexes initialized successfully&quot;);&#10;      {&#10;        key: { &quot;farmers.name&quot;: 1, &quot;farmers.location&quot;: 1 },&#10;        name: &quot;nested_farmers_search_idx&quot;,&#10;        options: { background: true },&#10;      },&#10;    console.log(&quot;Atlas-optimized farmers indexes initialized successfully&quot;);&#10;      {&#10;        key: { &quot;farmers.name&quot;: 1, &quot;farmers.location&quot;: 1 },&#10;        name: &quot;nested_farmers_search_idx&quot;,&#10;        options: { background: true },&#10;      },&#10;      // Nested farmers array index&#10;      {&#10;        key: { &quot;farmers.name&quot;: 1, &quot;farmers.location&quot;: 1 },&#10;        name: &quot;nested_farmers_search_idx&quot;,&#10;        options: { background: true },&#10;      },&#10;    console.log(&quot;Atlas-optimized farmers indexes initialized successfully&quot;);&#10;      {&#10;        key: { &quot;farmers.name&quot;: 1, &quot;farmers.location&quot;: 1 },&#10;        name: &quot;nested_farmers_search_idx&quot;,&#10;        options: { background: true },&#10;      },&#10;    console.log(&quot;Atlas-optimized farmers indexes initialized successfully&quot;);&#10;      {&#10;        key: { &quot;farmers.name&quot;: 1, &quot;farmers.location&quot;: 1 },&#10;        name: &quot;nested_farmers_search_idx&quot;,&#10;        options: { background: true },&#10;      },&#10;    console.log(&quot;Atlas-optimized farmers indexes initialized successfully&quot;);&#10;      {&#10;        key: { &quot;farmers.name&quot;: 1, &quot;farmers.location&quot;: 1 },&#10;// Optimized farmers query using aggregation pipeline&#10;        options: { background: true },&#10;      },&#10;      // Nested farmers array index&#10;      {&#10;        key: { &quot;farmers.name&quot;: 1, &quot;farmers.location&quot;: 1 },&#10;        name: &quot;nested_farmers_search_idx&quot;,&#10;        options: { background: true },&#10;      },&#10;  const pipeline = [];&#10;        key: { &quot;farmers.name&quot;: 1, &quot;farmers.location&quot;: 1 },&#10;  // Build match stage for filtering&#10;  const matchStage = { $match: { $or: [] } };&#10;    console.log(&quot;Atlas-optimized farmers indexes initialized successfully&quot;);&#10;      {&#10;        key: { &quot;farmers.name&quot;: 1, &quot;farmers.location&quot;: 1 },&#10;        name: &quot;nested_farmers_search_idx&quot;,&#10;  // Handle both direct farmers and nested farmers structure&#10;  const directFarmerMatch = {};&#10;  const nestedFarmerMatch = {};&#10;&#10;  // Add search filters&#10;      },&#10;// Get total count for pagination&#10;  const matchStage = { $match: { $or: [] } };&#10;&#10;    directFarmerMatch.$text = { $search: search };&#10;    nestedFarmerMatch[&quot;farmers&quot;] = {&#10;      $elemMatch: {&#10;        $or: [&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;    directFarmerMatch.$text = { $search: search };&#10;    nestedFarmerMatch[&quot;farmers&quot;] = {&#10;&#10;      $elemMatch: {&#10;        $or: [&#10;    directFarmerMatch.specializations = {&#10;          { description: { $regex: search, $options: &quot;i&quot; } },&#10;          { location: { $regex: search, $options: &quot;i&quot; } },&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        specializations: {&#10;          $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;        },&#10;      });&#10;    } else {&#10;  // If no specific filters, match all documents&#10;  if (matchStage.$match.$or.length === 0) {&#10;    matchStage.$match = {};&#10;  }&#10;&#10;  pipeline.push(matchStage);&#10;&#10;  // Add facet stage for both direct and nested farmers&#10;  pipeline.push({&#10;    $facet: {&#10;  const pipeline = [];&#10;        { $project: { farmers: 0 } }, // Exclude nested farmers array&#10;  // Build match stage for filtering&#10;  const matchStage = { $match: { $or: [] } };&#10;        { $unwind: &quot;$farmers&quot; },&#10;        { $replaceRoot: { newRoot: &quot;$farmers&quot; } },&#10;      ],&#10;  // Handle both direct farmers and nested farmers structure&#10;  const directFarmerMatch = {};&#10;  const nestedFarmerMatch = {};&#10;&#10;  // Add search filters&#10;  });&#10;&#10;  // Combine results&#10;    }&#10;          { name: { $regex: search, $options: &quot;i&quot; } },&#10;          { description: { $regex: search, $options: &quot;i&quot; } },&#10;          { location: { $regex: search, $options: &quot;i&quot; } },&#10;          { farmName: { $regex: search, $options: &quot;i&quot; } },&#10;    } else {&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: { location: { $regex: location, $options: &quot;i&quot; } },&#10;      };&#10;      total: totalCount,&#10;      page,&#10;      totalPages: Math.ceil(totalCount / limit),&#10;  // Build match stage for filtering&#10;  const matchStage = { $match: { $or: [] } };&#10;    };&#10;  // Handle both direct farmers and nested farmers structure&#10;  const directFarmerMatch = {};&#10;  const nestedFarmerMatch = {};&#10;&#10;  // Add search filters&#10;  pipeline.push({&#10;// Get total count for pagination&#10;  const matchStage = { $match: { $or: [] } };&#10;&#10;    directFarmerMatch.$text = { $search: search };&#10;    nestedFarmerMatch[&quot;farmers&quot;] = {&#10;      $elemMatch: {&#10;        $or: [&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;    directFarmerMatch.$text = { $search: search };&#10;    nestedFarmerMatch[&quot;farmers&quot;] = {&#10;&#10;      $elemMatch: {&#10;        $or: [&#10;    directFarmerMatch.specializations = {&#10;          { description: { $regex: search, $options: &quot;i&quot; } },&#10;          { location: { $regex: search, $options: &quot;i&quot; } },&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        specializations: {&#10;          $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;        },&#10;      });&#10;    } else {&#10;  // If no specific filters, match all documents&#10;  if (matchStage.$match.$or.length === 0) {&#10;    matchStage.$match = {};&#10;  }&#10;&#10;  pipeline.push(matchStage);&#10;&#10;  // Add facet stage for both direct and nested farmers&#10;  pipeline.push({&#10;    $facet: {&#10;      directFarmers: [&#10;        { $match: { name: { $exists: true }, location: { $exists: true } } },&#10;        { $project: { farmers: 0 } }, // Exclude nested farmers array&#10;      ],&#10;      nestedFarmers: [&#10;        { $match: { farmers: { $exists: true, $type: &quot;array&quot; } } },&#10;        { $unwind: &quot;$farmers&quot; },&#10;        { $replaceRoot: { newRoot: &quot;$farmers&quot; } },&#10;      ],&#10;    },&#10;  });&#10;&#10;  // Combine results&#10;  pipeline.push({&#10;  const pipeline = [];&#10;        const productsUpdateResult = await db.collection(&quot;products&quot;).updateMany(&#10;  // Build match stage (same as main query)&#10;  const matchStage = { $match: { $or: [] } };&#10;  pipeline.push({ $unwind: &quot;$allFarmers&quot; });&#10;  const directFarmerMatch = {};&#10;  const nestedFarmerMatch = {};&#10;&#10;&#10;  // Add sorting (by verification status, then name)&#10;    directFarmerMatch.$text = { $search: search };&#10;    nestedFarmerMatch[&quot;farmers&quot;] = {&#10;      $elemMatch: {&#10;    directFarmerMatch.specializations = {&#10;          { name: { $regex: search, $options: &quot;i&quot; } },&#10;          { description: { $regex: search, $options: &quot;i&quot; } },&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        specializations: {&#10;          $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;    directFarmerMatch.location = { $regex: location, $options: &quot;i&quot; };&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or =&#10;        nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or || [];&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        location: { $regex: location, $options: &quot;i&quot; },&#10;      });&#10;    } else {&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: { location: { $regex: location, $options: &quot;i&quot; } },&#10;      };&#10;    }&#10;  }&#10;&#10;  if (Object.keys(directFarmerMatch).length &gt; 0) {&#10;    directFarmerMatch.name = { $exists: true };&#10;    directFarmerMatch.location = { $exists: true };&#10;    matchStage.$match.$or.push(directFarmerMatch);&#10;  }&#10;&#10;  if (Object.keys(nestedFarmerMatch).length &gt; 0) {&#10;    matchStage.$match.$or.push(nestedFarmerMatch);&#10;  }&#10;&#10;      : 50; // Increased default limit to show all farmers&#10;    matchStage.$match = {};&#10;      });&#10;    const includeStats = searchParams.get(&quot;includeStats&quot;) !== &quot;false&quot;; // Default to true&#10;&#10;  pipeline.push({&#10;    $facet: {&#10;      directFarmers: [&#10;        { $match: { name: { $exists: true }, location: { $exists: true } } },&#10;        { $count: &quot;count&quot; },&#10;      ],&#10;      nestedFarmers: [&#10;        { $match: { farmers: { $exists: true, $type: &quot;array&quot; } } },&#10;        { $unwind: &quot;$farmers&quot; },&#10;        { $count: &quot;count&quot; },&#10;      ],&#10;    },&#10;  });&#10;&#10;  const result = await farmersCollection.aggregate(pipeline).toArray();&#10;&#10;  if (result.length === 0) return 0;&#10;&#10;  const directCount = result[0].directFarmers[0]?.count || 0;&#10;  const nestedCount = result[0].nestedFarmers[0]?.count || 0;&#10;&#10;  return directCount + nestedCount;&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: {&#10;          specializations: {&#10;            $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;          },&#10;        },&#10;      };&#10;    // Enhance farmers with product statistics if requested&#10;          { location: { $regex: search, $options: &quot;i&quot; } },&#10;          { farmName: { $regex: search, $options: &quot;i&quot; } },&#10;      },&#10;    };&#10;    // Get farmers using optimized aggregation pipeline&#10;      };&#10;    }&#10;          { farmName: { $regex: search, $options: &quot;i&quot; } },&#10;        ],&#10;      },&#10;    };&#10;    } else {&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: { location: { $regex: location, $options: &quot;i&quot; } },&#10;      };&#10;    }&#10;  }&#10;&#10;  // Add conditions for direct farmers&#10;      total: totalCount,&#10;      page,&#10;      totalPages: Math.ceil(totalCount / limit),&#10;      hasNextPage: page * limit &lt; totalCount,&#10;      hasPrevPage: page &gt; 1,&#10;// Get total count for pagination&#10;    matchStage.$match = {};&#10;  }&#10;&#10;  pipeline.push(matchStage);&#10;&#10;  // Add facet stage for both direct and nested farmers&#10;  pipeline.push({&#10;    $facet: {&#10;      directFarmers: [&#10;        { $match: { name: { $exists: true }, location: { $exists: true } } },&#10;&#10;        { $project: { farmers: 0 } }, // Exclude nested farmers array&#10;      ],&#10;      nestedFarmers: [&#10;        { $match: { farmers: { $exists: true, $type: &quot;array&quot; } } },&#10;        { $unwind: &quot;$farmers&quot; },&#10;        { $replaceRoot: { newRoot: &quot;$farmers&quot; } },&#10;      ],&#10;    },&#10;  });&#10;&#10;    console.error(&quot;Error fetching farmers:&quot;, error);&#10;  pipeline.push({&#10;  const pipeline = [];&#10;&#10;  // Build match stage (same as main query)&#10;  const matchStage = { $match: { $or: [] } };&#10;  pipeline.push({ $unwind: &quot;$allFarmers&quot; });&#10;  const directFarmerMatch = {};&#10;  const nestedFarmerMatch = {};&#10;&#10;&#10;  // Add sorting (by verification status, then name)&#10;    directFarmerMatch.$text = { $search: search };&#10;    nestedFarmerMatch[&quot;farmers&quot;] = {&#10;      $elemMatch: {&#10;    directFarmerMatch.specializations = {&#10;          { name: { $regex: search, $options: &quot;i&quot; } },&#10;          { description: { $regex: search, $options: &quot;i&quot; } },&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        specializations: {&#10;          $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;    directFarmerMatch.location = { $regex: location, $options: &quot;i&quot; };&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or =&#10;        nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or || [];&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        location: { $regex: location, $options: &quot;i&quot; },&#10;      });&#10;    } else {&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: { location: { $regex: location, $options: &quot;i&quot; } },&#10;      };&#10;    }&#10;  }&#10;&#10;  if (Object.keys(directFarmerMatch).length &gt; 0) {&#10;    directFarmerMatch.name = { $exists: true };&#10;    directFarmerMatch.location = { $exists: true };&#10;    matchStage.$match.$or.push(directFarmerMatch);&#10;  }&#10;&#10;  if (Object.keys(nestedFarmerMatch).length &gt; 0) {&#10;    matchStage.$match.$or.push(nestedFarmerMatch);&#10;  }&#10;&#10;      : 50; // Increased default limit to show all farmers&#10;    matchStage.$match = {};&#10;      });&#10;    const includeStats = searchParams.get(&quot;includeStats&quot;) !== &quot;false&quot;; // Default to true&#10;&#10;  pipeline.push({&#10;    $facet: {&#10;      directFarmers: [&#10;        { $match: { name: { $exists: true }, location: { $exists: true } } },&#10;        { $count: &quot;count&quot; },&#10;      ],&#10;      nestedFarmers: [&#10;        { $match: { farmers: { $exists: true, $type: &quot;array&quot; } } },&#10;        { $unwind: &quot;$farmers&quot; },&#10;        { $count: &quot;count&quot; },&#10;      ],&#10;    },&#10;  });&#10;&#10;  const result = await farmersCollection.aggregate(pipeline).toArray();&#10;&#10;  if (result.length === 0) return 0;&#10;&#10;  const directCount = result[0].directFarmers[0]?.count || 0;&#10;  const nestedCount = result[0].nestedFarmers[0]?.count || 0;&#10;&#10;  return directCount + nestedCount;&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: {&#10;          specializations: {&#10;            $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;          },&#10;        },&#10;      };&#10;    // Enhance farmers with product statistics if requested&#10;          { location: { $regex: search, $options: &quot;i&quot; } },&#10;          { farmName: { $regex: search, $options: &quot;i&quot; } },&#10;      },&#10;    };&#10;    // Get farmers using optimized aggregation pipeline&#10;      };&#10;    }&#10;          { name: { $regex: search, $options: &quot;i&quot; } },&#10;          { description: { $regex: search, $options: &quot;i&quot; } },&#10;          { location: { $regex: search, $options: &quot;i&quot; } },&#10;          { farmName: { $regex: search, $options: &quot;i&quot; } },&#10;    } else {&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: { location: { $regex: location, $options: &quot;i&quot; } },&#10;      };&#10;      total: totalCount,&#10;      page,&#10;      totalPages: Math.ceil(totalCount / limit),&#10;      hasNextPage: page * limit &lt; totalCount,&#10;      hasPrevPage: page &gt; 1,&#10;      },&#10;    };&#10;    directFarmerMatch.specializations = {&#10;  // Handle both direct farmers and nested farmers structure&#10;        const productsUpdateResult = await db.collection(&quot;products&quot;).updateMany(&#10;  const nestedFarmerMatch = {};&#10;&#10;  // Add search filters&#10;// Get total count for pagination&#10;  const matchStage = { $match: { $or: [] } };&#10;        $or: [&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;    directFarmerMatch.$text = { $search: search };&#10;    nestedFarmerMatch[&quot;farmers&quot;] = {&#10;&#10;      $elemMatch: {&#10;        $or: [&#10;    directFarmerMatch.specializations = {&#10;          { description: { $regex: search, $options: &quot;i&quot; } },&#10;          { location: { $regex: search, $options: &quot;i&quot; } },&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        specializations: {&#10;          $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;        },&#10;      });&#10;    } else {&#10;  // If no specific filters, match all documents&#10;  if (matchStage.$match.$or.length === 0) {&#10;    matchStage.$match = {};&#10;  }&#10;&#10;  pipeline.push(matchStage);&#10;&#10;  // Add facet stage for both direct and nested farmers&#10;  pipeline.push({&#10;    $facet: {&#10;      directFarmers: [&#10;        { $match: { name: { $exists: true }, location: { $exists: true } } },&#10;        { $project: { farmers: 0 } }, // Exclude nested farmers array&#10;      ],&#10;      nestedFarmers: [&#10;        { $match: { farmers: { $exists: true, $type: &quot;array&quot; } } },&#10;        { $unwind: &quot;$farmers&quot; },&#10;        { $replaceRoot: { newRoot: &quot;$farmers&quot; } },&#10;      ],&#10;    },&#10;  });&#10;&#10;  // Combine results&#10;  pipeline.push({&#10;  const pipeline = [];&#10;        const productsUpdateResult = await db.collection(&quot;products&quot;).updateMany(&#10;  // Build match stage (same as main query)&#10;  const matchStage = { $match: { $or: [] } };&#10;  pipeline.push({ $unwind: &quot;$allFarmers&quot; });&#10;  const directFarmerMatch = {};&#10;  const nestedFarmerMatch = {};&#10;&#10;&#10;  // Add sorting (by verification status, then name)&#10;    directFarmerMatch.$text = { $search: search };&#10;    nestedFarmerMatch[&quot;farmers&quot;] = {&#10;      $elemMatch: {&#10;    directFarmerMatch.specializations = {&#10;          { name: { $regex: search, $options: &quot;i&quot; } },&#10;          { description: { $regex: search, $options: &quot;i&quot; } },&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        specializations: {&#10;          $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;    directFarmerMatch.location = { $regex: location, $options: &quot;i&quot; };&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or =&#10;        nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or || [];&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        location: { $regex: location, $options: &quot;i&quot; },&#10;      });&#10;    } else {&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: { location: { $regex: location, $options: &quot;i&quot; } },&#10;      };&#10;    }&#10;  }&#10;&#10;  if (Object.keys(directFarmerMatch).length &gt; 0) {&#10;    directFarmerMatch.name = { $exists: true };&#10;    directFarmerMatch.location = { $exists: true };&#10;    matchStage.$match.$or.push(directFarmerMatch);&#10;  }&#10;&#10;  if (Object.keys(nestedFarmerMatch).length &gt; 0) {&#10;    matchStage.$match.$or.push(nestedFarmerMatch);&#10;  }&#10;&#10;  if (matchStage.$match.$or.length === 0) {&#10;      : 50; // Increased default limit to show all farmers&#10;      });&#10;    const includeStats = searchParams.get(&quot;includeStats&quot;) !== &quot;false&quot;; // Default to true&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: {&#10;          specializations: {&#10;            $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;          },&#10;        },&#10;      };&#10;    }&#10;          { location: { $regex: search, $options: &quot;i&quot; } },&#10;          { farmName: { $regex: search, $options: &quot;i&quot; } },&#10;      },&#10;    };&#10;    // Get farmers using optimized aggregation pipeline&#10;      };&#10;    }&#10;          { farmName: { $regex: search, $options: &quot;i&quot; } },&#10;        ],&#10;      },&#10;    };&#10;    directFarmerMatch.location = { $regex: location, $options: &quot;i&quot; };&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or =&#10;        nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or || [];&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        location: { $regex: location, $options: &quot;i&quot; },&#10;      });&#10;    } else {&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: { location: { $regex: location, $options: &quot;i&quot; } },&#10;      };&#10;    // Enhance farmers with product statistics if requested&#10;  }&#10;&#10;  // Add conditions for direct farmers&#10;  if (Object.keys(directFarmerMatch).length &gt; 0) {&#10;    directFarmerMatch.name = { $exists: true };&#10;    directFarmerMatch.location = { $exists: true };&#10;    matchStage.$match.$or.push(directFarmerMatch);&#10;  }&#10;&#10;  // Add conditions for nested farmers&#10;  if (Object.keys(nestedFarmerMatch).length &gt; 0) {&#10;  }&#10;&#10;  pipeline.push(matchStage);&#10;&#10;      total: totalCount,&#10;      page,&#10;      totalPages: Math.ceil(totalCount / limit),&#10;      hasNextPage: page * limit &lt; totalCount,&#10;      hasPrevPage: page &gt; 1,&#10;  });&#10;&#10;  // Combine results&#10;  pipeline.push({&#10;  const pipeline = [];&#10;&#10;  // Build match stage (same as main query)&#10;  const matchStage = { $match: { $or: [] } };&#10;  pipeline.push(matchStage);&#10;&#10;  pipeline.push({&#10;    $facet: {&#10;      directFarmers: [&#10;        { $match: { name: { $exists: true }, location: { $exists: true } } },&#10;        { $count: &quot;count&quot; },&#10;&#10;      ],&#10;      nestedFarmers: [&#10;        { $match: { farmers: { $exists: true, $type: &quot;array&quot; } } },&#10;        { $unwind: &quot;$farmers&quot; },&#10;        { $count: &quot;count&quot; },&#10;      ],&#10;    },&#10;  });&#10;&#10;  const result = await farmersCollection.aggregate(pipeline).toArray();&#10;&#10;  if (result.length === 0) return 0;&#10;&#10;  const directCount = result[0].directFarmers[0]?.count || 0;&#10;  const nestedCount = result[0].nestedFarmers[0]?.count || 0;&#10;&#10;  return directCount + nestedCount;&#10;  const directFarmerMatch = {};&#10;  const nestedFarmerMatch = {};&#10;&#10;&#10;  // Add sorting (by verification status, then name)&#10;    directFarmerMatch.$text = { $search: search };&#10;    nestedFarmerMatch[&quot;farmers&quot;] = {&#10;      $elemMatch: {&#10;    directFarmerMatch.specializations = {&#10;          { name: { $regex: search, $options: &quot;i&quot; } },&#10;          { description: { $regex: search, $options: &quot;i&quot; } },&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        specializations: {&#10;          $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;    directFarmerMatch.location = { $regex: location, $options: &quot;i&quot; };&#10;    console.error(&quot;Error fetching farmers:&quot;, error);&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or =&#10;        nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or || [];&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        location: { $regex: location, $options: &quot;i&quot; },&#10;      });&#10;    } else {&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: { location: { $regex: location, $options: &quot;i&quot; } },&#10;  if (Object.keys(directFarmerMatch).length &gt; 0) {&#10;    directFarmerMatch.name = { $exists: true };&#10;    directFarmerMatch.location = { $exists: true };&#10;    matchStage.$match.$or.push(directFarmerMatch);&#10;  }&#10;&#10;  if (Object.keys(nestedFarmerMatch).length &gt; 0) {&#10;    matchStage.$match.$or.push(nestedFarmerMatch);&#10;  }&#10;&#10;      : 50; // Increased default limit to show all farmers&#10;    matchStage.$match = {};&#10;      });&#10;    const includeStats = searchParams.get(&quot;includeStats&quot;) !== &quot;false&quot;; // Default to true&#10;&#10;  pipeline.push({&#10;    $facet: {&#10;      directFarmers: [&#10;        { $match: { name: { $exists: true }, location: { $exists: true } } },&#10;        { $count: &quot;count&quot; },&#10;      ],&#10;      nestedFarmers: [&#10;        { $match: { farmers: { $exists: true, $type: &quot;array&quot; } } },&#10;        { $unwind: &quot;$farmers&quot; },&#10;        { $count: &quot;count&quot; },&#10;      ],&#10;    },&#10;  });&#10;&#10;  const result = await farmersCollection.aggregate(pipeline).toArray();&#10;&#10;  if (result.length === 0) return 0;&#10;&#10;  const directCount = result[0].directFarmers[0]?.count || 0;&#10;  const nestedCount = result[0].nestedFarmers[0]?.count || 0;&#10;&#10;  return directCount + nestedCount;&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: {&#10;  const pipeline = [];&#10;          },&#10;        },&#10;      };&#10;    // Enhance farmers with product statistics if requested&#10;          { location: { $regex: search, $options: &quot;i&quot; } },&#10;          { farmName: { $regex: search, $options: &quot;i&quot; } },&#10;      },&#10;    };&#10;    // Get farmers using optimized aggregation pipeline&#10;  // Build match stage (same as main query)&#10;  const matchStage = { $match: { $or: [] } };&#10;  pipeline.push({ $unwind: &quot;$allFarmers&quot; });&#10;  const directFarmerMatch = {};&#10;  const nestedFarmerMatch = {};&#10;&#10;&#10;  // Add sorting (by verification status, then name)&#10;    directFarmerMatch.$text = { $search: search };&#10;    nestedFarmerMatch[&quot;farmers&quot;] = {&#10;      $elemMatch: {&#10;    directFarmerMatch.specializations = {&#10;          { name: { $regex: search, $options: &quot;i&quot; } },&#10;          { description: { $regex: search, $options: &quot;i&quot; } },&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        specializations: {&#10;          $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;    directFarmerMatch.location = { $regex: location, $options: &quot;i&quot; };&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or =&#10;        nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or || [];&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        location: { $regex: location, $options: &quot;i&quot; },&#10;      });&#10;    } else {&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: { location: { $regex: location, $options: &quot;i&quot; } },&#10;      };&#10;    }&#10;  }&#10;&#10;  if (Object.keys(directFarmerMatch).length &gt; 0) {&#10;    directFarmerMatch.name = { $exists: true };&#10;    directFarmerMatch.location = { $exists: true };&#10;    matchStage.$match.$or.push(directFarmerMatch);&#10;  }&#10;&#10;  if (Object.keys(nestedFarmerMatch).length &gt; 0) {&#10;    matchStage.$match.$or.push(nestedFarmerMatch);&#10;  }&#10;&#10;  if (matchStage.$match.$or.length === 0) {&#10;      : 50; // Increased default limit to show all farmers&#10;      });&#10;    const includeStats = searchParams.get(&quot;includeStats&quot;) !== &quot;false&quot;; // Default to true&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: {&#10;          specializations: {&#10;            $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;          },&#10;        },&#10;      };&#10;    }&#10;          { location: { $regex: search, $options: &quot;i&quot; } },&#10;          { farmName: { $regex: search, $options: &quot;i&quot; } },&#10;      },&#10;    };&#10;    // Get farmers using optimized aggregation pipeline&#10;      };&#10;    }&#10;          { farmName: { $regex: search, $options: &quot;i&quot; } },&#10;        ],&#10;      },&#10;    };&#10;    directFarmerMatch.location = { $regex: location, $options: &quot;i&quot; };&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or =&#10;        nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or || [];&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        location: { $regex: location, $options: &quot;i&quot; },&#10;      });&#10;    } else {&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: { location: { $regex: location, $options: &quot;i&quot; } },&#10;      };&#10;    // Enhance farmers with product statistics if requested&#10;  }&#10;&#10;  // Add conditions for direct farmers&#10;  if (Object.keys(directFarmerMatch).length &gt; 0) {&#10;    directFarmerMatch.name = { $exists: true };&#10;    directFarmerMatch.location = { $exists: true };&#10;    matchStage.$match.$or.push(directFarmerMatch);&#10;  }&#10;&#10;  // Add conditions for nested farmers&#10;  if (Object.keys(nestedFarmerMatch).length &gt; 0) {&#10;  }&#10;&#10;  pipeline.push(matchStage);&#10;&#10;      total: totalCount,&#10;      page,&#10;      totalPages: Math.ceil(totalCount / limit),&#10;      hasNextPage: page * limit &lt; totalCount,&#10;      hasPrevPage: page &gt; 1,&#10;  });&#10;&#10;  // Combine results&#10;  pipeline.push({&#10;  const pipeline = [];&#10;&#10;  // Build match stage (same as main query)&#10;  const matchStage = { $match: { $or: [] } };&#10;  pipeline.push(matchStage);&#10;&#10;  pipeline.push({&#10;    $facet: {&#10;      directFarmers: [&#10;        { $match: { name: { $exists: true }, location: { $exists: true } } },&#10;        { $count: &quot;count&quot; },&#10;&#10;      ],&#10;      nestedFarmers: [&#10;        { $match: { farmers: { $exists: true, $type: &quot;array&quot; } } },&#10;        { $unwind: &quot;$farmers&quot; },&#10;        { $count: &quot;count&quot; },&#10;      ],&#10;    },&#10;  });&#10;&#10;  const result = await farmersCollection.aggregate(pipeline).toArray();&#10;&#10;  if (result.length === 0) return 0;&#10;&#10;  const directCount = result[0].directFarmers[0]?.count || 0;&#10;  const nestedCount = result[0].nestedFarmers[0]?.count || 0;&#10;&#10;  return directCount + nestedCount;&#10;  const directFarmerMatch = {};&#10;  const nestedFarmerMatch = {};&#10;&#10;&#10;  // Add sorting (by verification status, then name)&#10;    directFarmerMatch.$text = { $search: search };&#10;    nestedFarmerMatch[&quot;farmers&quot;] = {&#10;      $elemMatch: {&#10;    directFarmerMatch.specializations = {&#10;          { name: { $regex: search, $options: &quot;i&quot; } },&#10;          { description: { $regex: search, $options: &quot;i&quot; } },&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        specializations: {&#10;          $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;    directFarmerMatch.location = { $regex: location, $options: &quot;i&quot; };&#10;    console.error(&quot;Error fetching farmers:&quot;, error);&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or =&#10;        nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or || [];&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        location: { $regex: location, $options: &quot;i&quot; },&#10;      });&#10;    } else {&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: { location: { $regex: location, $options: &quot;i&quot; } },&#10;  if (Object.keys(directFarmerMatch).length &gt; 0) {&#10;    directFarmerMatch.name = { $exists: true };&#10;    directFarmerMatch.location = { $exists: true };&#10;    matchStage.$match.$or.push(directFarmerMatch);&#10;  }&#10;&#10;  if (Object.keys(nestedFarmerMatch).length &gt; 0) {&#10;    matchStage.$match.$or.push(nestedFarmerMatch);&#10;  }&#10;&#10;      : 50; // Increased default limit to show all farmers&#10;    matchStage.$match = {};&#10;      });&#10;    const includeStats = searchParams.get(&quot;includeStats&quot;) !== &quot;false&quot;; // Default to true&#10;&#10;  pipeline.push({&#10;    $facet: {&#10;      directFarmers: [&#10;        { $match: { name: { $exists: true }, location: { $exists: true } } },&#10;        { $count: &quot;count&quot; },&#10;      ],&#10;      nestedFarmers: [&#10;        { $match: { farmers: { $exists: true, $type: &quot;array&quot; } } },&#10;        { $unwind: &quot;$farmers&quot; },&#10;        { $count: &quot;count&quot; },&#10;      ],&#10;    },&#10;  });&#10;&#10;  const result = await farmersCollection.aggregate(pipeline).toArray();&#10;&#10;  if (result.length === 0) return 0;&#10;&#10;  const directCount = result[0].directFarmers[0]?.count || 0;&#10;  const nestedCount = result[0].nestedFarmers[0]?.count || 0;&#10;&#10;  return directCount + nestedCount;&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: {&#10;          specializations: {&#10;            $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;          },&#10;        },&#10;      };&#10;    // Enhance farmers with product statistics if requested&#10;          { location: { $regex: search, $options: &quot;i&quot; } },&#10;          { farmName: { $regex: search, $options: &quot;i&quot; } },&#10;      },&#10;    };&#10;    // Get farmers using optimized aggregation pipeline&#10;      };&#10;    }&#10;          { name: { $regex: search, $options: &quot;i&quot; } },&#10;          { description: { $regex: search, $options: &quot;i&quot; } },&#10;          { location: { $regex: search, $options: &quot;i&quot; } },&#10;          { farmName: { $regex: search, $options: &quot;i&quot; } },&#10;    } else {&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: { location: { $regex: location, $options: &quot;i&quot; } },&#10;      };&#10;      total: totalCount,&#10;      page,&#10;      totalPages: Math.ceil(totalCount / limit),&#10;      hasNextPage: page * limit &lt; totalCount,&#10;      hasPrevPage: page &gt; 1,&#10;      },&#10;    };&#10;    directFarmerMatch.specializations = {&#10;&#10;// Get total count for pagination&#10;  const matchStage = { $match: { $or: [] } };&#10;&#10;  // Handle both direct farmers and nested farmers structure&#10;        const productsUpdateResult = await db.collection(&quot;products&quot;).updateMany(&#10;  const nestedFarmerMatch = {};&#10;&#10;  // Add search filters&#10;    }&#10;  }&#10;        $or: [&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;    directFarmerMatch.$text = { $search: search };&#10;    nestedFarmerMatch[&quot;farmers&quot;] = {&#10;&#10;      $elemMatch: {&#10;        $or: [&#10;    directFarmerMatch.specializations = {&#10;          { description: { $regex: search, $options: &quot;i&quot; } },&#10;          { location: { $regex: search, $options: &quot;i&quot; } },&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        specializations: {&#10;          $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;        },&#10;      });&#10;    } else {&#10;  // If no specific filters, match all documents&#10;  if (matchStage.$match.$or.length === 0) {&#10;    matchStage.$match = {};&#10;  }&#10;&#10;  pipeline.push(matchStage);&#10;&#10;  // Add facet stage for both direct and nested farmers&#10;  pipeline.push({&#10;    $facet: {&#10;      directFarmers: [&#10;        { $match: { name: { $exists: true }, location: { $exists: true } } },&#10;        { $project: { farmers: 0 } }, // Exclude nested farmers array&#10;      ],&#10;      nestedFarmers: [&#10;        { $match: { farmers: { $exists: true, $type: &quot;array&quot; } } },&#10;        { $unwind: &quot;$farmers&quot; },&#10;        { $replaceRoot: { newRoot: &quot;$farmers&quot; } },&#10;      ],&#10;    },&#10;  });&#10;&#10;  // Combine results&#10;  pipeline.push({&#10;  const pipeline = [];&#10;        const productsUpdateResult = await db.collection(&quot;products&quot;).updateMany(&#10;  // Build match stage (same as main query)&#10;  const matchStage = { $match: { $or: [] } };&#10;  pipeline.push({ $unwind: &quot;$allFarmers&quot; });&#10;  const directFarmerMatch = {};&#10;  const nestedFarmerMatch = {};&#10;&#10;&#10;  // Add sorting (by verification status, then name)&#10;    directFarmerMatch.$text = { $search: search };&#10;    nestedFarmerMatch[&quot;farmers&quot;] = {&#10;      $elemMatch: {&#10;    directFarmerMatch.specializations = {&#10;          { name: { $regex: search, $options: &quot;i&quot; } },&#10;          { description: { $regex: search, $options: &quot;i&quot; } },&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        specializations: {&#10;          $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;    directFarmerMatch.location = { $regex: location, $options: &quot;i&quot; };&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or =&#10;        nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or || [];&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        location: { $regex: location, $options: &quot;i&quot; },&#10;      });&#10;    } else {&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: { location: { $regex: location, $options: &quot;i&quot; } },&#10;      };&#10;    }&#10;  }&#10;&#10;  if (Object.keys(directFarmerMatch).length &gt; 0) {&#10;    directFarmerMatch.name = { $exists: true };&#10;    directFarmerMatch.location = { $exists: true };&#10;    matchStage.$match.$or.push(directFarmerMatch);&#10;  }&#10;&#10;  if (Object.keys(nestedFarmerMatch).length &gt; 0) {&#10;    matchStage.$match.$or.push(nestedFarmerMatch);&#10;  }&#10;&#10;  if (matchStage.$match.$or.length === 0) {&#10;      : 50; // Increased default limit to show all farmers&#10;      });&#10;    const includeStats = searchParams.get(&quot;includeStats&quot;) !== &quot;false&quot;; // Default to true&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: {&#10;          specializations: {&#10;            $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;          },&#10;        },&#10;      };&#10;    }&#10;          { location: { $regex: search, $options: &quot;i&quot; } },&#10;          { farmName: { $regex: search, $options: &quot;i&quot; } },&#10;      },&#10;    };&#10;    // Get farmers using optimized aggregation pipeline&#10;      };&#10;    }&#10;          { farmName: { $regex: search, $options: &quot;i&quot; } },&#10;        ],&#10;      },&#10;    };&#10;    directFarmerMatch.location = { $regex: location, $options: &quot;i&quot; };&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or =&#10;        nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or || [];&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        location: { $regex: location, $options: &quot;i&quot; },&#10;      });&#10;    } else {&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: { location: { $regex: location, $options: &quot;i&quot; } },&#10;      };&#10;    // Enhance farmers with product statistics if requested&#10;  }&#10;&#10;  // Add conditions for direct farmers&#10;  if (Object.keys(directFarmerMatch).length &gt; 0) {&#10;    directFarmerMatch.name = { $exists: true };&#10;    directFarmerMatch.location = { $exists: true };&#10;    matchStage.$match.$or.push(directFarmerMatch);&#10;  }&#10;&#10;  // Add conditions for nested farmers&#10;  if (Object.keys(nestedFarmerMatch).length &gt; 0) {&#10;  }&#10;&#10;  pipeline.push(matchStage);&#10;&#10;      total: totalCount,&#10;      page,&#10;      totalPages: Math.ceil(totalCount / limit),&#10;      hasNextPage: page * limit &lt; totalCount,&#10;      hasPrevPage: page &gt; 1,&#10;  });&#10;&#10;  // Combine results&#10;  pipeline.push({&#10;  const pipeline = [];&#10;&#10;  // Build match stage (same as main query)&#10;  const matchStage = { $match: { $or: [] } };&#10;  pipeline.push(matchStage);&#10;&#10;  pipeline.push({&#10;    $facet: {&#10;      directFarmers: [&#10;        { $match: { name: { $exists: true }, location: { $exists: true } } },&#10;        { $count: &quot;count&quot; },&#10;&#10;      ],&#10;      nestedFarmers: [&#10;        { $match: { farmers: { $exists: true, $type: &quot;array&quot; } } },&#10;        { $unwind: &quot;$farmers&quot; },&#10;        { $count: &quot;count&quot; },&#10;      ],&#10;    },&#10;  });&#10;&#10;  const result = await farmersCollection.aggregate(pipeline).toArray();&#10;&#10;  if (result.length === 0) return 0;&#10;&#10;  const directCount = result[0].directFarmers[0]?.count || 0;&#10;  const nestedCount = result[0].nestedFarmers[0]?.count || 0;&#10;&#10;  return directCount + nestedCount;&#10;  const directFarmerMatch = {};&#10;  const nestedFarmerMatch = {};&#10;&#10;&#10;  // Add sorting (by verification status, then name)&#10;    directFarmerMatch.$text = { $search: search };&#10;    nestedFarmerMatch[&quot;farmers&quot;] = {&#10;      $elemMatch: {&#10;    directFarmerMatch.specializations = {&#10;          { name: { $regex: search, $options: &quot;i&quot; } },&#10;          { description: { $regex: search, $options: &quot;i&quot; } },&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        specializations: {&#10;          $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;    directFarmerMatch.location = { $regex: location, $options: &quot;i&quot; };&#10;    console.error(&quot;Error fetching farmers:&quot;, error);&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or =&#10;        nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or || [];&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        location: { $regex: location, $options: &quot;i&quot; },&#10;      });&#10;    } else {&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: { location: { $regex: location, $options: &quot;i&quot; } },&#10;  if (Object.keys(directFarmerMatch).length &gt; 0) {&#10;    directFarmerMatch.name = { $exists: true };&#10;    directFarmerMatch.location = { $exists: true };&#10;    matchStage.$match.$or.push(directFarmerMatch);&#10;  }&#10;&#10;  if (Object.keys(nestedFarmerMatch).length &gt; 0) {&#10;    matchStage.$match.$or.push(nestedFarmerMatch);&#10;  }&#10;&#10;      : 50; // Increased default limit to show all farmers&#10;    matchStage.$match = {};&#10;      });&#10;    const includeStats = searchParams.get(&quot;includeStats&quot;) !== &quot;false&quot;; // Default to true&#10;&#10;  pipeline.push({&#10;    $facet: {&#10;      directFarmers: [&#10;        { $match: { name: { $exists: true }, location: { $exists: true } } },&#10;        { $count: &quot;count&quot; },&#10;      ],&#10;      nestedFarmers: [&#10;        { $match: { farmers: { $exists: true, $type: &quot;array&quot; } } },&#10;        { $unwind: &quot;$farmers&quot; },&#10;        { $count: &quot;count&quot; },&#10;      ],&#10;    },&#10;  });&#10;&#10;  const result = await farmersCollection.aggregate(pipeline).toArray();&#10;&#10;  if (result.length === 0) return 0;&#10;&#10;  const directCount = result[0].directFarmers[0]?.count || 0;&#10;  const nestedCount = result[0].nestedFarmers[0]?.count || 0;&#10;&#10;  return directCount + nestedCount;&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: {&#10;  const pipeline = [];&#10;          },&#10;        },&#10;      };&#10;    // Enhance farmers with product statistics if requested&#10;          { location: { $regex: search, $options: &quot;i&quot; } },&#10;          { farmName: { $regex: search, $options: &quot;i&quot; } },&#10;      },&#10;    };&#10;    // Get farmers using optimized aggregation pipeline&#10;        key: { verified: 1, isCertified: 1, createdAt: -1 },&#10;    }&#10;          { name: { $regex: search, $options: &quot;i&quot; } },&#10;          { description: { $regex: search, $options: &quot;i&quot; } },&#10;          { location: { $regex: search, $options: &quot;i&quot; } },&#10;          { farmName: { $regex: search, $options: &quot;i&quot; } },&#10;    } else {&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: { location: { $regex: location, $options: &quot;i&quot; } },&#10;      };&#10;      total: totalCount,&#10;      page,&#10;      totalPages: Math.ceil(totalCount / limit),&#10;  // Build match stage for filtering&#10;  const matchStage = { $match: { $or: [] } };&#10;    };&#10;  // Handle both direct farmers and nested farmers structure&#10;  const directFarmerMatch = {};&#10;  const nestedFarmerMatch = {};&#10;&#10;  // Add search filters&#10;        name: &quot;status_created_idx&quot;,&#10;        options: { background: true },&#10;      },&#10;    ];&#10;&#10;    for (const indexSpec of indexesToCreate) {&#10;      if (!indexNames.includes(indexSpec.name)) {&#10;        await farmersCollection.createIndex(indexSpec.key, {&#10;          name: indexSpec.name,&#10;    console.log(&quot;Atlas-optimized farmers indexes initialized successfully&quot;);&#10;        });&#10;      }&#10;    }&#10;&#10;    farmersIndexesInitialized = true;&#10;    console.log(&quot;Atlas-optimized farmers indexes initialized successfully&quot;);&#10;  } catch (error) {&#10;    console.log(&quot;Farmers index initialization note:&quot;, error.message);&#10;  }&#10;}&#10;&#10;// Generate cache key for request&#10;// Optimized farmers query using aggregation pipeline&#10;  const params = {};&#10;  searchParams.forEach((value, key) =&gt; {&#10;    params[key] = value;&#10;  });&#10;  return JSON.stringify(params);&#10;}&#10;&#10;// Get cached response if available and not expired&#10;function getCachedResponse(cacheKey) {&#10;  const cached = responseCache.get(cacheKey);&#10;  if (cached &amp;&amp; Date.now() - cached.timestamp &lt; CACHE_TTL) {&#10;    return cached.data;&#10;  }&#10;  responseCache.delete(cacheKey);&#10;  return null;&#10;}&#10;&#10;// Set response in cache&#10;function setCachedResponse(cacheKey, data) {&#10;  responseCache.set(cacheKey, {&#10;    data,&#10;    timestamp: Date.now(),&#10;  });&#10;&#10;  // Clear cache if it gets too large&#10;  if (responseCache.size &gt; 100) {&#10;    const now = Date.now();&#10;    for (const [key, value] of responseCache.entries()) {&#10;      if (now - value.timestamp &gt;= CACHE_TTL) {&#10;        responseCache.delete(key);&#10;      }&#10;    }&#10;  }&#10;}&#10;&#10;// Enhanced farmer data with product statistics&#10;async function enhanceFarmersWithStats(&#10;  farmersCollection,&#10;  productsCollection,&#10;  farmers,&#10;) {&#10;  if (farmers.length === 0) return farmers;&#10;&#10;  // Get all farmer IDs and names for batch processing&#10;  const farmerIds = farmers.map((f) =&gt; f._id).filter(Boolean);&#10;  const farmerNames = farmers.map((f) =&gt; f.name).filter(Boolean);&#10;  const farmerEmails = farmers.map((f) =&gt; f.email).filter(Boolean);&#10;&#10;  // Calculate statistics for all farmers in a single aggregation&#10;// Optimized farmers query using aggregation pipeline&#10;    {&#10;      $match: {&#10;        $or: [&#10;          { farmerId: { $in: farmerIds } },&#10;          { &quot;farmer._id&quot;: { $in: farmerIds } },&#10;          { &quot;farmer.name&quot;: { $in: farmerNames } },&#10;          { farmerEmail: { $in: farmerEmails } },&#10;        ],&#10;  const pipeline = [];&#10;    {&#10;  // Build match stage for filtering&#10;  const matchStage = { $match: { $or: [] } };&#10;            { $ne: [&quot;$farmerId&quot;, null] },&#10;            &quot;$farmerId&quot;,&#10;            {&#10;  // Handle both direct farmers and nested farmers structure&#10;  const directFarmerMatch = {};&#10;  const nestedFarmerMatch = {};&#10;&#10;  // Add search filters&#10;                { $ne: [&quot;$farmer._id&quot;, null] },&#10;                &quot;$farmer._id&quot;,&#10;                {&#10;    }&#10;          { name: { $regex: search, $options: &quot;i&quot; } },&#10;          { description: { $regex: search, $options: &quot;i&quot; } },&#10;          { location: { $regex: search, $options: &quot;i&quot; } },&#10;          { farmName: { $regex: search, $options: &quot;i&quot; } },&#10;    } else {&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: { location: { $regex: location, $options: &quot;i&quot; } },&#10;      };&#10;      total: totalCount,&#10;      page,&#10;      totalPages: Math.ceil(totalCount / limit),&#10;  // Build match stage for filtering&#10;  const matchStage = { $match: { $or: [] } };&#10;    };&#10;  // Handle both direct farmers and nested farmers structure&#10;  const directFarmerMatch = {};&#10;  const nestedFarmerMatch = {};&#10;&#10;  // Add search filters&#10;                  $cond: [&#10;// Get total count for pagination&#10;  const matchStage = { $match: { $or: [] } };&#10;&#10;    directFarmerMatch.$text = { $search: search };&#10;    nestedFarmerMatch[&quot;farmers&quot;] = {&#10;      $elemMatch: {&#10;        $or: [&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;    directFarmerMatch.$text = { $search: search };&#10;    nestedFarmerMatch[&quot;farmers&quot;] = {&#10;&#10;      $elemMatch: {&#10;        $or: [&#10;    directFarmerMatch.specializations = {&#10;          { description: { $regex: search, $options: &quot;i&quot; } },&#10;          { location: { $regex: search, $options: &quot;i&quot; } },&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        specializations: {&#10;          $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;        },&#10;      });&#10;    } else {&#10;  // If no specific filters, match all documents&#10;  if (matchStage.$match.$or.length === 0) {&#10;    matchStage.$match = {};&#10;  }&#10;&#10;  pipeline.push(matchStage);&#10;&#10;  // Add facet stage for both direct and nested farmers&#10;  pipeline.push({&#10;    $facet: {&#10;      directFarmers: [&#10;        { $match: { name: { $exists: true }, location: { $exists: true } } },&#10;        { $project: { farmers: 0 } }, // Exclude nested farmers array&#10;      ],&#10;      nestedFarmers: [&#10;        { $match: { farmers: { $exists: true, $type: &quot;array&quot; } } },&#10;        { $unwind: &quot;$farmers&quot; },&#10;        { $replaceRoot: { newRoot: &quot;$farmers&quot; } },&#10;      ],&#10;    },&#10;  });&#10;&#10;  // Combine results&#10;  pipeline.push({&#10;  const pipeline = [];&#10;        const productsUpdateResult = await db.collection(&quot;products&quot;).updateMany(&#10;  // Build match stage (same as main query)&#10;  const matchStage = { $match: { $or: [] } };&#10;  pipeline.push({ $unwind: &quot;$allFarmers&quot; });&#10;  const directFarmerMatch = {};&#10;  const nestedFarmerMatch = {};&#10;&#10;&#10;  // Add sorting (by verification status, then name)&#10;    directFarmerMatch.$text = { $search: search };&#10;    nestedFarmerMatch[&quot;farmers&quot;] = {&#10;      $elemMatch: {&#10;    directFarmerMatch.specializations = {&#10;          { name: { $regex: search, $options: &quot;i&quot; } },&#10;          { description: { $regex: search, $options: &quot;i&quot; } },&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        specializations: {&#10;          $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;    directFarmerMatch.location = { $regex: location, $options: &quot;i&quot; };&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or =&#10;        nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or || [];&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        location: { $regex: location, $options: &quot;i&quot; },&#10;      });&#10;    } else {&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: { location: { $regex: location, $options: &quot;i&quot; } },&#10;      };&#10;    }&#10;  }&#10;&#10;  if (Object.keys(directFarmerMatch).length &gt; 0) {&#10;    directFarmerMatch.name = { $exists: true };&#10;    directFarmerMatch.location = { $exists: true };&#10;    matchStage.$match.$or.push(directFarmerMatch);&#10;  }&#10;&#10;  if (Object.keys(nestedFarmerMatch).length &gt; 0) {&#10;    matchStage.$match.$or.push(nestedFarmerMatch);&#10;  }&#10;&#10;  if (matchStage.$match.$or.length === 0) {&#10;      : 50; // Increased default limit to show all farmers&#10;      });&#10;    const includeStats = searchParams.get(&quot;includeStats&quot;) !== &quot;false&quot;; // Default to true&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: {&#10;          specializations: {&#10;            $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;          },&#10;        },&#10;      };&#10;    }&#10;          { location: { $regex: search, $options: &quot;i&quot; } },&#10;          { farmName: { $regex: search, $options: &quot;i&quot; } },&#10;      },&#10;    };&#10;    // Get farmers using optimized aggregation pipeline&#10;      };&#10;    }&#10;          { farmName: { $regex: search, $options: &quot;i&quot; } },&#10;        ],&#10;      },&#10;    };&#10;    directFarmerMatch.location = { $regex: location, $options: &quot;i&quot; };&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or =&#10;        nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or || [];&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        location: { $regex: location, $options: &quot;i&quot; },&#10;      });&#10;    } else {&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: { location: { $regex: location, $options: &quot;i&quot; } },&#10;      };&#10;    // Enhance farmers with product statistics if requested&#10;  }&#10;&#10;  // Add conditions for direct farmers&#10;  if (Object.keys(directFarmerMatch).length &gt; 0) {&#10;    directFarmerMatch.name = { $exists: true };&#10;    directFarmerMatch.location = { $exists: true };&#10;    matchStage.$match.$or.push(directFarmerMatch);&#10;  }&#10;&#10;  // Add conditions for nested farmers&#10;  if (Object.keys(nestedFarmerMatch).length &gt; 0) {&#10;  }&#10;&#10;  pipeline.push(matchStage);&#10;&#10;      total: totalCount,&#10;      page,&#10;      totalPages: Math.ceil(totalCount / limit),&#10;      hasNextPage: page * limit &lt; totalCount,&#10;      hasPrevPage: page &gt; 1,&#10;  });&#10;&#10;  // Combine results&#10;  pipeline.push({&#10;  const pipeline = [];&#10;&#10;  // Build match stage (same as main query)&#10;  const matchStage = { $match: { $or: [] } };&#10;  pipeline.push(matchStage);&#10;&#10;  pipeline.push({&#10;    $facet: {&#10;      directFarmers: [&#10;        { $match: { name: { $exists: true }, location: { $exists: true } } },&#10;        { $count: &quot;count&quot; },&#10;&#10;      ],&#10;      nestedFarmers: [&#10;        { $match: { farmers: { $exists: true, $type: &quot;array&quot; } } },&#10;        { $unwind: &quot;$farmers&quot; },&#10;        { $count: &quot;count&quot; },&#10;      ],&#10;    },&#10;  });&#10;&#10;  const result = await farmersCollection.aggregate(pipeline).toArray();&#10;&#10;  if (result.length === 0) return 0;&#10;&#10;  const directCount = result[0].directFarmers[0]?.count || 0;&#10;  const nestedCount = result[0].nestedFarmers[0]?.count || 0;&#10;&#10;  return directCount + nestedCount;&#10;  const directFarmerMatch = {};&#10;  const nestedFarmerMatch = {};&#10;&#10;&#10;  // Add sorting (by verification status, then name)&#10;    directFarmerMatch.$text = { $search: search };&#10;    nestedFarmerMatch[&quot;farmers&quot;] = {&#10;      $elemMatch: {&#10;    directFarmerMatch.specializations = {&#10;          { name: { $regex: search, $options: &quot;i&quot; } },&#10;          { description: { $regex: search, $options: &quot;i&quot; } },&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        specializations: {&#10;          $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;    directFarmerMatch.location = { $regex: location, $options: &quot;i&quot; };&#10;    console.error(&quot;Error fetching farmers:&quot;, error);&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or =&#10;        nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or || [];&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        location: { $regex: location, $options: &quot;i&quot; },&#10;      });&#10;    } else {&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: { location: { $regex: location, $options: &quot;i&quot; } },&#10;  if (Object.keys(directFarmerMatch).length &gt; 0) {&#10;    directFarmerMatch.name = { $exists: true };&#10;    directFarmerMatch.location = { $exists: true };&#10;    matchStage.$match.$or.push(directFarmerMatch);&#10;  }&#10;&#10;  if (Object.keys(nestedFarmerMatch).length &gt; 0) {&#10;    matchStage.$match.$or.push(nestedFarmerMatch);&#10;  }&#10;&#10;      : 50; // Increased default limit to show all farmers&#10;    matchStage.$match = {};&#10;      });&#10;    const includeStats = searchParams.get(&quot;includeStats&quot;) !== &quot;false&quot;; // Default to true&#10;&#10;  pipeline.push({&#10;    $facet: {&#10;      directFarmers: [&#10;        { $match: { name: { $exists: true }, location: { $exists: true } } },&#10;        { $count: &quot;count&quot; },&#10;      ],&#10;      nestedFarmers: [&#10;        { $match: { farmers: { $exists: true, $type: &quot;array&quot; } } },&#10;        { $unwind: &quot;$farmers&quot; },&#10;        { $count: &quot;count&quot; },&#10;      ],&#10;    },&#10;  });&#10;&#10;  const result = await farmersCollection.aggregate(pipeline).toArray();&#10;&#10;  if (result.length === 0) return 0;&#10;&#10;  const directCount = result[0].directFarmers[0]?.count || 0;&#10;  const nestedCount = result[0].nestedFarmers[0]?.count || 0;&#10;&#10;  return directCount + nestedCount;&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: {&#10;          specializations: {&#10;            $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;          },&#10;        },&#10;      };&#10;    // Enhance farmers with product statistics if requested&#10;          { location: { $regex: search, $options: &quot;i&quot; } },&#10;          { farmName: { $regex: search, $options: &quot;i&quot; } },&#10;      },&#10;    };&#10;    // Get farmers using optimized aggregation pipeline&#10;      };&#10;    }&#10;          { name: { $regex: search, $options: &quot;i&quot; } },&#10;          { description: { $regex: search, $options: &quot;i&quot; } },&#10;          { location: { $regex: search, $options: &quot;i&quot; } },&#10;          { farmName: { $regex: search, $options: &quot;i&quot; } },&#10;    } else {&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: { location: { $regex: location, $options: &quot;i&quot; } },&#10;      };&#10;      total: totalCount,&#10;      page,&#10;      totalPages: Math.ceil(totalCount / limit),&#10;      hasNextPage: page * limit &lt; totalCount,&#10;      hasPrevPage: page &gt; 1,&#10;      },&#10;    };&#10;    directFarmerMatch.specializations = {&#10;&#10;// Get total count for pagination&#10;  const matchStage = { $match: { $or: [] } };&#10;&#10;  // Handle both direct farmers and nested farmers structure&#10;        const productsUpdateResult = await db.collection(&quot;products&quot;).updateMany(&#10;  const nestedFarmerMatch = {};&#10;&#10;  // Add search filters&#10;    }&#10;  }&#10;        $or: [&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;    directFarmerMatch.$text = { $search: search };&#10;    nestedFarmerMatch[&quot;farmers&quot;] = {&#10;&#10;      $elemMatch: {&#10;        $or: [&#10;    directFarmerMatch.specializations = {&#10;          { description: { $regex: search, $options: &quot;i&quot; } },&#10;          { location: { $regex: search, $options: &quot;i&quot; } },&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        specializations: {&#10;          $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;        },&#10;      });&#10;    } else {&#10;  // If no specific filters, match all documents&#10;  if (matchStage.$match.$or.length === 0) {&#10;    matchStage.$match = {};&#10;  }&#10;&#10;  pipeline.push(matchStage);&#10;&#10;  // Add facet stage for both direct and nested farmers&#10;  pipeline.push({&#10;    $facet: {&#10;      directFarmers: [&#10;        { $match: { name: { $exists: true }, location: { $exists: true } } },&#10;        { $project: { farmers: 0 } }, // Exclude nested farmers array&#10;      ],&#10;      nestedFarmers: [&#10;        { $match: { farmers: { $exists: true, $type: &quot;array&quot; } } },&#10;        { $unwind: &quot;$farmers&quot; },&#10;        { $replaceRoot: { newRoot: &quot;$farmers&quot; } },&#10;      ],&#10;    },&#10;  });&#10;&#10;  // Combine results&#10;  pipeline.push({&#10;  const pipeline = [];&#10;        const productsUpdateResult = await db.collection(&quot;products&quot;).updateMany(&#10;  // Build match stage (same as main query)&#10;  const matchStage = { $match: { $or: [] } };&#10;  pipeline.push({ $unwind: &quot;$allFarmers&quot; });&#10;  const directFarmerMatch = {};&#10;  const nestedFarmerMatch = {};&#10;&#10;&#10;  // Add sorting (by verification status, then name)&#10;    directFarmerMatch.$text = { $search: search };&#10;    nestedFarmerMatch[&quot;farmers&quot;] = {&#10;      $elemMatch: {&#10;    directFarmerMatch.specializations = {&#10;          { name: { $regex: search, $options: &quot;i&quot; } },&#10;          { description: { $regex: search, $options: &quot;i&quot; } },&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        specializations: {&#10;          $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;    directFarmerMatch.location = { $regex: location, $options: &quot;i&quot; };&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or =&#10;        nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or || [];&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        location: { $regex: location, $options: &quot;i&quot; },&#10;      });&#10;    } else {&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: { location: { $regex: location, $options: &quot;i&quot; } },&#10;      };&#10;    }&#10;  }&#10;&#10;  if (Object.keys(directFarmerMatch).length &gt; 0) {&#10;    directFarmerMatch.name = { $exists: true };&#10;    directFarmerMatch.location = { $exists: true };&#10;    matchStage.$match.$or.push(directFarmerMatch);&#10;  }&#10;&#10;  if (Object.keys(nestedFarmerMatch).length &gt; 0) {&#10;    matchStage.$match.$or.push(nestedFarmerMatch);&#10;  }&#10;&#10;  if (matchStage.$match.$or.length === 0) {&#10;      : 50; // Increased default limit to show all farmers&#10;      });&#10;    const includeStats = searchParams.get(&quot;includeStats&quot;) !== &quot;false&quot;; // Default to true&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: {&#10;          specializations: {&#10;            $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;          },&#10;        },&#10;      };&#10;    }&#10;          { location: { $regex: search, $options: &quot;i&quot; } },&#10;          { farmName: { $regex: search, $options: &quot;i&quot; } },&#10;      },&#10;    };&#10;    // Get farmers using optimized aggregation pipeline&#10;      };&#10;    }&#10;          { farmName: { $regex: search, $options: &quot;i&quot; } },&#10;        ],&#10;      },&#10;    };&#10;    directFarmerMatch.location = { $regex: location, $options: &quot;i&quot; };&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or =&#10;        nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or || [];&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        location: { $regex: location, $options: &quot;i&quot; },&#10;      });&#10;    } else {&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: { location: { $regex: location, $options: &quot;i&quot; } },&#10;      };&#10;    // Enhance farmers with product statistics if requested&#10;  }&#10;&#10;  // Add conditions for direct farmers&#10;  if (Object.keys(directFarmerMatch).length &gt; 0) {&#10;    directFarmerMatch.name = { $exists: true };&#10;    directFarmerMatch.location = { $exists: true };&#10;    matchStage.$match.$or.push(directFarmerMatch);&#10;  }&#10;&#10;  // Add conditions for nested farmers&#10;  if (Object.keys(nestedFarmerMatch).length &gt; 0) {&#10;  }&#10;&#10;  pipeline.push(matchStage);&#10;&#10;      total: totalCount,&#10;      page,&#10;      totalPages: Math.ceil(totalCount / limit),&#10;      hasNextPage: page * limit &lt; totalCount,&#10;      hasPrevPage: page &gt; 1,&#10;  });&#10;&#10;  // Combine results&#10;  pipeline.push({&#10;  const pipeline = [];&#10;&#10;  // Build match stage (same as main query)&#10;  const matchStage = { $match: { $or: [] } };&#10;  pipeline.push(matchStage);&#10;&#10;  pipeline.push({&#10;    $facet: {&#10;      directFarmers: [&#10;        { $match: { name: { $exists: true }, location: { $exists: true } } },&#10;        { $count: &quot;count&quot; },&#10;&#10;      ],&#10;      nestedFarmers: [&#10;        { $match: { farmers: { $exists: true, $type: &quot;array&quot; } } },&#10;        { $unwind: &quot;$farmers&quot; },&#10;        { $count: &quot;count&quot; },&#10;      ],&#10;    },&#10;  });&#10;&#10;  const result = await farmersCollection.aggregate(pipeline).toArray();&#10;&#10;  if (result.length === 0) return 0;&#10;&#10;  const directCount = result[0].directFarmers[0]?.count || 0;&#10;  const nestedCount = result[0].nestedFarmers[0]?.count || 0;&#10;&#10;  return directCount + nestedCount;&#10;  const directFarmerMatch = {};&#10;  const nestedFarmerMatch = {};&#10;&#10;&#10;  // Add sorting (by verification status, then name)&#10;    directFarmerMatch.$text = { $search: search };&#10;    nestedFarmerMatch[&quot;farmers&quot;] = {&#10;      $elemMatch: {&#10;    directFarmerMatch.specializations = {&#10;          { name: { $regex: search, $options: &quot;i&quot; } },&#10;          { description: { $regex: search, $options: &quot;i&quot; } },&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        specializations: {&#10;          $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;    directFarmerMatch.location = { $regex: location, $options: &quot;i&quot; };&#10;    console.error(&quot;Error fetching farmers:&quot;, error);&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or =&#10;        nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or || [];&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        location: { $regex: location, $options: &quot;i&quot; },&#10;      });&#10;    } else {&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: { location: { $regex: location, $options: &quot;i&quot; } },&#10;  if (Object.keys(directFarmerMatch).length &gt; 0) {&#10;    directFarmerMatch.name = { $exists: true };&#10;    directFarmerMatch.location = { $exists: true };&#10;    matchStage.$match.$or.push(directFarmerMatch);&#10;  }&#10;&#10;  if (Object.keys(nestedFarmerMatch).length &gt; 0) {&#10;    matchStage.$match.$or.push(nestedFarmerMatch);&#10;  }&#10;&#10;      : 50; // Increased default limit to show all farmers&#10;    matchStage.$match = {};&#10;      });&#10;    const includeStats = searchParams.get(&quot;includeStats&quot;) !== &quot;false&quot;; // Default to true&#10;&#10;  pipeline.push({&#10;    $facet: {&#10;      directFarmers: [&#10;        { $match: { name: { $exists: true }, location: { $exists: true } } },&#10;        { $count: &quot;count&quot; },&#10;      ],&#10;      nestedFarmers: [&#10;        { $match: { farmers: { $exists: true, $type: &quot;array&quot; } } },&#10;        { $unwind: &quot;$farmers&quot; },&#10;        { $count: &quot;count&quot; },&#10;      ],&#10;    },&#10;  });&#10;&#10;  const result = await farmersCollection.aggregate(pipeline).toArray();&#10;&#10;  if (result.length === 0) return 0;&#10;&#10;  const directCount = result[0].directFarmers[0]?.count || 0;&#10;  const nestedCount = result[0].nestedFarmers[0]?.count || 0;&#10;&#10;  return directCount + nestedCount;&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: {&#10;  const pipeline = [];&#10;          },&#10;        },&#10;      };&#10;    // Enhance farmers with product statistics if requested&#10;          { location: { $regex: search, $options: &quot;i&quot; } },&#10;          { farmName: { $regex: search, $options: &quot;i&quot; } },&#10;      },&#10;    };&#10;    // Get farmers using optimized aggregation pipeline&#10;                    &quot;$farmerEmail&quot;,&#10;                  ],&#10;                },&#10;              ],&#10;            },&#10;          ],&#10;        },&#10;        totalProducts: { $sum: 1 },&#10;        activeProducts: {&#10;          $sum: { $cond: [{ $gt: [&quot;$stock&quot;, 0] }, 1, 0] },&#10;        },&#10;        averageRating: { $avg: &quot;$averageRating&quot; },&#10;        totalSales: { $sum: &quot;$purchaseCount&quot; },&#10;        featuredProducts: {&#10;          $sum: { $cond: [&quot;$featured&quot;, 1, 0] },&#10;        },&#10;      },&#10;    },&#10;  ];&#10;&#10;  const statsResults = await productsCollection&#10;    .aggregate(statsAggregation)&#10;    .toArray();&#10;// Optimized farmers query using aggregation pipeline&#10;  // Create a lookup map for quick stats access&#10;  const statsMap = new Map();&#10;  statsResults.forEach((stat) =&gt; {&#10;    statsMap.set(stat._id, {&#10;      totalProducts: stat.totalProducts || 0,&#10;      activeProducts: stat.activeProducts || 0,&#10;      averageRating: Math.round((stat.averageRating || 0) * 10) / 10,&#10;      totalSales: stat.totalSales || 0,&#10;  const pipeline = [];&#10;  });&#10;  // Build match stage for filtering&#10;  const matchStage = { $match: { $or: [] } };&#10;    const stats = statsMap.get(farmer._id) ||&#10;      statsMap.get(farmer.name) ||&#10;  // Handle both direct farmers and nested farmers structure&#10;  const directFarmerMatch = {};&#10;  const nestedFarmerMatch = {};&#10;&#10;  // Add search filters&#10;        totalProducts: 0,&#10;        activeProducts: 0,&#10;        averageRating: 0,&#10;        totalSales: 0,&#10;    directFarmerMatch.$text = { $search: search };&#10;    nestedFarmerMatch[&quot;farmers&quot;] = {&#10;      $elemMatch: {&#10;        $or: [&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;    directFarmerMatch.$text = { $search: search };&#10;    nestedFarmerMatch[&quot;farmers&quot;] = {&#10;&#10;      $elemMatch: {&#10;        $or: [&#10;    directFarmerMatch.specializations = {&#10;          { description: { $regex: search, $options: &quot;i&quot; } },&#10;          { location: { $regex: search, $options: &quot;i&quot; } },&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        specializations: {&#10;          $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;        },&#10;      });&#10;    } else {&#10;  // If no specific filters, match all documents&#10;  if (matchStage.$match.$or.length === 0) {&#10;    matchStage.$match = {};&#10;  }&#10;&#10;  pipeline.push(matchStage);&#10;&#10;  // Add facet stage for both direct and nested farmers&#10;  pipeline.push({&#10;    $facet: {&#10;      directFarmers: [&#10;        { $match: { name: { $exists: true }, location: { $exists: true } } },&#10;        { $project: { farmers: 0 } }, // Exclude nested farmers array&#10;      ],&#10;      nestedFarmers: [&#10;        { $match: { farmers: { $exists: true, $type: &quot;array&quot; } } },&#10;        { $unwind: &quot;$farmers&quot; },&#10;        { $replaceRoot: { newRoot: &quot;$farmers&quot; } },&#10;      ],&#10;    },&#10;  });&#10;&#10;  // Combine results&#10;  pipeline.push({&#10;  const pipeline = [];&#10;        const productsUpdateResult = await db.collection(&quot;products&quot;).updateMany(&#10;  // Build match stage (same as main query)&#10;  const matchStage = { $match: { $or: [] } };&#10;  pipeline.push({ $unwind: &quot;$allFarmers&quot; });&#10;  const directFarmerMatch = {};&#10;  const nestedFarmerMatch = {};&#10;&#10;&#10;  // Add sorting (by verification status, then name)&#10;    directFarmerMatch.$text = { $search: search };&#10;    nestedFarmerMatch[&quot;farmers&quot;] = {&#10;      $elemMatch: {&#10;    directFarmerMatch.specializations = {&#10;          { name: { $regex: search, $options: &quot;i&quot; } },&#10;          { description: { $regex: search, $options: &quot;i&quot; } },&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        specializations: {&#10;          $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;    directFarmerMatch.location = { $regex: location, $options: &quot;i&quot; };&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or =&#10;        nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or || [];&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        location: { $regex: location, $options: &quot;i&quot; },&#10;      });&#10;    } else {&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: { location: { $regex: location, $options: &quot;i&quot; } },&#10;      };&#10;    }&#10;  }&#10;&#10;  if (Object.keys(directFarmerMatch).length &gt; 0) {&#10;    directFarmerMatch.name = { $exists: true };&#10;    directFarmerMatch.location = { $exists: true };&#10;    matchStage.$match.$or.push(directFarmerMatch);&#10;  }&#10;&#10;  if (Object.keys(nestedFarmerMatch).length &gt; 0) {&#10;    matchStage.$match.$or.push(nestedFarmerMatch);&#10;  }&#10;&#10;  if (matchStage.$match.$or.length === 0) {&#10;      : 50; // Increased default limit to show all farmers&#10;      });&#10;    const includeStats = searchParams.get(&quot;includeStats&quot;) !== &quot;false&quot;; // Default to true&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: {&#10;          specializations: {&#10;            $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;          },&#10;        },&#10;      };&#10;    }&#10;          { location: { $regex: search, $options: &quot;i&quot; } },&#10;          { farmName: { $regex: search, $options: &quot;i&quot; } },&#10;      },&#10;    };&#10;    // Get farmers using optimized aggregation pipeline&#10;      };&#10;    }&#10;          { farmName: { $regex: search, $options: &quot;i&quot; } },&#10;        ],&#10;      },&#10;    };&#10;    directFarmerMatch.location = { $regex: location, $options: &quot;i&quot; };&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or =&#10;        nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or || [];&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        location: { $regex: location, $options: &quot;i&quot; },&#10;      });&#10;    } else {&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: { location: { $regex: location, $options: &quot;i&quot; } },&#10;      };&#10;    // Enhance farmers with product statistics if requested&#10;  }&#10;&#10;  // Add conditions for direct farmers&#10;  if (Object.keys(directFarmerMatch).length &gt; 0) {&#10;    directFarmerMatch.name = { $exists: true };&#10;    directFarmerMatch.location = { $exists: true };&#10;    matchStage.$match.$or.push(directFarmerMatch);&#10;  }&#10;&#10;  // Add conditions for nested farmers&#10;  if (Object.keys(nestedFarmerMatch).length &gt; 0) {&#10;  }&#10;&#10;  pipeline.push(matchStage);&#10;&#10;      total: totalCount,&#10;      page,&#10;      totalPages: Math.ceil(totalCount / limit),&#10;      hasNextPage: page * limit &lt; totalCount,&#10;      hasPrevPage: page &gt; 1,&#10;  });&#10;&#10;  // Combine results&#10;  pipeline.push({&#10;  const pipeline = [];&#10;&#10;  // Build match stage (same as main query)&#10;  const matchStage = { $match: { $or: [] } };&#10;  pipeline.push(matchStage);&#10;&#10;  pipeline.push({&#10;    $facet: {&#10;      directFarmers: [&#10;        { $match: { name: { $exists: true }, location: { $exists: true } } },&#10;        { $count: &quot;count&quot; },&#10;&#10;      ],&#10;      nestedFarmers: [&#10;        { $match: { farmers: { $exists: true, $type: &quot;array&quot; } } },&#10;        { $unwind: &quot;$farmers&quot; },&#10;        { $count: &quot;count&quot; },&#10;      ],&#10;    },&#10;  });&#10;&#10;  const result = await farmersCollection.aggregate(pipeline).toArray();&#10;&#10;  if (result.length === 0) return 0;&#10;&#10;  const directCount = result[0].directFarmers[0]?.count || 0;&#10;  const nestedCount = result[0].nestedFarmers[0]?.count || 0;&#10;&#10;  return directCount + nestedCount;&#10;  const directFarmerMatch = {};&#10;  const nestedFarmerMatch = {};&#10;&#10;&#10;  // Add sorting (by verification status, then name)&#10;    directFarmerMatch.$text = { $search: search };&#10;    nestedFarmerMatch[&quot;farmers&quot;] = {&#10;      $elemMatch: {&#10;    directFarmerMatch.specializations = {&#10;          { name: { $regex: search, $options: &quot;i&quot; } },&#10;          { description: { $regex: search, $options: &quot;i&quot; } },&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        specializations: {&#10;          $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;    directFarmerMatch.location = { $regex: location, $options: &quot;i&quot; };&#10;    console.error(&quot;Error fetching farmers:&quot;, error);&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or =&#10;        nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or || [];&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        location: { $regex: location, $options: &quot;i&quot; },&#10;      });&#10;    } else {&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: { location: { $regex: location, $options: &quot;i&quot; } },&#10;  if (Object.keys(directFarmerMatch).length &gt; 0) {&#10;    directFarmerMatch.name = { $exists: true };&#10;    directFarmerMatch.location = { $exists: true };&#10;    matchStage.$match.$or.push(directFarmerMatch);&#10;  }&#10;&#10;  if (Object.keys(nestedFarmerMatch).length &gt; 0) {&#10;    matchStage.$match.$or.push(nestedFarmerMatch);&#10;  }&#10;&#10;      : 50; // Increased default limit to show all farmers&#10;    matchStage.$match = {};&#10;      });&#10;    const includeStats = searchParams.get(&quot;includeStats&quot;) !== &quot;false&quot;; // Default to true&#10;&#10;  pipeline.push({&#10;    $facet: {&#10;      directFarmers: [&#10;        { $match: { name: { $exists: true }, location: { $exists: true } } },&#10;        { $count: &quot;count&quot; },&#10;      ],&#10;      nestedFarmers: [&#10;        { $match: { farmers: { $exists: true, $type: &quot;array&quot; } } },&#10;        { $unwind: &quot;$farmers&quot; },&#10;        { $count: &quot;count&quot; },&#10;      ],&#10;    },&#10;  });&#10;&#10;  const result = await farmersCollection.aggregate(pipeline).toArray();&#10;&#10;  if (result.length === 0) return 0;&#10;&#10;  const directCount = result[0].directFarmers[0]?.count || 0;&#10;  const nestedCount = result[0].nestedFarmers[0]?.count || 0;&#10;&#10;  return directCount + nestedCount;&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: {&#10;          specializations: {&#10;            $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;          },&#10;        },&#10;      };&#10;    // Enhance farmers with product statistics if requested&#10;          { location: { $regex: search, $options: &quot;i&quot; } },&#10;          { farmName: { $regex: search, $options: &quot;i&quot; } },&#10;      },&#10;    };&#10;    // Get farmers using optimized aggregation pipeline&#10;      };&#10;    }&#10;          { name: { $regex: search, $options: &quot;i&quot; } },&#10;          { description: { $regex: search, $options: &quot;i&quot; } },&#10;          { location: { $regex: search, $options: &quot;i&quot; } },&#10;          { farmName: { $regex: search, $options: &quot;i&quot; } },&#10;    } else {&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: { location: { $regex: location, $options: &quot;i&quot; } },&#10;      };&#10;      total: totalCount,&#10;      page,&#10;      totalPages: Math.ceil(totalCount / limit),&#10;      hasNextPage: page * limit &lt; totalCount,&#10;      hasPrevPage: page &gt; 1,&#10;      },&#10;    };&#10;    directFarmerMatch.specializations = {&#10;&#10;// Get total count for pagination&#10;  const matchStage = { $match: { $or: [] } };&#10;&#10;  // Handle both direct farmers and nested farmers structure&#10;  const directFarmerMatch = {};&#10;        const productsUpdateResult = await db.collection(&quot;products&quot;).updateMany(&#10;&#10;  // Add search filters&#10;    }&#10;  }&#10;      bio: farmer.bio || farmer.description,&#10;      verified: farmer.verified || farmer.isCertified || false,&#10;      stats,&#10;    };&#10;  const pipeline = [];&#10;&#10;  // Build match stage for filtering&#10;  const matchStage = { $match: { $or: [] } };&#10;  search,&#10;  // Handle both direct farmers and nested farmers structure&#10;  const directFarmerMatch = {};&#10;  const nestedFarmerMatch = {};&#10;&#10;  // Add search filters&#10;  location,&#10;  limit,&#10;  page,&#10;    directFarmerMatch.$text = { $search: search };&#10;    nestedFarmerMatch[&quot;farmers&quot;] = {&#10;      $elemMatch: {&#10;        $or: [&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        specializations: {&#10;          $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;        },&#10;      });&#10;    } else {&#10;  // If no specific filters, match all documents&#10;  if (matchStage.$match.$or.length === 0) {&#10;    matchStage.$match = {};&#10;  }&#10;&#10;  pipeline.push(matchStage);&#10;&#10;  // Add facet stage for both direct and nested farmers&#10;  pipeline.push({&#10;    $facet: {&#10;      directFarmers: [&#10;        { $match: { name: { $exists: true }, location: { $exists: true } } },&#10;        { $project: { farmers: 0 } }, // Exclude nested farmers array&#10;      ],&#10;      nestedFarmers: [&#10;        { $match: { farmers: { $exists: true, $type: &quot;array&quot; } } },&#10;        { $unwind: &quot;$farmers&quot; },&#10;        { $replaceRoot: { newRoot: &quot;$farmers&quot; } },&#10;      ],&#10;    },&#10;  });&#10;&#10;  // Combine results&#10;  pipeline.push({&#10;  const pipeline = [];&#10;&#10;  // Build match stage (same as main query)&#10;  const matchStage = { $match: { $or: [] } };&#10;  pipeline.push({ $unwind: &quot;$allFarmers&quot; });&#10;  const directFarmerMatch = {};&#10;  const nestedFarmerMatch = {};&#10;&#10;&#10;  // Add sorting (by verification status, then name)&#10;    directFarmerMatch.$text = { $search: search };&#10;    nestedFarmerMatch[&quot;farmers&quot;] = {&#10;      $elemMatch: {&#10;    directFarmerMatch.specializations = {&#10;          { name: { $regex: search, $options: &quot;i&quot; } },&#10;          { description: { $regex: search, $options: &quot;i&quot; } },&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        specializations: {&#10;          $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;    directFarmerMatch.location = { $regex: location, $options: &quot;i&quot; };&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or =&#10;        nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or || [];&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        location: { $regex: location, $options: &quot;i&quot; },&#10;      });&#10;    } else {&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: { location: { $regex: location, $options: &quot;i&quot; } },&#10;      };&#10;    }&#10;  }&#10;&#10;  if (Object.keys(directFarmerMatch).length &gt; 0) {&#10;    directFarmerMatch.name = { $exists: true };&#10;    directFarmerMatch.location = { $exists: true };&#10;    matchStage.$match.$or.push(directFarmerMatch);&#10;  }&#10;&#10;  if (Object.keys(nestedFarmerMatch).length &gt; 0) {&#10;    matchStage.$match.$or.push(nestedFarmerMatch);&#10;  }&#10;&#10;      : 50; // Increased default limit to show all farmers&#10;    matchStage.$match = {};&#10;      });&#10;    const includeStats = searchParams.get(&quot;includeStats&quot;) !== &quot;false&quot;; // Default to true&#10;&#10;  pipeline.push({&#10;    $facet: {&#10;      directFarmers: [&#10;        { $match: { name: { $exists: true }, location: { $exists: true } } },&#10;        { $count: &quot;count&quot; },&#10;      ],&#10;      nestedFarmers: [&#10;        { $match: { farmers: { $exists: true, $type: &quot;array&quot; } } },&#10;        { $unwind: &quot;$farmers&quot; },&#10;        { $count: &quot;count&quot; },&#10;      ],&#10;    },&#10;  });&#10;&#10;  const result = await farmersCollection.aggregate(pipeline).toArray();&#10;&#10;  if (result.length === 0) return 0;&#10;&#10;  const directCount = result[0].directFarmers[0]?.count || 0;&#10;  const nestedCount = result[0].nestedFarmers[0]?.count || 0;&#10;&#10;  return directCount + nestedCount;&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: {&#10;          specializations: {&#10;            $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;          },&#10;        },&#10;      };&#10;    // Enhance farmers with product statistics if requested&#10;          { location: { $regex: search, $options: &quot;i&quot; } },&#10;          { farmName: { $regex: search, $options: &quot;i&quot; } },&#10;      },&#10;    };&#10;    // Get farmers using optimized aggregation pipeline&#10;      };&#10;    }&#10;          { name: { $regex: search, $options: &quot;i&quot; } },&#10;          { description: { $regex: search, $options: &quot;i&quot; } },&#10;          { location: { $regex: search, $options: &quot;i&quot; } },&#10;          { farmName: { $regex: search, $options: &quot;i&quot; } },&#10;    } else {&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: { location: { $regex: location, $options: &quot;i&quot; } },&#10;      };&#10;      total: totalCount,&#10;      page,&#10;      totalPages: Math.ceil(totalCount / limit),&#10;      hasNextPage: page * limit &lt; totalCount,&#10;      hasPrevPage: page &gt; 1,&#10;      },&#10;    };&#10;    directFarmerMatch.specializations = {&#10;&#10;// Get total count for pagination&#10;  const matchStage = { $match: { $or: [] } };&#10;&#10;  // Handle both direct farmers and nested farmers structure&#10;  const directFarmerMatch = {};&#10;  const nestedFarmerMatch = {};&#10;&#10;  // Add search filters&#10;  if (search) {&#10;    directFarmerMatch.$text = { $search: search };&#10;    nestedFarmerMatch[&quot;farmers&quot;] = {&#10;&#10;      $elemMatch: {&#10;        $or: [&#10;          { name: { $regex: search, $options: &quot;i&quot; } },&#10;          { description: { $regex: search, $options: &quot;i&quot; } },&#10;          { location: { $regex: search, $options: &quot;i&quot; } },&#10;          { farmName: { $regex: search, $options: &quot;i&quot; } },&#10;        ],&#10;      },&#10;    };&#10;  }&#10;    console.error(&quot;Error fetching farmers:&quot;, error);&#10;  // Add specialization filter&#10;  if (specialization) {&#10;    directFarmerMatch.specializations = {&#10;      $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;    };&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        specializations: {&#10;          $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;        },&#10;      });&#10;    } else {&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: {&#10;          specializations: {&#10;            $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;          },&#10;        },&#10;      };&#10;    }&#10;  }&#10;&#10;  // Add location filter&#10;  if (location) {&#10;    directFarmerMatch.location = { $regex: location, $options: &quot;i&quot; };&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or =&#10;        nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or || [];&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        location: { $regex: location, $options: &quot;i&quot; },&#10;      });&#10;    } else {&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: { location: { $regex: location, $options: &quot;i&quot; } },&#10;      };&#10;    }&#10;  }&#10;&#10;  // Add conditions for direct farmers&#10;  if (Object.keys(directFarmerMatch).length &gt; 0) {&#10;    directFarmerMatch.name = { $exists: true };&#10;    directFarmerMatch.location = { $exists: true };&#10;    matchStage.$match.$or.push(directFarmerMatch);&#10;  }&#10;&#10;  // Add conditions for nested farmers&#10;  if (Object.keys(nestedFarmerMatch).length &gt; 0) {&#10;    matchStage.$match.$or.push(nestedFarmerMatch);&#10;  }&#10;&#10;  // If no specific filters, match all documents&#10;  if (matchStage.$match.$or.length === 0) {&#10;    matchStage.$match = {};&#10;  }&#10;&#10;  pipeline.push(matchStage);&#10;&#10;  // Add facet stage for both direct and nested farmers&#10;  pipeline.push({&#10;    $facet: {&#10;      directFarmers: [&#10;        { $match: { name: { $exists: true }, location: { $exists: true } } },&#10;        { $project: { farmers: 0 } }, // Exclude nested farmers array&#10;      ],&#10;      nestedFarmers: [&#10;        { $match: { farmers: { $exists: true, $type: &quot;array&quot; } } },&#10;        { $unwind: &quot;$farmers&quot; },&#10;        { $replaceRoot: { newRoot: &quot;$farmers&quot; } },&#10;      ],&#10;    },&#10;  });&#10;&#10;  // Combine results&#10;  pipeline.push({&#10;    $project: {&#10;      allFarmers: { $concatArrays: [&quot;$directFarmers&quot;, &quot;$nestedFarmers&quot;] },&#10;    },&#10;  });&#10;&#10;  pipeline.push({ $unwind: &quot;$allFarmers&quot; });&#10;  pipeline.push({ $replaceRoot: { newRoot: &quot;$allFarmers&quot; } });&#10;&#10;  // Add sorting (by verification status, then name)&#10;  pipeline.push({&#10;    $sort: { verified: -1, isCertified: -1, name: 1 },&#10;  });&#10;&#10;  // Add pagination&#10;  if (limit) {&#10;    const skip = (page - 1) * limit;&#10;    pipeline.push({ $skip: skip });&#10;    pipeline.push({ $limit: limit });&#10;  }&#10;&#10;  return await farmersCollection.aggregate(pipeline).toArray();&#10;}&#10;&#10;// Get total count for pagination&#10;async function getFarmersCount(&#10;  farmersCollection,&#10;  search,&#10;  specialization,&#10;  location,&#10;) {&#10;  const pipeline = [];&#10;        const productsUpdateResult = await db.collection(&quot;products&quot;).updateMany(&#10;  // Build match stage (same as main query)&#10;  const matchStage = { $match: { $or: [] } };&#10;&#10;  const directFarmerMatch = {};&#10;  const nestedFarmerMatch = {};&#10;&#10;  if (search) {&#10;    directFarmerMatch.$text = { $search: search };&#10;    nestedFarmerMatch[&quot;farmers&quot;] = {&#10;      $elemMatch: {&#10;        $or: [&#10;          { name: { $regex: search, $options: &quot;i&quot; } },&#10;          { description: { $regex: search, $options: &quot;i&quot; } },&#10;          { location: { $regex: search, $options: &quot;i&quot; } },&#10;          { farmName: { $regex: search, $options: &quot;i&quot; } },&#10;        ],&#10;      },&#10;    };&#10;  }&#10;&#10;  if (specialization) {&#10;    directFarmerMatch.specializations = {&#10;      $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;    };&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        specializations: {&#10;          $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;        },&#10;      });&#10;    } else {&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: {&#10;          specializations: {&#10;            $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;          },&#10;        },&#10;      };&#10;    }&#10;  }&#10;&#10;  if (location) {&#10;    directFarmerMatch.location = { $regex: location, $options: &quot;i&quot; };&#10;    if (nestedFarmerMatch[&quot;farmers&quot;]) {&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or =&#10;        nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or || [];&#10;      nestedFarmerMatch[&quot;farmers&quot;].$elemMatch.$or.push({&#10;        location: { $regex: location, $options: &quot;i&quot; },&#10;      });&#10;    } else {&#10;      nestedFarmerMatch[&quot;farmers&quot;] = {&#10;        $elemMatch: { location: { $regex: location, $options: &quot;i&quot; } },&#10;      };&#10;    }&#10;  }&#10;&#10;  if (Object.keys(directFarmerMatch).length &gt; 0) {&#10;    directFarmerMatch.name = { $exists: true };&#10;    directFarmerMatch.location = { $exists: true };&#10;    matchStage.$match.$or.push(directFarmerMatch);&#10;  }&#10;&#10;  if (Object.keys(nestedFarmerMatch).length &gt; 0) {&#10;    matchStage.$match.$or.push(nestedFarmerMatch);&#10;  }&#10;&#10;  if (matchStage.$match.$or.length === 0) {&#10;    matchStage.$match = {};&#10;  }&#10;&#10;  pipeline.push(matchStage);&#10;&#10;  pipeline.push({&#10;    $facet: {&#10;      directFarmers: [&#10;        { $match: { name: { $exists: true }, location: { $exists: true } } },&#10;        { $count: &quot;count&quot; },&#10;      ],&#10;      nestedFarmers: [&#10;        { $match: { farmers: { $exists: true, $type: &quot;array&quot; } } },&#10;        { $unwind: &quot;$farmers&quot; },&#10;        { $count: &quot;count&quot; },&#10;      ],&#10;    },&#10;  });&#10;&#10;  const result = await farmersCollection.aggregate(pipeline).toArray();&#10;&#10;  if (result.length === 0) return 0;&#10;&#10;  const directCount = result[0].directFarmers[0]?.count || 0;&#10;  const nestedCount = result[0].nestedFarmers[0]?.count || 0;&#10;&#10;  return directCount + nestedCount;&#10;}&#10;&#10;export async function GET(request) {&#10;  try {&#10;    const { searchParams } = new URL(request.url);&#10;&#10;    // Check cache first&#10;    const cacheKey = generateCacheKey(searchParams);&#10;    const cachedResponse = getCachedResponse(cacheKey);&#10;    if (cachedResponse) {&#10;      const response = NextResponse.json(cachedResponse);&#10;      response.headers.set(&quot;X-Cache&quot;, &quot;HIT&quot;);&#10;      response.headers.set(&quot;Cache-Control&quot;, &quot;public, max-age=300&quot;);&#10;      return response;&#10;    }&#10;&#10;    const search = searchParams.get(&quot;search&quot;);&#10;    const specialization = searchParams.get(&quot;specialization&quot;);&#10;    const location = searchParams.get(&quot;location&quot;);&#10;    const limit = searchParams.get(&quot;limit&quot;)&#10;      ? parseInt(searchParams.get(&quot;limit&quot;))&#10;      : 50; // Increased default limit to show all farmers&#10;    const page = parseInt(searchParams.get(&quot;page&quot;)) || 1;&#10;    const includeStats = searchParams.get(&quot;includeStats&quot;) !== &quot;false&quot;; // Default to true&#10;&#10;    // Reuse database connections&#10;    if (!cachedDb) {&#10;      const client = await clientPromise;&#10;      cachedDb = client.db(&quot;farmfresh&quot;);&#10;      cachedFarmersCollection = cachedDb.collection(&quot;farmers&quot;);&#10;      cachedProductsCollection = cachedDb.collection(&quot;products&quot;);&#10;    }&#10;&#10;    // Initialize indexes only once&#10;    await initializeFarmersIndexes(cachedDb);&#10;&#10;    // Get farmers using optimized aggregation pipeline&#10;    const [farmers, totalCount] = await Promise.all([&#10;      getFarmersOptimized(&#10;        cachedFarmersCollection,&#10;        search,&#10;        specialization,&#10;        location,&#10;        limit,&#10;        page,&#10;      ),&#10;      getFarmersCount(&#10;        cachedFarmersCollection,&#10;        search,&#10;        specialization,&#10;        location,&#10;      ),&#10;    ]);&#10;&#10;    // Enhance farmers with product statistics if requested&#10;    const enhancedFarmers = includeStats&#10;      ? await enhanceFarmersWithStats(&#10;          cachedFarmersCollection,&#10;          cachedProductsCollection,&#10;          farmers,&#10;        )&#10;      : farmers.map((farmer) =&gt; ({&#10;          ...farmer,&#10;          profilePicture: farmer.profilePicture || farmer.profileImage,&#10;          bio: farmer.bio || farmer.description,&#10;          verified: farmer.verified || farmer.isCertified || false,&#10;        }));&#10;&#10;    const responseData = {&#10;      farmers: enhancedFarmers,&#10;      total: totalCount,&#10;      page,&#10;      totalPages: Math.ceil(totalCount / limit),&#10;      hasNextPage: page * limit &lt; totalCount,&#10;      hasPrevPage: page &gt; 1,&#10;    };&#10;&#10;    // Cache the response&#10;    setCachedResponse(cacheKey, responseData);&#10;&#10;    const response = NextResponse.json(responseData);&#10;    response.headers.set(&quot;X-Cache&quot;, &quot;MISS&quot;);&#10;    response.headers.set(&quot;Cache-Control&quot;, &quot;public, max-age=300&quot;);&#10;&#10;    return response;&#10;  } catch (error) {&#10;    console.error(&quot;Error fetching farmers:&quot;, error);&#10;    return NextResponse.json(&#10;      { error: &quot;Failed to fetch farmers&quot; },&#10;      { status: 500 },&#10;    );&#10;  }&#10;}&#10;&#10;// PUT method to update farmer profile&#10;export async function PUT(request) {&#10;  try {&#10;    // Get the session to verify user authentication&#10;    const session = await getServerSession(authOptions);&#10;&#10;    if (!session || !session.user) {&#10;      return NextResponse.json({ error: &quot;Unauthorized&quot; }, { status: 401 });&#10;    }&#10;&#10;    // Check if user is a farmer&#10;    if (session.user.userType !== &quot;farmer&quot;) {&#10;      return NextResponse.json(&#10;        { error: &quot;Access denied. Farmers only.&quot; },&#10;        { status: 403 },&#10;      );&#10;    }&#10;&#10;    const body = await request.json();&#10;    const client = await clientPromise;&#10;    const db = client.db(&quot;farmfresh&quot;);&#10;&#10;    // Find the farmer by email (session email)&#10;    const farmer = await db&#10;      .collection(&quot;farmers&quot;)&#10;      .findOne({ email: session.user.email });&#10;&#10;    if (!farmer) {&#10;      return NextResponse.json({ error: &quot;Farmer not found&quot; }, { status: 404 });&#10;    }&#10;&#10;    // Prepare update data - only include fields that can be updated&#10;    const updateData = {&#10;      updatedAt: new Date(),&#10;    };&#10;&#10;    // Update basic profile fields&#10;    if (body.name) updateData.name = body.name;&#10;    if (body.phone) updateData.phone = body.phone;&#10;&#10;    // Update farm information&#10;    if (body.farmInfo) {&#10;      updateData.farmInfo = {&#10;        ...farmer.farmInfo, // Keep existing farm info&#10;        ...body.farmInfo, // Override with new data&#10;      };&#10;    }&#10;&#10;    // Update address&#10;    if (body.address) {&#10;      updateData.address = {&#10;        ...farmer.address, // Keep existing address&#10;        ...body.address, // Override with new data&#10;      };&#10;&#10;      // IMPORTANT: Also update the location field for display compatibility&#10;      // Combine address fields into a location string for farmer page display&#10;      const addressParts = [];&#10;      if (body.address.street) addressParts.push(body.address.street);&#10;      if (body.address.city) addressParts.push(body.address.city);&#10;      if (body.address.state) addressParts.push(body.address.state);&#10;      if (body.address.country) addressParts.push(body.address.country);&#10;&#10;      // Update location field with formatted address string&#10;      if (addressParts.length &gt; 0) {&#10;        updateData.location = addressParts.join(&quot;, &quot;);&#10;      }&#10;    }&#10;&#10;    // Update business information&#10;    if (body.businessInfo) {&#10;      updateData.businessInfo = {&#10;        ...farmer.businessInfo, // Keep existing business info&#10;        ...body.businessInfo, // Override with new data&#10;      };&#10;    }&#10;&#10;    // Update preferences&#10;    if (body.preferences) {&#10;      updateData.preferences = {&#10;        ...farmer.preferences, // Keep existing preferences&#10;        ...body.preferences, // Override with new data&#10;      };&#10;    }&#10;&#10;    // Update farmer in database&#10;    const result = await db&#10;      .collection(&quot;farmers&quot;)&#10;      .updateOne({ _id: farmer._id }, { $set: updateData });&#10;&#10;    if (result.modifiedCount === 0) {&#10;      return NextResponse.json(&#10;        { error: &quot;No changes made to farmer profile&quot; },&#10;        { status: 400 },&#10;      );&#10;    }&#10;&#10;    if (body.name) {&#10;      try {&#10;        const productsUpdateResult = await db.collection(&quot;products&quot;).updateMany(&#10;          {&#10;            $or: [&#10;              { farmerId: farmer._id },&#10;              { farmerEmail: farmer.email },&#10;              { &quot;farmer._id&quot;: farmer._id },&#10;              { &quot;farmer.email&quot;: farmer.email },&#10;            ],&#10;          },&#10;          {&#10;            $set: {&#10;              &quot;farmer.name&quot;: body.name,&#10;              farmerName: body.name, // Update if this field exists&#10;              updatedAt: new Date(),&#10;            },&#10;          },&#10;        );&#10;      } catch (error) {&#10;        console.error(&quot;Error updating farmer name in products:&quot;, error);&#10;        // Don't fail the whole request if product update fails&#10;      }&#10;    }&#10;&#10;    // Fetch updated farmer data&#10;    const updatedFarmer = await db.collection(&quot;farmers&quot;).findOne(&#10;      { _id: farmer._id },&#10;      { projection: { password: 0 } }, // Exclude password&#10;    );&#10;&#10;    // CRITICAL: Clear server-side response cache to prevent serving stale farmer data&#10;    responseCache.clear();&#10;&#10;    return NextResponse.json(&#10;      {&#10;        success: true,&#10;        message: &quot;Farmer profile updated successfully&quot;,&#10;        farmer: updatedFarmer,&#10;      },&#10;      {&#10;        headers: {&#10;          &quot;Cache-Control&quot;:&#10;            &quot;no-store, no-cache, must-revalidate, proxy-revalidate&quot;,&#10;          Pragma: &quot;no-cache&quot;,&#10;          Expires: &quot;0&quot;,&#10;          &quot;Surrogate-Control&quot;: &quot;no-store&quot;,&#10;        },&#10;      },&#10;    );&#10;  } catch (error) {&#10;    console.error(&quot;Error updating farmer profile:&quot;, error);&#10;    return NextResponse.json(&#10;      {&#10;        error: &quot;Failed to update farmer profile&quot;,&#10;        details: error.message,&#10;      },&#10;      { status: 500 },&#10;    );&#10;  }&#10;}&#10;" />
              <option name="updatedContent" value="import { NextResponse } from &quot;next/server&quot;;&#10;import clientPromise from &quot;@/lib/mongodb&quot;;&#10;import { getServerSession } from &quot;next-auth/next&quot;;&#10;import { authOptions } from &quot;../auth/[...nextauth]/route&quot;;&#10;&#10;// Track if indexes have been initialized to avoid repeated calls&#10;let farmersIndexesInitialized = false;&#10;// Cache for database connection and collections&#10;let cachedDb = null;&#10;let cachedFarmersCollection = null;&#10;let cachedProductsCollection = null;&#10;&#10;// Response cache for identical requests (5 minutes)&#10;const responseCache = new Map();&#10;const CACHE_TTL = 5 * 60 * 1000;&#10;&#10;// Initialize indexes optimized for MongoDB Atlas performance&#10;async function initializeFarmersIndexes(db) {&#10;  if (farmersIndexesInitialized) {&#10;    return;&#10;  }&#10;&#10;  try {&#10;    const farmersCollection = db.collection(&quot;farmers&quot;);&#10;&#10;    // Check existing indexes&#10;    const existingIndexes = await farmersCollection.listIndexes().toArray();&#10;    const indexNames = existingIndexes.map((index) =&gt; index.name);&#10;&#10;    // Simplified indexes for direct farmers only&#10;    const indexesToCreate = [&#10;      // Text search index with proper weights&#10;      {&#10;        key: {&#10;          name: &quot;text&quot;,&#10;          description: &quot;text&quot;,&#10;          location: &quot;text&quot;,&#10;          farmName: &quot;text&quot;,&#10;          specializations: &quot;text&quot;,&#10;        },&#10;        name: &quot;farmers_text_search_idx&quot;,&#10;        options: {&#10;          background: true,&#10;          weights: {&#10;            name: 10,&#10;            farmName: 8,&#10;            location: 5,&#10;            specializations: 3,&#10;            description: 1,&#10;          },&#10;        },&#10;      },&#10;      // Location-based queries&#10;      {&#10;        key: { location: 1, verified: 1 },&#10;        name: &quot;location_verified_idx&quot;,&#10;        options: { background: true },&#10;      },&#10;      // Specialization queries&#10;      {&#10;        key: { specializations: 1, verified: 1 },&#10;        name: &quot;specializations_verified_idx&quot;,&#10;        options: { background: true },&#10;      },&#10;      // Verified/certification status&#10;      {&#10;        key: { verified: 1, isCertified: 1, createdAt: -1 },&#10;        name: &quot;status_created_idx&quot;,&#10;        options: { background: true },&#10;      },&#10;    ];&#10;&#10;    for (const indexSpec of indexesToCreate) {&#10;      if (!indexNames.includes(indexSpec.name)) {&#10;        await farmersCollection.createIndex(indexSpec.key, {&#10;          name: indexSpec.name,&#10;          ...indexSpec.options,&#10;        });&#10;      }&#10;    }&#10;&#10;    farmersIndexesInitialized = true;&#10;    console.log(&quot;Simplified farmers indexes initialized successfully&quot;);&#10;  } catch (error) {&#10;    console.log(&quot;Farmers index initialization note:&quot;, error.message);&#10;  }&#10;}&#10;&#10;// Generate cache key for request&#10;function generateCacheKey(searchParams) {&#10;  const params = {};&#10;  searchParams.forEach((value, key) =&gt; {&#10;    params[key] = value;&#10;  });&#10;  return JSON.stringify(params);&#10;}&#10;&#10;// Get cached response if available and not expired&#10;function getCachedResponse(cacheKey) {&#10;  const cached = responseCache.get(cacheKey);&#10;  if (cached &amp;&amp; Date.now() - cached.timestamp &lt; CACHE_TTL) {&#10;    return cached.data;&#10;  }&#10;  responseCache.delete(cacheKey);&#10;  return null;&#10;}&#10;&#10;// Set response in cache&#10;function setCachedResponse(cacheKey, data) {&#10;  responseCache.set(cacheKey, {&#10;    data,&#10;    timestamp: Date.now(),&#10;  });&#10;&#10;  // Clear cache if it gets too large&#10;  if (responseCache.size &gt; 100) {&#10;    const now = Date.now();&#10;    for (const [key, value] of responseCache.entries()) {&#10;      if (now - value.timestamp &gt;= CACHE_TTL) {&#10;        responseCache.delete(key);&#10;      }&#10;    }&#10;  }&#10;}&#10;&#10;// Enhanced farmer data with product statistics&#10;async function enhanceFarmersWithStats(&#10;  farmersCollection,&#10;  productsCollection,&#10;  farmers,&#10;) {&#10;  if (farmers.length === 0) return farmers;&#10;&#10;  // Get all farmer IDs and names for batch processing&#10;  const farmerIds = farmers.map((f) =&gt; f._id).filter(Boolean);&#10;  const farmerNames = farmers.map((f) =&gt; f.name).filter(Boolean);&#10;  const farmerEmails = farmers.map((f) =&gt; f.email).filter(Boolean);&#10;&#10;  // Calculate statistics for all farmers in a single aggregation&#10;  const statsAggregation = [&#10;    {&#10;      $match: {&#10;        $or: [&#10;          { farmerId: { $in: farmerIds } },&#10;          { &quot;farmer._id&quot;: { $in: farmerIds } },&#10;          { &quot;farmer.name&quot;: { $in: farmerNames } },&#10;          { farmerEmail: { $in: farmerEmails } },&#10;        ],&#10;      },&#10;    },&#10;    {&#10;      $group: {&#10;        _id: {&#10;          $cond: [&#10;            { $ne: [&quot;$farmerId&quot;, null] },&#10;            &quot;$farmerId&quot;,&#10;            {&#10;              $cond: [&#10;                { $ne: [&quot;$farmer._id&quot;, null] },&#10;                &quot;$farmer._id&quot;,&#10;                {&#10;                  $cond: [&#10;                    { $ne: [&quot;$farmer.name&quot;, null] },&#10;                    &quot;$farmer.name&quot;,&#10;                    &quot;$farmerEmail&quot;,&#10;                  ],&#10;                },&#10;              ],&#10;            },&#10;          ],&#10;        },&#10;        totalProducts: { $sum: 1 },&#10;        activeProducts: {&#10;          $sum: { $cond: [{ $gt: [&quot;$stock&quot;, 0] }, 1, 0] },&#10;        },&#10;        averageRating: { $avg: &quot;$averageRating&quot; },&#10;        totalSales: { $sum: &quot;$purchaseCount&quot; },&#10;        featuredProducts: {&#10;          $sum: { $cond: [&quot;$featured&quot;, 1, 0] },&#10;        },&#10;      },&#10;    },&#10;  ];&#10;&#10;  const statsResults = await productsCollection&#10;    .aggregate(statsAggregation)&#10;    .toArray();&#10;&#10;  // Create a lookup map for quick stats access&#10;  const statsMap = new Map();&#10;  statsResults.forEach((stat) =&gt; {&#10;    statsMap.set(stat._id, {&#10;      totalProducts: stat.totalProducts || 0,&#10;      activeProducts: stat.activeProducts || 0,&#10;      averageRating: Math.round((stat.averageRating || 0) * 10) / 10,&#10;      totalSales: stat.totalSales || 0,&#10;      featuredProducts: stat.featuredProducts || 0,&#10;    });&#10;  });&#10;&#10;  // Enhance farmers with their statistics&#10;  return farmers.map((farmer) =&gt; {&#10;    const stats = statsMap.get(farmer._id) ||&#10;      statsMap.get(farmer.name) ||&#10;      statsMap.get(farmer.email) || {&#10;        totalProducts: 0,&#10;        activeProducts: 0,&#10;        averageRating: 0,&#10;        totalSales: 0,&#10;        featuredProducts: 0,&#10;      };&#10;&#10;    return {&#10;      ...farmer,&#10;      // Normalize field names&#10;      profilePicture: farmer.profilePicture || farmer.profileImage,&#10;      bio: farmer.bio || farmer.description,&#10;      verified: farmer.verified || farmer.isCertified || false,&#10;      stats,&#10;    };&#10;  });&#10;}&#10;&#10;// Simplified farmers query - only direct farmers&#10;async function getFarmersOptimized(&#10;  farmersCollection,&#10;  search,&#10;  specialization,&#10;  location,&#10;  limit,&#10;  page,&#10;) {&#10;  // Build match filter for direct farmers only&#10;  const matchFilter = {&#10;    // Only get documents that are direct farmers (have name and location fields)&#10;    name: { $exists: true, $ne: null },&#10;    location: { $exists: true, $ne: null },&#10;  };&#10;&#10;  // Add search filter&#10;  if (search) {&#10;    matchFilter.$text = { $search: search };&#10;  }&#10;&#10;  // Add specialization filter&#10;  if (specialization) {&#10;    matchFilter.specializations = {&#10;      $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;    };&#10;  }&#10;&#10;  // Add location filter&#10;  if (location) {&#10;    matchFilter.location = { $regex: location, $options: &quot;i&quot; };&#10;  }&#10;&#10;  // Build aggregation pipeline&#10;  const pipeline = [&#10;    { $match: matchFilter },&#10;    // Sort by verification status, then name&#10;    { $sort: { verified: -1, isCertified: -1, name: 1 } },&#10;  ];&#10;&#10;  // Add pagination&#10;  if (limit) {&#10;    const skip = (page - 1) * limit;&#10;    pipeline.push({ $skip: skip });&#10;    pipeline.push({ $limit: limit });&#10;  }&#10;&#10;  return await farmersCollection.aggregate(pipeline).toArray();&#10;}&#10;&#10;// Get total count for pagination - simplified for direct farmers only&#10;async function getFarmersCount(&#10;  farmersCollection,&#10;  search,&#10;  specialization,&#10;  location,&#10;) {&#10;  // Build match filter for direct farmers only&#10;  const matchFilter = {&#10;    name: { $exists: true, $ne: null },&#10;    location: { $exists: true, $ne: null },&#10;  };&#10;&#10;  // Add search filter&#10;  if (search) {&#10;    matchFilter.$text = { $search: search };&#10;  }&#10;&#10;  // Add specialization filter&#10;  if (specialization) {&#10;    matchFilter.specializations = {&#10;      $elemMatch: { $regex: specialization, $options: &quot;i&quot; },&#10;    };&#10;  }&#10;&#10;  // Add location filter&#10;  if (location) {&#10;    matchFilter.location = { $regex: location, $options: &quot;i&quot; };&#10;  }&#10;&#10;  return await farmersCollection.countDocuments(matchFilter);&#10;}&#10;&#10;export async function GET(request) {&#10;  try {&#10;    const { searchParams } = new URL(request.url);&#10;&#10;    // Check cache first&#10;    const cacheKey = generateCacheKey(searchParams);&#10;    const cachedResponse = getCachedResponse(cacheKey);&#10;    if (cachedResponse) {&#10;      const response = NextResponse.json(cachedResponse);&#10;      response.headers.set(&quot;X-Cache&quot;, &quot;HIT&quot;);&#10;      response.headers.set(&quot;Cache-Control&quot;, &quot;public, max-age=300&quot;);&#10;      return response;&#10;    }&#10;&#10;    const search = searchParams.get(&quot;search&quot;);&#10;    const specialization = searchParams.get(&quot;specialization&quot;);&#10;    const location = searchParams.get(&quot;location&quot;);&#10;    const limit = searchParams.get(&quot;limit&quot;)&#10;      ? parseInt(searchParams.get(&quot;limit&quot;))&#10;      : 50;&#10;    const page = parseInt(searchParams.get(&quot;page&quot;)) || 1;&#10;    const includeStats = searchParams.get(&quot;includeStats&quot;) !== &quot;false&quot;;&#10;&#10;    // Reuse database connections&#10;    if (!cachedDb) {&#10;      const client = await clientPromise;&#10;      cachedDb = client.db(&quot;farmfresh&quot;);&#10;      cachedFarmersCollection = cachedDb.collection(&quot;farmers&quot;);&#10;      cachedProductsCollection = cachedDb.collection(&quot;products&quot;);&#10;    }&#10;&#10;    // Initialize indexes only once&#10;    await initializeFarmersIndexes(cachedDb);&#10;&#10;    // Get farmers using simplified query&#10;    const [farmers, totalCount] = await Promise.all([&#10;      getFarmersOptimized(&#10;        cachedFarmersCollection,&#10;        search,&#10;        specialization,&#10;        location,&#10;        limit,&#10;        page,&#10;      ),&#10;      getFarmersCount(&#10;        cachedFarmersCollection,&#10;        search,&#10;        specialization,&#10;        location,&#10;      ),&#10;    ]);&#10;&#10;    // Enhance with stats if requested&#10;    const enhancedFarmers = includeStats&#10;      ? await enhanceFarmersWithStats(&#10;          cachedFarmersCollection,&#10;          cachedProductsCollection,&#10;          farmers,&#10;        )&#10;      : farmers.map((farmer) =&gt; ({&#10;          ...farmer,&#10;          profilePicture: farmer.profilePicture || farmer.profileImage,&#10;          bio: farmer.bio || farmer.description,&#10;          verified: farmer.verified || farmer.isCertified || false,&#10;          stats: {&#10;            totalProducts: 0,&#10;            activeProducts: 0,&#10;            averageRating: 0,&#10;            totalSales: 0,&#10;            featuredProducts: 0,&#10;          },&#10;        }));&#10;&#10;    const responseData = {&#10;      farmers: enhancedFarmers,&#10;      pagination: {&#10;        total: totalCount,&#10;        page,&#10;        limit,&#10;        totalPages: Math.ceil(totalCount / limit),&#10;        hasNext: page &lt; Math.ceil(totalCount / limit),&#10;        hasPrev: page &gt; 1,&#10;      },&#10;      filters: {&#10;        search: search || &quot;&quot;,&#10;        specialization: specialization || &quot;&quot;,&#10;        location: location || &quot;&quot;,&#10;      },&#10;    };&#10;&#10;    // Cache the response&#10;    setCachedResponse(cacheKey, responseData);&#10;&#10;    const response = NextResponse.json(responseData);&#10;    response.headers.set(&quot;X-Cache&quot;, &quot;MISS&quot;);&#10;    response.headers.set(&quot;Cache-Control&quot;, &quot;public, max-age=300&quot;);&#10;    return response;&#10;  } catch (error) {&#10;    console.error(&quot;Error in farmers API:&quot;, error);&#10;    return NextResponse.json(&#10;      { error: &quot;Failed to fetch farmers&quot; },&#10;      { status: 500 },&#10;    );&#10;  }&#10;}&#10;&#10;// PUT method to update farmer profile&#10;export async function PUT(request) {&#10;  try {&#10;    // Get the session to verify user authentication&#10;    const session = await getServerSession(authOptions);&#10;&#10;    if (!session || !session.user) {&#10;      return NextResponse.json({ error: &quot;Unauthorized&quot; }, { status: 401 });&#10;    }&#10;&#10;    // Check if user is a farmer&#10;    if (session.user.userType !== &quot;farmer&quot;) {&#10;      return NextResponse.json(&#10;        { error: &quot;Access denied. Farmers only.&quot; },&#10;        { status: 403 },&#10;      );&#10;    }&#10;&#10;    const body = await request.json();&#10;    const client = await clientPromise;&#10;    const db = client.db(&quot;farmfresh&quot;);&#10;&#10;    // Find the farmer by email (session email)&#10;    const farmer = await db&#10;      .collection(&quot;farmers&quot;)&#10;      .findOne({ email: session.user.email });&#10;&#10;    if (!farmer) {&#10;      return NextResponse.json({ error: &quot;Farmer not found&quot; }, { status: 404 });&#10;    }&#10;&#10;    // Prepare update data - only include fields that can be updated&#10;    const updateData = {&#10;      updatedAt: new Date(),&#10;    };&#10;&#10;    // Update basic profile fields&#10;    if (body.name) updateData.name = body.name;&#10;    if (body.phone) updateData.phone = body.phone;&#10;&#10;    // Update farm information&#10;    if (body.farmInfo) {&#10;      updateData.farmInfo = {&#10;        ...farmer.farmInfo, // Keep existing farm info&#10;        ...body.farmInfo, // Override with new data&#10;      };&#10;    }&#10;&#10;    // Update address&#10;    if (body.address) {&#10;      updateData.address = {&#10;        ...farmer.address, // Keep existing address&#10;        ...body.address, // Override with new data&#10;      };&#10;&#10;      // IMPORTANT: Also update the location field for display compatibility&#10;      // Combine address fields into a location string for farmer page display&#10;      const addressParts = [];&#10;      if (body.address.street) addressParts.push(body.address.street);&#10;      if (body.address.city) addressParts.push(body.address.city);&#10;      if (body.address.state) addressParts.push(body.address.state);&#10;      if (body.address.country) addressParts.push(body.address.country);&#10;&#10;      // Update location field with formatted address string&#10;      if (addressParts.length &gt; 0) {&#10;        updateData.location = addressParts.join(&quot;, &quot;);&#10;      }&#10;    }&#10;&#10;    // Update business information&#10;    if (body.businessInfo) {&#10;      updateData.businessInfo = {&#10;        ...farmer.businessInfo, // Keep existing business info&#10;        ...body.businessInfo, // Override with new data&#10;      };&#10;    }&#10;&#10;    // Update preferences&#10;    if (body.preferences) {&#10;      updateData.preferences = {&#10;        ...farmer.preferences, // Keep existing preferences&#10;        ...body.preferences, // Override with new data&#10;      };&#10;    }&#10;&#10;    // Update farmer in database&#10;    const result = await db&#10;      .collection(&quot;farmers&quot;)&#10;      .updateOne({ _id: farmer._id }, { $set: updateData });&#10;&#10;    if (result.modifiedCount === 0) {&#10;      return NextResponse.json(&#10;        { error: &quot;No changes made to farmer profile&quot; },&#10;        { status: 400 },&#10;      );&#10;    }&#10;&#10;    if (body.name) {&#10;      try {&#10;        await db.collection(&quot;products&quot;).updateMany(&#10;          {&#10;            $or: [&#10;              { farmerId: farmer._id },&#10;              { farmerEmail: farmer.email },&#10;              { &quot;farmer._id&quot;: farmer._id },&#10;              { &quot;farmer.email&quot;: farmer.email },&#10;            ],&#10;          },&#10;          {&#10;            $set: {&#10;              &quot;farmer.name&quot;: body.name,&#10;              farmerName: body.name, // Update if this field exists&#10;              updatedAt: new Date(),&#10;            },&#10;          },&#10;        );&#10;      } catch (error) {&#10;        console.error(&quot;Error updating farmer name in products:&quot;, error);&#10;        // Don't fail the whole request if product update fails&#10;      }&#10;    }&#10;&#10;    // Fetch updated farmer data&#10;    const updatedFarmer = await db.collection(&quot;farmers&quot;).findOne(&#10;      { _id: farmer._id },&#10;      { projection: { password: 0 } }, // Exclude password&#10;    );&#10;&#10;    // CRITICAL: Clear server-side response cache to prevent serving stale farmer data&#10;    responseCache.clear();&#10;&#10;    return NextResponse.json(&#10;      {&#10;        success: true,&#10;        message: &quot;Farmer profile updated successfully&quot;,&#10;        farmer: updatedFarmer,&#10;      },&#10;      {&#10;        headers: {&#10;          &quot;Cache-Control&quot;:&#10;            &quot;no-store, no-cache, must-revalidate, proxy-revalidate&quot;,&#10;          Pragma: &quot;no-cache&quot;,&#10;          Expires: &quot;0&quot;,&#10;          &quot;Surrogate-Control&quot;: &quot;no-store&quot;,&#10;        },&#10;      },&#10;    );&#10;  } catch (error) {&#10;    console.error(&quot;Error updating farmer profile:&quot;, error);&#10;    return NextResponse.json(&#10;      {&#10;        error: &quot;Failed to update farmer profile&quot;,&#10;        details: error.message,&#10;      },&#10;      { status: 500 },&#10;    );&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/api/messages/[conversationId]/read/route.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/api/messages/[conversationId]/read/route.js" />
              <option name="originalContent" value="import { NextResponse } from &quot;next/server&quot;;&#10;import clientPromise from &quot;@/lib/mongodb&quot;;&#10;import { ObjectId } from &quot;mongodb&quot;;&#10;import { getServerSession } from &quot;next-auth/next&quot;;&#10;import { authOptions } from &quot;../../auth/[...nextauth]/route&quot;;&#10;&#10;export async function PUT(request, { params }) {&#10;  try {&#10;    const session = await getServerSession(authOptions);&#10;    if (!session) {&#10;      return NextResponse.json({ error: &quot;Unauthorized&quot; }, { status: 401 });&#10;    }&#10;&#10;    const conversationId = params.conversationId;&#10;        receiverId: new ObjectId(userId),&#10;        isRead: false,&#10;      },&#10;      {&#10;        $set: {&#10;          isRead: true,&#10;          readAt: new Date(),&#10;        },&#10;      },&#10;    );&#10;&#10;    return NextResponse.json({&#10;      success: true,&#10;      markedAsRead: result.modifiedCount,&#10;    });&#10;  } catch (error) {&#10;    console.error(&quot;❌ Error marking conversation as read:&quot;, error);&#10;    return NextResponse.json(&#10;      { error: &quot;Internal server error&quot; },&#10;      { status: 500 },&#10;    );&#10;  }&#10;}&#10;" />
              <option name="updatedContent" value="import { NextResponse } from &quot;next/server&quot;;&#10;import clientPromise from &quot;@/lib/mongodb&quot;;&#10;import { ObjectId } from &quot;mongodb&quot;;&#10;import { getServerSession } from &quot;next-auth/next&quot;;&#10;import { authOptions } from &quot;../../../auth/[...nextauth]/route&quot;;&#10;&#10;export async function PUT(request, { params }) {&#10;  try {&#10;    const session = await getServerSession(authOptions);&#10;    if (!session) {&#10;      return NextResponse.json({ error: &quot;Unauthorized&quot; }, { status: 401 });&#10;    }&#10;&#10;    // Await params before using its properties&#10;    const { conversationId } = await params;&#10;    if (!conversationId) {&#10;      return NextResponse.json(&#10;        { error: &quot;Conversation ID required&quot; },&#10;        { status: 400 },&#10;      );&#10;    }&#10;&#10;    // Enhanced user ID detection&#10;    const currentUser = session.user;&#10;    const userId =&#10;      currentUser?.id ||&#10;      currentUser?._id ||&#10;      currentUser?.userId ||&#10;      currentUser?.sub ||&#10;      currentUser?.email;&#10;&#10;    if (!userId) {&#10;      console.error(&quot;❌ No user ID found for marking conversation as read&quot;);&#10;      return NextResponse.json(&#10;        { error: &quot;Invalid user session&quot; },&#10;        { status: 400 },&#10;      );&#10;    }&#10;&#10;    const client = await clientPromise;&#10;    const db = client.db(&quot;farm-fresh&quot;);&#10;&#10;    // Mark all messages in this conversation as read for the current user&#10;    const result = await db.collection(&quot;messages&quot;).updateMany(&#10;      {&#10;        conversationId: new ObjectId(conversationId),&#10;        receiverId: new ObjectId(userId),&#10;        isRead: false,&#10;      },&#10;      {&#10;        $set: {&#10;          isRead: true,&#10;          readAt: new Date(),&#10;        },&#10;      },&#10;    );&#10;&#10;    return NextResponse.json({&#10;      success: true,&#10;      markedAsRead: result.modifiedCount,&#10;    });&#10;  } catch (error) {&#10;    console.error(&quot;❌ Error marking conversation as read:&quot;, error);&#10;    return NextResponse.json(&#10;      { error: &quot;Internal server error&quot; },&#10;      { status: 500 },&#10;    );&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/api/products/route.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/api/products/route.js" />
              <option name="originalContent" value="import { NextResponse } from &quot;next/server&quot;;&#10;import clientPromise from &quot;@/lib/mongodb&quot;;&#10;import { ObjectId } from &quot;mongodb&quot;;&#10;import { enhanceProductsWithRatings } from &quot;@/lib/reviewUtils&quot;;&#10;&#10;// Track if indexes have been initialized to avoid repeated calls&#10;let productIndexesInitialized = false;&#10;// Cache for database connection and collections&#10;let cachedDb = null;&#10;let cachedCollection = null;&#10;&#10;// Response cache for identical requests (5 minutes)&#10;const responseCache = new Map();&#10;const CACHE_TTL = 5 * 60 * 1000;&#10;&#10;// Export the response cache for access by bulk-update route&#10;export { responseCache };&#10;&#10;// Function to clear cache when reviews are updated&#10;export function clearProductsCache() {&#10;  responseCache.clear();&#10;}&#10;&#10;// Enhanced cache clearing function for purchase count updates&#10;export function clearAllProductsCaches() {&#10;  responseCache.clear();&#10;  // Also clear any session cache&#10;  if (typeof window !== &quot;undefined&quot;) {&#10;    try {&#10;      sessionStorage.removeItem(&quot;products-cache&quot;);&#10;      sessionStorage.removeItem(&quot;farmfresh-products&quot;);&#10;    } catch (error) {}&#10;  }&#10;}&#10;&#10;// Initialize indexes optimized for MongoDB Atlas performance&#10;async function initializeProductIndexes(db) {&#10;  // Only initialize once per application lifecycle&#10;  if (productIndexesInitialized) {&#10;    return;&#10;  }&#10;&#10;  try {&#10;    const collection = db.collection(&quot;products&quot;);&#10;&#10;    // Check if indexes already exist before creating them&#10;    const existingIndexes = await collection.listIndexes().toArray();&#10;    const indexNames = existingIndexes.map((index) =&gt; index.name);&#10;&#10;    // Simplified Atlas-optimized compound indexes for better performance&#10;    const indexesToCreate = [&#10;      // Primary query index - most common pattern&#10;      {&#10;        key: { status: 1, category: 1, createdAt: -1 },&#10;        name: &quot;primary_query_idx&quot;,&#10;        options: { background: true },&#10;      },&#10;      // Search index&#10;      {&#10;        key: { name: &quot;text&quot;, description: &quot;text&quot;, category: &quot;text&quot; },&#10;        name: &quot;products_text_search_idx&quot;,&#10;        options: {&#10;          background: true,&#10;          weights: { name: 10, category: 5, description: 1 },&#10;        },&#10;      },&#10;      // Price and rating filters&#10;      {&#10;        key: { status: 1, price: 1, averageRating: -1 },&#10;        name: &quot;price_rating_idx&quot;,&#10;        options: { background: true },&#10;      },&#10;      // Farmer queries&#10;      {&#10;        key: { &quot;farmer._id&quot;: 1, status: 1 },&#10;        name: &quot;farmer_status_idx&quot;,&#10;        options: { background: true },&#10;      },&#10;    ];&#10;&#10;    for (const indexSpec of indexesToCreate) {&#10;      if (!indexNames.includes(indexSpec.name)) {&#10;        await collection.createIndex(indexSpec.key, {&#10;          name: indexSpec.name,&#10;          ...indexSpec.options,&#10;        });&#10;      }&#10;    }&#10;&#10;    productIndexesInitialized = true;&#10;  } catch (error) {}&#10;}&#10;&#10;// Generate cache key for request&#10;function generateCacheKey(searchParams) {&#10;  const params = {};&#10;  searchParams.forEach((value, key) =&gt; {&#10;    params[key] = value;&#10;  });&#10;  return JSON.stringify(params);&#10;}&#10;&#10;// Get cached response if available and not expired&#10;function getCachedResponse(cacheKey) {&#10;  const cached = responseCache.get(cacheKey);&#10;  if (cached &amp;&amp; Date.now() - cached.timestamp &lt; CACHE_TTL) {&#10;    return cached.data;&#10;  }&#10;  responseCache.delete(cacheKey);&#10;  return null;&#10;}&#10;&#10;// Set response in cache&#10;function setCachedResponse(cacheKey, data) {&#10;  responseCache.set(cacheKey, {&#10;    data,&#10;    timestamp: Date.now(),&#10;  });&#10;&#10;  // Clear cache if it gets too large to prevent memory issues&#10;  if (responseCache.size &gt; 50) {&#10;    const now = Date.now();&#10;    for (const [key, value] of responseCache.entries()) {&#10;      if (now - value.timestamp &gt;= CACHE_TTL) {&#10;        responseCache.delete(key);&#10;      }&#10;    }&#10;  }&#10;}&#10;&#10;export async function GET(request) {&#10;  try {&#10;    const { searchParams } = new URL(request.url);&#10;&#10;    // Check cache first&#10;    const cacheKey = generateCacheKey(searchParams);&#10;    const cachedResponse = getCachedResponse(cacheKey);&#10;    if (cachedResponse) {&#10;      const response = NextResponse.json(cachedResponse);&#10;      // Add cache headers to indicate this is cached data&#10;      response.headers.set(&quot;X-Cache&quot;, &quot;HIT&quot;);&#10;      response.headers.set(&quot;Cache-Control&quot;, &quot;public, max-age=300&quot;); // 5 minutes&#10;      return response;&#10;    }&#10;&#10;    const search = searchParams.get(&quot;search&quot;);&#10;    const category = searchParams.get(&quot;category&quot;);&#10;    const featured = searchParams.get(&quot;featured&quot;);&#10;    const sortBy = searchParams.get(&quot;sortBy&quot;);&#10;    const farmerId = searchParams.get(&quot;farmerId&quot;);&#10;    const farmerEmail = searchParams.get(&quot;farmerEmail&quot;);&#10;    const limit = parseInt(searchParams.get(&quot;limit&quot;)) || 50;&#10;    const page = parseInt(searchParams.get(&quot;page&quot;)) || 1;&#10;    const skip = (page - 1) * limit;&#10;&#10;    // Simplified filtering parameters&#10;    const minPrice = searchParams.get(&quot;minPrice&quot;)&#10;      ? parseFloat(searchParams.get(&quot;minPrice&quot;))&#10;      : null;&#10;    const maxPrice = searchParams.get(&quot;maxPrice&quot;)&#10;      ? parseFloat(searchParams.get(&quot;maxPrice&quot;))&#10;      : null;&#10;    const minRating = searchParams.get(&quot;minRating&quot;)&#10;      ? parseFloat(searchParams.get(&quot;minRating&quot;))&#10;      : null;&#10;&#10;    // Reuse database connection and collection&#10;    if (!cachedDb) {&#10;      const client = await clientPromise;&#10;      cachedDb = client.db(&quot;farmfresh&quot;);&#10;      cachedCollection = cachedDb.collection(&quot;products&quot;);&#10;    }&#10;&#10;    // Initialize indexes only once&#10;    await initializeProductIndexes(cachedDb);&#10;&#10;    // Build query - BACK TO ORIGINAL WORKING VERSION&#10;    const query = { status: { $ne: &quot;deleted&quot; } };&#10;&#10;    // Check if this is a dashboard context request&#10;    const isDashboardContext = searchParams.get(&quot;dashboard&quot;) === &quot;true&quot;;&#10;&#10;    // For public access (non-farmer requests), exclude inactive products&#10;    if (!farmerId &amp;&amp; !farmerEmail &amp;&amp; !isDashboardContext) {&#10;      query.status = { $nin: [&quot;deleted&quot;, &quot;inactive&quot;] };&#10;    }&#10;&#10;    // Add search filter&#10;    if (search) {&#10;      query.$text = { $search: search };&#10;    }&#10;&#10;    // Add category filter&#10;    if (category &amp;&amp; category !== &quot;All Categories&quot;) {&#10;      query.category = { $regex: new RegExp(category, &quot;i&quot;) };&#10;    }&#10;&#10;    // Add featured filter&#10;    if (featured === &quot;true&quot;) {&#10;      query.featured = true;&#10;    }&#10;&#10;    // Add farmer filters for dashboard&#10;    if (farmerId || farmerEmail) {&#10;      query.$or = [];&#10;      if (farmerId) {&#10;            });&#10;            if (farmersDoc &amp;&amp; farmersDoc.farmers) {&#10;              farmer = farmersDoc.farmers.find((f) =&gt; f._id === farmerId);&#10;            }&#10;          }&#10;          let farmer = null;&#10;&#10;          if (farmerId.match(/^[0-9a-fA-F]{24}$/)) {&#10;            farmer = await farmersCollection.findOne({&#10;              _id: new ObjectId(farmerId),&#10;            });&#10;          } else {&#10;            const farmersDoc = await farmersCollection.findOne({&#10;              &quot;farmers._id&quot;: farmerId,&#10;            });&#10;            if (farmersDoc &amp;&amp; farmersDoc.farmers) {&#10;              farmer = farmersDoc.farmers.find((f) =&gt; f._id === farmerId);&#10;            }&#10;          }&#10;            farmerFarmName = farmer.farmName;&#10;          }&#10;        } catch (error) {&#10;          console.log(&quot;Could not fetch farmer for name-based matching:&quot;, error);&#10;        }&#10;&#10;        query.$or.push(&#10;          { farmerId: farmerId },&#10;          { farmerId: { $eq: farmerId } },&#10;          { &quot;farmer.id&quot;: farmerId },&#10;          { &quot;farmer._id&quot;: farmerId },&#10;        );&#10;&#10;        if (farmerName) {&#10;          query.$or.push(&#10;            { &quot;farmer.name&quot;: farmerName },&#10;            { &quot;farmer.name&quot;: { $regex: new RegExp(`^${farmerName}$`, &quot;i&quot;) } },&#10;          );&#10;        }&#10;        if (farmerFarmName) {&#10;      if (farmerEmail) {&#10;        query.$or.push(&#10;          { farmerEmail: farmerEmail },&#10;          { &quot;farmer.email&quot;: farmerEmail },&#10;        );&#10;&#10;    // Add price range filter&#10;    if (minPrice !== null || maxPrice !== null) {&#10;      query.price = {};&#10;      if (minPrice !== null) query.price.$gte = minPrice;&#10;      if (maxPrice !== null) query.price.$lte = maxPrice;&#10;    }&#10;&#10;    // Add rating filter&#10;    if (minRating !== null) {&#10;      query.averageRating = { $gte: minRating };&#10;    }&#10;&#10;    // BACK TO ORIGINAL WORKING SORT&#10;    let sortOptions = {};&#10;    if (search) {&#10;      sortOptions = { score: { $meta: &quot;textScore&quot; }, createdAt: -1 };&#10;    } else {&#10;      switch (sortBy) {&#10;        case &quot;price-low&quot;:&#10;          sortOptions = { price: 1 };&#10;      if (farmerEmail) {&#10;        query.$or.push(&#10;          { farmerEmail: farmerEmail },&#10;          { &quot;farmer.email&quot;: farmerEmail },&#10;        );&#10;      }&#10;          break;&#10;        case &quot;price-high&quot;:&#10;          sortOptions = { price: -1 };&#10;          break;&#10;        case &quot;rating&quot;:&#10;          sortOptions = { averageRating: -1, totalReviews: -1 };&#10;          break;&#10;        case &quot;popular&quot;:&#10;          sortOptions = { purchaseCount: -1, averageRating: -1 };&#10;          break;&#10;        case &quot;oldest&quot;:&#10;          sortOptions = { createdAt: 1 };&#10;          break;&#10;        case &quot;newest&quot;:&#10;        default:&#10;          sortOptions = { createdAt: -1 };&#10;          break;&#10;      }&#10;    }&#10;&#10;    // BACK TO ORIGINAL WORKING QUERY EXECUTION&#10;    const startTime = Date.now();&#10;&#10;    // Execute query with original method&#10;    const [products, totalCount] = await Promise.all([&#10;      cachedCollection&#10;        .find(query)&#10;        .sort(sortOptions)&#10;        .skip(skip)&#10;        .limit(limit)&#10;        .toArray(),&#10;      cachedCollection.countDocuments(query),&#10;    ]);&#10;&#10;    const queryTime = Date.now() - startTime;&#10;    console.log(&#10;      `Query executed in ${queryTime}ms for ${products.length} products, total: ${totalCount}`,&#10;    );&#10;&#10;    // Enhance with ratings&#10;    const enhancedProducts = await enhanceProductsWithRatings(&#10;      products,&#10;      cachedDb,&#10;    );&#10;&#10;    // Prepare response data&#10;    const responseData = {&#10;      products: enhancedProducts,&#10;      pagination: {&#10;        page,&#10;        limit,&#10;        total: totalCount,&#10;        totalPages: Math.ceil(totalCount / limit),&#10;        hasNext: page * limit &lt; totalCount,&#10;        hasPrev: page &gt; 1,&#10;      },&#10;      meta: {&#10;        query: {&#10;          search,&#10;          category,&#10;          featured,&#10;          sortBy,&#10;          minPrice,&#10;          maxPrice,&#10;          minRating,&#10;        },&#10;        performance: {&#10;          queryTime,&#10;          cached: false,&#10;        },&#10;        timestamp: new Date().toISOString(),&#10;      },&#10;    };&#10;&#10;    // Cache the response&#10;    setCachedResponse(cacheKey, responseData);&#10;&#10;    const response = NextResponse.json(responseData);&#10;    // Add cache headers&#10;    response.headers.set(&quot;X-Cache&quot;, &quot;MISS&quot;);&#10;    response.headers.set(&quot;Cache-Control&quot;, &quot;public, max-age=300&quot;); // 5 minutes&#10;    response.headers.set(&quot;X-Generated-At&quot;, new Date().toISOString());&#10;&#10;    return response;&#10;  } catch (error) {&#10;    console.error(&quot;Error fetching products:&quot;, error);&#10;    return NextResponse.json(&#10;      {&#10;        error: &quot;Failed to fetch products&quot;,&#10;        message: error.message,&#10;        products: [],&#10;        pagination: {&#10;          page: 1,&#10;          limit: 12,&#10;          total: 0,&#10;          totalPages: 0,&#10;          hasNext: false,&#10;          hasPrev: false,&#10;        },&#10;        timestamp: new Date().toISOString(),&#10;      },&#10;      { status: 500 },&#10;    );&#10;  }&#10;}&#10;&#10;export async function POST(request) {&#10;  try {&#10;    const body = await request.json();&#10;    const client = await clientPromise;&#10;    const db = client.db(&quot;farmfresh&quot;);&#10;&#10;    // Initialize indexes for the first POST operation&#10;    await initializeProductIndexes(db);&#10;&#10;    const result = await db.collection(&quot;products&quot;).insertOne({&#10;      ...body,&#10;      // Don't overwrite createdAt if it's already provided, but ensure it's a Date object&#10;      createdAt: body.createdAt ? new Date(body.createdAt) : new Date(),&#10;      updatedAt: new Date(),&#10;      status: &quot;active&quot;,&#10;      averageRating: 0,&#10;      totalReviews: 0,&#10;      reviewCount: 0,&#10;      purchaseCount: 0,&#10;    });&#10;&#10;    return NextResponse.json({&#10;      success: true,&#10;      productId: result.insertedId,&#10;    });&#10;  } catch (error) {&#10;    console.error(&quot;Error creating product:&quot;, error);&#10;    return NextResponse.json(&#10;      { error: &quot;Failed to create product&quot;, message: error.message },&#10;      { status: 500 },&#10;    );&#10;  }&#10;}&#10;" />
              <option name="updatedContent" value="import { NextResponse } from &quot;next/server&quot;;&#10;import clientPromise from &quot;@/lib/mongodb&quot;;&#10;import { ObjectId } from &quot;mongodb&quot;;&#10;import { enhanceProductsWithRatings } from &quot;@/lib/reviewUtils&quot;;&#10;&#10;// Track if indexes have been initialized to avoid repeated calls&#10;let productIndexesInitialized = false;&#10;// Cache for database connection and collections&#10;let cachedDb = null;&#10;let cachedCollection = null;&#10;&#10;// Response cache for identical requests (5 minutes)&#10;const responseCache = new Map();&#10;const CACHE_TTL = 5 * 60 * 1000;&#10;&#10;// Export the response cache for access by bulk-update route&#10;export { responseCache };&#10;&#10;// Function to clear cache when reviews are updated&#10;export function clearProductsCache() {&#10;  responseCache.clear();&#10;}&#10;&#10;// Enhanced cache clearing function for purchase count updates&#10;export function clearAllProductsCaches() {&#10;  responseCache.clear();&#10;  // Also clear any session cache&#10;  if (typeof window !== &quot;undefined&quot;) {&#10;    try {&#10;      sessionStorage.removeItem(&quot;products-cache&quot;);&#10;      sessionStorage.removeItem(&quot;farmfresh-products&quot;);&#10;    } catch (error) {}&#10;  }&#10;}&#10;&#10;// Initialize indexes optimized for MongoDB Atlas performance&#10;async function initializeProductIndexes(db) {&#10;  // Only initialize once per application lifecycle&#10;  if (productIndexesInitialized) {&#10;    return;&#10;  }&#10;&#10;  try {&#10;    const collection = db.collection(&quot;products&quot;);&#10;&#10;    // Check if indexes already exist before creating them&#10;    const existingIndexes = await collection.listIndexes().toArray();&#10;    const indexNames = existingIndexes.map((index) =&gt; index.name);&#10;&#10;    // Simplified Atlas-optimized compound indexes for better performance&#10;    const indexesToCreate = [&#10;      // Primary query index - most common pattern&#10;      {&#10;        key: { status: 1, category: 1, createdAt: -1 },&#10;        name: &quot;primary_query_idx&quot;,&#10;        options: { background: true },&#10;      },&#10;      // Search index&#10;      {&#10;        key: { name: &quot;text&quot;, description: &quot;text&quot;, category: &quot;text&quot; },&#10;        name: &quot;products_text_search_idx&quot;,&#10;        options: {&#10;          background: true,&#10;          weights: { name: 10, category: 5, description: 1 },&#10;        },&#10;      },&#10;      // Price and rating filters&#10;      {&#10;        key: { status: 1, price: 1, averageRating: -1 },&#10;        name: &quot;price_rating_idx&quot;,&#10;        options: { background: true },&#10;      },&#10;      // Farmer queries&#10;      {&#10;        key: { &quot;farmer._id&quot;: 1, status: 1 },&#10;        name: &quot;farmer_status_idx&quot;,&#10;        options: { background: true },&#10;      },&#10;    ];&#10;&#10;    for (const indexSpec of indexesToCreate) {&#10;      if (!indexNames.includes(indexSpec.name)) {&#10;        await collection.createIndex(indexSpec.key, {&#10;          name: indexSpec.name,&#10;          ...indexSpec.options,&#10;        });&#10;      }&#10;    }&#10;&#10;    productIndexesInitialized = true;&#10;  } catch (error) {}&#10;}&#10;&#10;// Generate cache key for request&#10;function generateCacheKey(searchParams) {&#10;  const params = {};&#10;  searchParams.forEach((value, key) =&gt; {&#10;    params[key] = value;&#10;  });&#10;  return JSON.stringify(params);&#10;}&#10;&#10;// Get cached response if available and not expired&#10;function getCachedResponse(cacheKey) {&#10;  const cached = responseCache.get(cacheKey);&#10;  if (cached &amp;&amp; Date.now() - cached.timestamp &lt; CACHE_TTL) {&#10;    return cached.data;&#10;  }&#10;  responseCache.delete(cacheKey);&#10;  return null;&#10;}&#10;&#10;// Set response in cache&#10;function setCachedResponse(cacheKey, data) {&#10;  responseCache.set(cacheKey, {&#10;    data,&#10;    timestamp: Date.now(),&#10;  });&#10;&#10;  // Clear cache if it gets too large to prevent memory issues&#10;  if (responseCache.size &gt; 50) {&#10;    const now = Date.now();&#10;    for (const [key, value] of responseCache.entries()) {&#10;      if (now - value.timestamp &gt;= CACHE_TTL) {&#10;        responseCache.delete(key);&#10;      }&#10;    }&#10;  }&#10;}&#10;&#10;export async function GET(request) {&#10;  try {&#10;    const { searchParams } = new URL(request.url);&#10;&#10;    // Check cache first&#10;    const cacheKey = generateCacheKey(searchParams);&#10;    const cachedResponse = getCachedResponse(cacheKey);&#10;    if (cachedResponse) {&#10;      const response = NextResponse.json(cachedResponse);&#10;      // Add cache headers to indicate this is cached data&#10;      response.headers.set(&quot;X-Cache&quot;, &quot;HIT&quot;);&#10;      response.headers.set(&quot;Cache-Control&quot;, &quot;public, max-age=300&quot;); // 5 minutes&#10;      return response;&#10;    }&#10;&#10;    const search = searchParams.get(&quot;search&quot;);&#10;    const category = searchParams.get(&quot;category&quot;);&#10;    const featured = searchParams.get(&quot;featured&quot;);&#10;    const sortBy = searchParams.get(&quot;sortBy&quot;);&#10;    const farmerId = searchParams.get(&quot;farmerId&quot;);&#10;    const farmerEmail = searchParams.get(&quot;farmerEmail&quot;);&#10;    const limit = parseInt(searchParams.get(&quot;limit&quot;)) || 50;&#10;    const page = parseInt(searchParams.get(&quot;page&quot;)) || 1;&#10;    const skip = (page - 1) * limit;&#10;&#10;    // Simplified filtering parameters&#10;    const minPrice = searchParams.get(&quot;minPrice&quot;)&#10;      ? parseFloat(searchParams.get(&quot;minPrice&quot;))&#10;      : null;&#10;    const maxPrice = searchParams.get(&quot;maxPrice&quot;)&#10;      ? parseFloat(searchParams.get(&quot;maxPrice&quot;))&#10;      : null;&#10;    const minRating = searchParams.get(&quot;minRating&quot;)&#10;      ? parseFloat(searchParams.get(&quot;minRating&quot;))&#10;      : null;&#10;&#10;    // Reuse database connection and collection&#10;    if (!cachedDb) {&#10;      const client = await clientPromise;&#10;      cachedDb = client.db(&quot;farmfresh&quot;);&#10;      cachedCollection = cachedDb.collection(&quot;products&quot;);&#10;    }&#10;&#10;    // Initialize indexes only once&#10;    await initializeProductIndexes(cachedDb);&#10;&#10;    // Build query - BACK TO ORIGINAL WORKING VERSION&#10;    const query = { status: { $ne: &quot;deleted&quot; } };&#10;&#10;    // Check if this is a dashboard context request&#10;    const isDashboardContext = searchParams.get(&quot;dashboard&quot;) === &quot;true&quot;;&#10;&#10;    // For public access (non-farmer requests), exclude inactive products&#10;    if (!farmerId &amp;&amp; !farmerEmail &amp;&amp; !isDashboardContext) {&#10;      query.status = { $nin: [&quot;deleted&quot;, &quot;inactive&quot;] };&#10;    }&#10;&#10;    // Add search filter&#10;    if (search) {&#10;      query.$text = { $search: search };&#10;    }&#10;&#10;    // Add category filter&#10;    if (category &amp;&amp; category !== &quot;All Categories&quot;) {&#10;      query.category = { $regex: new RegExp(category, &quot;i&quot;) };&#10;    }&#10;&#10;    // Add featured filter&#10;    if (featured === &quot;true&quot;) {&#10;      query.featured = true;&#10;    }&#10;&#10;    // Add farmer filters for dashboard - FIXED LOGIC to prevent cross-contamination&#10;    if (farmerId || farmerEmail) {&#10;      // For hardcoded farmers (no ObjectId), filter strictly by email&#10;      if (!farmerId || !farmerId.match(/^[0-9a-fA-F]{24}$/)) {&#10;        // This is a hardcoded farmer - filter ONLY by exact email match&#10;        if (farmerEmail) {&#10;          query.$and = query.$and || [];&#10;          query.$and.push({&#10;            $or: [&#10;              { farmerEmail: { $eq: farmerEmail } },&#10;              { &quot;farmer.email&quot;: { $eq: farmerEmail } },&#10;            ],&#10;          });&#10;        }&#10;      } else {&#10;        // This is a real farmer with ObjectId - use comprehensive matching&#10;        query.$or = [];&#10;&#10;        let farmerName = null;&#10;        let farmerFarmName = null;&#10;&#10;        try {&#10;          const farmersCollection = cachedDb.collection(&quot;farmers&quot;);&#10;          const farmer = await farmersCollection.findOne({&#10;            _id: new ObjectId(farmerId),&#10;          });&#10;&#10;          if (farmer) {&#10;            farmerName = farmer.name;&#10;            farmerFarmName = farmer.farmName;&#10;          }&#10;        } catch (error) {&#10;          console.log(&quot;Could not fetch farmer for name-based matching:&quot;, error);&#10;        }&#10;&#10;        // Match by farmerId (various formats)&#10;        query.$or.push(&#10;          { farmerId: farmerId },&#10;          { farmerId: { $eq: farmerId } },&#10;          { &quot;farmer.id&quot;: farmerId },&#10;          { &quot;farmer._id&quot;: farmerId },&#10;        );&#10;&#10;        // Match by farmer email (for real farmers)&#10;        if (farmerEmail) {&#10;          query.$or.push(&#10;            { farmerEmail: farmerEmail },&#10;            { &quot;farmer.email&quot;: farmerEmail },&#10;          );&#10;        }&#10;&#10;        // Match by farmer name (if available)&#10;        if (farmerName) {&#10;          query.$or.push(&#10;            { &quot;farmer.name&quot;: farmerName },&#10;            { &quot;farmer.name&quot;: { $regex: new RegExp(`^${farmerName}$`, &quot;i&quot;) } },&#10;          );&#10;        }&#10;&#10;        // Match by farm name (if available)&#10;        if (farmerFarmName) {&#10;          query.$or.push(&#10;            { &quot;farmer.farmName&quot;: farmerFarmName },&#10;            {&#10;              &quot;farmer.farmName&quot;: {&#10;                $regex: new RegExp(`^${farmerFarmName}$`, &quot;i&quot;),&#10;              },&#10;            },&#10;          );&#10;        }&#10;      }&#10;    }&#10;&#10;    // Add price range filter&#10;    if (minPrice !== null || maxPrice !== null) {&#10;      query.price = {};&#10;      if (minPrice !== null) query.price.$gte = minPrice;&#10;      if (maxPrice !== null) query.price.$lte = maxPrice;&#10;    }&#10;&#10;    // Add rating filter&#10;    if (minRating !== null) {&#10;      query.averageRating = { $gte: minRating };&#10;    }&#10;&#10;    // BACK TO ORIGINAL WORKING SORT&#10;    let sortOptions = {};&#10;    if (search) {&#10;      sortOptions = { score: { $meta: &quot;textScore&quot; }, createdAt: -1 };&#10;    } else {&#10;      switch (sortBy) {&#10;        case &quot;price-low&quot;:&#10;          sortOptions = { price: 1 };&#10;          break;&#10;        case &quot;price-high&quot;:&#10;          sortOptions = { price: -1 };&#10;          break;&#10;        case &quot;rating&quot;:&#10;          sortOptions = { averageRating: -1, totalReviews: -1 };&#10;          break;&#10;        case &quot;popular&quot;:&#10;          sortOptions = { purchaseCount: -1, averageRating: -1 };&#10;          break;&#10;        case &quot;oldest&quot;:&#10;          sortOptions = { createdAt: 1 };&#10;          break;&#10;        case &quot;newest&quot;:&#10;        default:&#10;          sortOptions = { createdAt: -1 };&#10;          break;&#10;      }&#10;    }&#10;&#10;    // BACK TO ORIGINAL WORKING QUERY EXECUTION&#10;    const startTime = Date.now();&#10;&#10;    // Execute query with original method&#10;    const [products, totalCount] = await Promise.all([&#10;      cachedCollection&#10;        .find(query)&#10;        .sort(sortOptions)&#10;        .skip(skip)&#10;        .limit(limit)&#10;        .toArray(),&#10;      cachedCollection.countDocuments(query),&#10;    ]);&#10;&#10;    const queryTime = Date.now() - startTime;&#10;    console.log(&#10;      `Query executed in ${queryTime}ms for ${products.length} products, total: ${totalCount}`,&#10;    );&#10;&#10;    // Enhance with ratings&#10;    const enhancedProducts = await enhanceProductsWithRatings(&#10;      products,&#10;      cachedDb,&#10;    );&#10;&#10;    // Prepare response data&#10;    const responseData = {&#10;      products: enhancedProducts,&#10;      pagination: {&#10;        page,&#10;        limit,&#10;        total: totalCount,&#10;        totalPages: Math.ceil(totalCount / limit),&#10;        hasNext: page * limit &lt; totalCount,&#10;        hasPrev: page &gt; 1,&#10;      },&#10;      meta: {&#10;        query: {&#10;          search,&#10;          category,&#10;          featured,&#10;          sortBy,&#10;          minPrice,&#10;          maxPrice,&#10;          minRating,&#10;        },&#10;        performance: {&#10;          queryTime,&#10;          cached: false,&#10;        },&#10;        timestamp: new Date().toISOString(),&#10;      },&#10;    };&#10;&#10;    // Cache the response&#10;    setCachedResponse(cacheKey, responseData);&#10;&#10;    const response = NextResponse.json(responseData);&#10;    // Add cache headers&#10;    response.headers.set(&quot;X-Cache&quot;, &quot;MISS&quot;);&#10;    response.headers.set(&quot;Cache-Control&quot;, &quot;public, max-age=300&quot;); // 5 minutes&#10;    response.headers.set(&quot;X-Generated-At&quot;, new Date().toISOString());&#10;&#10;    return response;&#10;  } catch (error) {&#10;    console.error(&quot;Error fetching products:&quot;, error);&#10;    return NextResponse.json(&#10;      {&#10;        error: &quot;Failed to fetch products&quot;,&#10;        message: error.message,&#10;        products: [],&#10;        pagination: {&#10;          page: 1,&#10;          limit: 12,&#10;          total: 0,&#10;          totalPages: 0,&#10;          hasNext: false,&#10;          hasPrev: false,&#10;        },&#10;        timestamp: new Date().toISOString(),&#10;      },&#10;      { status: 500 },&#10;    );&#10;  }&#10;}&#10;&#10;export async function POST(request) {&#10;  try {&#10;    const body = await request.json();&#10;    const client = await clientPromise;&#10;    const db = client.db(&quot;farmfresh&quot;);&#10;&#10;    // Initialize indexes for the first POST operation&#10;    await initializeProductIndexes(db);&#10;&#10;    const result = await db.collection(&quot;products&quot;).insertOne({&#10;      ...body,&#10;      // Don't overwrite createdAt if it's already provided, but ensure it's a Date object&#10;      createdAt: body.createdAt ? new Date(body.createdAt) : new Date(),&#10;      updatedAt: new Date(),&#10;      status: &quot;active&quot;,&#10;      averageRating: 0,&#10;      totalReviews: 0,&#10;      reviewCount: 0,&#10;      purchaseCount: 0,&#10;    });&#10;&#10;    return NextResponse.json({&#10;      success: true,&#10;      productId: result.insertedId,&#10;    });&#10;  } catch (error) {&#10;    console.error(&quot;Error creating product:&quot;, error);&#10;    return NextResponse.json(&#10;      { error: &quot;Failed to create product&quot;, message: error.message },&#10;      { status: 500 },&#10;    );&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/create/page.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/create/page.js" />
              <option name="originalContent" value="&quot;use client&quot;;&#10;&#10;import { useState, useEffect } from &quot;react&quot;;&#10;import { useSession } from &quot;next-auth/react&quot;;&#10;import { useRouter } from &quot;next/navigation&quot;;&#10;import Link from &quot;next/link&quot;;&#10;import Image from &quot;next/image&quot;;&#10;import Footer from &quot;@/components/Footer&quot;;&#10;import { useDashboardData } from &quot;@/hooks/useDashboardData&quot;;&#10;&#10;export default function CreateProduct() {&#10;  const { data: session, status } = useSession();&#10;  const router = useRouter();&#10;  const { addProduct } = useDashboardData(); // Use the optimistic addProduct function&#10;  const [loading, setLoading] = useState(false);&#10;  const [imagePreviews, setImagePreviews] = useState([]);&#10;  const [imageFiles, setImageFiles] = useState([]);&#10;  const [formData, setFormData] = useState({&#10;    name: &quot;&quot;,&#10;    category: &quot;&quot;,&#10;    description: &quot;&quot;,&#10;    price: &quot;&quot;,&#10;    stock: &quot;&quot;,&#10;    unit: &quot;&quot;,&#10;    features: [],&#10;    images: [],&#10;    farmLocation: &quot;&quot;,&#10;    harvestDate: &quot;&quot;,&#10;  });&#10;&#10;  useEffect(() =&gt; {&#10;    if (status === &quot;unauthenticated&quot;) {&#10;      router.push(&quot;/login&quot;);&#10;      return;&#10;    }&#10;&#10;    if (status === &quot;authenticated&quot; &amp;&amp; session?.user) {&#10;      // Check if user is a farmer&#10;      const userType = session.user.userType || session.user.role || &quot;user&quot;;&#10;      if (userType !== &quot;farmer&quot;) {&#10;        router.push(&quot;/&quot;);&#10;        return;&#10;      }&#10;    }&#10;  }, [session, status, router]);&#10;&#10;  const handleInputChange = (e) =&gt; {&#10;    const { name, value } = e.target;&#10;    setFormData((prev) =&gt; ({&#10;      ...prev,&#10;      [name]: value,&#10;    }));&#10;  };&#10;&#10;  const handleFeatureChange = (e) =&gt; {&#10;    const { value, checked } = e.target;&#10;    setFormData((prev) =&gt; ({&#10;      ...prev,&#10;      features: checked&#10;        ? [...prev.features, value]&#10;        : prev.features.filter((feature) =&gt; feature !== value),&#10;    }));&#10;  };&#10;&#10;  const compressImage = (&#10;    file,&#10;    maxWidth = 1200,&#10;    maxHeight = 1200,&#10;    quality = 0.8,&#10;  ) =&gt; {&#10;    return new Promise((resolve) =&gt; {&#10;      const canvas = document.createElement(&quot;canvas&quot;);&#10;      const ctx = canvas.getContext(&quot;2d&quot;);&#10;      const img = new Image();&#10;&#10;      img.onload = () =&gt; {&#10;        // Calculate new dimensions while maintaining aspect ratio&#10;        let { width, height } = img;&#10;&#10;        if (width &gt; maxWidth) {&#10;          height = (height * maxWidth) / width;&#10;          width = maxWidth;&#10;        }&#10;&#10;        if (height &gt; maxHeight) {&#10;          width = (width * maxHeight) / height;&#10;          height = maxHeight;&#10;        }&#10;&#10;        canvas.width = width;&#10;        canvas.height = height;&#10;&#10;        // Draw and compress the image&#10;        ctx.drawImage(img, 0, 0, width, height);&#10;&#10;        canvas.toBlob(&#10;          (blob) =&gt; {&#10;            const reader = new FileReader();&#10;            reader.onload = (e) =&gt; resolve(e.target.result);&#10;            reader.readAsDataURL(blob);&#10;          },&#10;          &quot;image/jpeg&quot;,&#10;          quality,&#10;        );&#10;      };&#10;&#10;      img.src = URL.createObjectURL(file);&#10;    });&#10;  };&#10;&#10;  const handleImageChange = async (e) =&gt; {&#10;    const files = Array.from(e.target.files);&#10;&#10;    // Validate number of files&#10;    if (files.length &gt; 5) {&#10;      alert(&quot;You can upload a maximum of 5 images&quot;);&#10;      return;&#10;    }&#10;&#10;    // Validate each file&#10;    const validFiles = [];&#10;    const previews = [];&#10;    const base64Images = [];&#10;&#10;    for (const file of files) {&#10;      // Validate file type&#10;      if (!file.type.startsWith(&quot;image/&quot;)) {&#10;        alert(`${file.name} is not a valid image file`);&#10;        continue;&#10;      }&#10;&#10;      validFiles.push(file);&#10;      previews.push(URL.createObjectURL(file));&#10;&#10;      try {&#10;        // Compress large images automatically&#10;        let processedImageData;&#10;&#10;        if (file.size &gt; 2 * 1024 * 1024) {&#10;          // If file is larger than 2MB&#10;          console.log(&#10;            `Compressing large image: ${file.name} (${(file.size / 1024 / 1024).toFixed(2)}MB)`,&#10;          );&#10;          processedImageData = await compressImage(file, 1200, 1200, 0.8);&#10;        } else if (file.size &gt; 1 * 1024 * 1024) {&#10;          // If file is larger than 1MB&#10;          processedImageData = await compressImage(file, 1200, 1200, 0.9);&#10;        } else {&#10;          // For smaller files, just convert to base64 without compression&#10;          const reader = new FileReader();&#10;          processedImageData = await new Promise((resolve) =&gt; {&#10;            reader.onload = (event) =&gt; resolve(event.target.result);&#10;            reader.readAsDataURL(file);&#10;          });&#10;        }&#10;&#10;        base64Images.push(processedImageData);&#10;      } catch (error) {&#10;        console.error(`Error processing image ${file.name}:`, error);&#10;        alert(`Failed to process image ${file.name}. Please try again.`);&#10;      }&#10;    }&#10;&#10;    // Update state with processed images&#10;    setImageFiles(validFiles);&#10;    setImagePreviews(previews);&#10;    setFormData((prev) =&gt; ({&#10;      ...prev,&#10;      images: base64Images,&#10;    }));&#10;  };&#10;&#10;  const removeImage = (index) =&gt; {&#10;    const newPreviews = imagePreviews.filter((_, i) =&gt; i !== index);&#10;    const newFiles = imageFiles.filter((_, i) =&gt; i !== index);&#10;    const newImages = formData.images.filter((_, i) =&gt; i !== index);&#10;&#10;    setImagePreviews(newPreviews);&#10;    setImageFiles(newFiles);&#10;    setFormData((prev) =&gt; ({&#10;      ...prev,&#10;      images: newImages,&#10;    }));&#10;  };&#10;&#10;  const validateForm = () =&gt; {&#10;    if (!formData.name.trim()) {&#10;      alert(&quot;Product name is required&quot;);&#10;      return false;&#10;    }&#10;    if (!formData.category) {&#10;      alert(&quot;Category is required&quot;);&#10;      return false;&#10;    }&#10;    if (!formData.description.trim()) {&#10;      alert(&quot;Description is required&quot;);&#10;      return false;&#10;    }&#10;    if (!formData.price || parseFloat(formData.price) &lt;= 0) {&#10;      alert(&quot;Valid price is required&quot;);&#10;      return false;&#10;    }&#10;    if (!formData.stock || parseInt(formData.stock) &lt; 0) {&#10;      alert(&quot;Valid stock quantity is required&quot;);&#10;      return false;&#10;    }&#10;    if (!formData.unit) {&#10;      alert(&quot;Unit is required&quot;);&#10;      return false;&#10;    }&#10;    return true;&#10;  };&#10;&#10;  const handleSubmit = async (e) =&gt; {&#10;    e.preventDefault();&#10;&#10;    if (!validateForm()) return;&#10;&#10;    setLoading(true);&#10;    try {&#10;      // Use the same user ID logic as in manage page&#10;      const userId = session.user.userId || session.user.id || session.user._id;&#10;      const userEmail = session.user.email;&#10;&#10;      const productData = {&#10;        ...formData,&#10;        price: parseFloat(formData.price),&#10;        stock: parseInt(formData.stock),&#10;        farmerId: userId,&#10;        farmerEmail: userEmail,&#10;        farmer: {&#10;          id: userId,&#10;          email: userEmail,&#10;          name: session.user.name,&#10;        },&#10;        status: &quot;active&quot;,&#10;        createdAt: new Date().toISOString(),&#10;        updatedAt: new Date().toISOString(),&#10;        // Keep backward compatibility with single image&#10;        image: formData.images[0] || &quot;&quot;,&#10;      };&#10;&#10;      console.log(&quot;Creating product:&quot;, productData);&#10;&#10;      // Use the addProduct function from hook with optimistic updates&#10;      const result = await addProduct(productData);&#10;&#10;      if (!result.success) {&#10;        throw new Error(&quot;Failed to create product&quot;);&#10;      }&#10;&#10;      alert(&quot;Product added successfully!&quot;);&#10;&#10;      // Reset form&#10;      setFormData({&#10;        name: &quot;&quot;,&#10;        category: &quot;&quot;,&#10;        description: &quot;&quot;,&#10;        price: &quot;&quot;,&#10;        stock: &quot;&quot;,&#10;        unit: &quot;&quot;,&#10;        features: [],&#10;        images: [],&#10;        farmLocation: &quot;&quot;,&#10;        harvestDate: &quot;&quot;,&#10;      });&#10;      setImagePreviews([]);&#10;      setImageFiles([]);&#10;&#10;      // Redirect to manage products page&#10;      router.push(&quot;/manage&quot;);&#10;    } catch (error) {&#10;      console.error(&quot;Error creating product:&quot;, error);&#10;      alert(`Failed to add product: ${error.message || &quot;Please try again.&quot;}`);&#10;    } finally {&#10;      setLoading(false);&#10;    }&#10;  };&#10;&#10;  if (status === &quot;loading&quot;) {&#10;    return (&#10;      &lt;div className=&quot;min-h-screen bg-gray-50 dark:bg-gray-900 flex items-center justify-center&quot;&gt;&#10;        &lt;div className=&quot;text-center&quot;&gt;&#10;          &lt;i className=&quot;fas fa-spinner fa-spin text-4xl text-primary-600 mb-4&quot;&gt;&lt;/i&gt;&#10;          &lt;p className=&quot;text-gray-600 dark:text-gray-400&quot;&gt;Loading...&lt;/p&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;&#10;  return (&#10;    &lt;&gt;&#10;      {/* Breadcrumb */}&#10;      &lt;div className=&quot;max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-4&quot;&gt;&#10;        &lt;nav className=&quot;flex&quot; aria-label=&quot;Breadcrumb&quot;&gt;&#10;          &lt;ol className=&quot;flex items-center space-x-2 text-sm&quot;&gt;&#10;            &lt;li&gt;&#10;              &lt;Link href=&quot;/&quot; className=&quot;text-gray-500 hover:text-primary-600&quot;&gt;&#10;                Home&#10;              &lt;/Link&gt;&#10;            &lt;/li&gt;&#10;            &lt;li&gt;&#10;              &lt;i className=&quot;fas fa-chevron-right text-gray-400 text-xs&quot;&gt;&lt;/i&gt;&#10;            &lt;/li&gt;&#10;            &lt;li&gt;&#10;              &lt;Link&#10;                href=&quot;/manage&quot;&#10;                className=&quot;text-gray-500 hover:text-primary-600&quot;&#10;              &gt;&#10;                Manage Products&#10;              &lt;/Link&gt;&#10;            &lt;/li&gt;&#10;            &lt;li&gt;&#10;              &lt;i className=&quot;fas fa-chevron-right text-gray-400 text-xs&quot;&gt;&lt;/i&gt;&#10;            &lt;/li&gt;&#10;            &lt;li className=&quot;text-gray-900 dark:text-white&quot;&gt;Add Product&lt;/li&gt;&#10;          &lt;/ol&gt;&#10;        &lt;/nav&gt;&#10;      &lt;/div&gt;&#10;&#10;      {/* Add Product Form */}&#10;      &lt;div className=&quot;max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-8&quot;&gt;&#10;        &lt;div className=&quot;bg-white dark:bg-gray-800 rounded-2xl shadow-lg overflow-hidden&quot;&gt;&#10;          {/* Header */}&#10;          &lt;div className=&quot;bg-primary-600 text-white px-8 py-6&quot;&gt;&#10;            &lt;h1 className=&quot;text-3xl font-bold&quot;&gt;Add New Product&lt;/h1&gt;&#10;            &lt;p className=&quot;text-primary-100 mt-2&quot;&gt;&#10;              Share your fresh produce with customers&#10;            &lt;/p&gt;&#10;          &lt;/div&gt;&#10;&#10;          {/* Form */}&#10;          &lt;form onSubmit={handleSubmit} className=&quot;p-8 space-y-8&quot;&gt;&#10;            {/* Basic Information */}&#10;            &lt;div&gt;&#10;              &lt;h2 className=&quot;text-xl font-semibold text-gray-900 dark:text-white mb-4&quot;&gt;&#10;                Basic Information&#10;              &lt;/h2&gt;&#10;              &lt;div className=&quot;grid grid-cols-1 md:grid-cols-2 gap-6&quot;&gt;&#10;                &lt;div&gt;&#10;                  &lt;label&#10;                    htmlFor=&quot;name&quot;&#10;                    className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&#10;                  &gt;&#10;                    Product Name *&#10;                  &lt;/label&gt;&#10;                  &lt;input&#10;                    type=&quot;text&quot;&#10;                    id=&quot;name&quot;&#10;                    name=&quot;name&quot;&#10;                    value={formData.name}&#10;                    onChange={handleInputChange}&#10;                    required&#10;                    className=&quot;w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-transparent dark:bg-gray-700 dark:text-white&quot;&#10;                    placeholder=&quot;e.g., Fresh Tomatoes&quot;&#10;                  /&gt;&#10;                &lt;/div&gt;&#10;&#10;                &lt;div&gt;&#10;                  &lt;label&#10;                    htmlFor=&quot;category&quot;&#10;                    className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&#10;                  &gt;&#10;                    Category *&#10;                  &lt;/label&gt;&#10;                  &lt;select&#10;                    id=&quot;category&quot;&#10;                    name=&quot;category&quot;&#10;                    value={formData.category}&#10;                    onChange={handleInputChange}&#10;                    required&#10;                    className=&quot;w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-transparent dark:bg-gray-700 dark:text-white&quot;&#10;                  &gt;&#10;                    &lt;option value=&quot;&quot;&gt;Select Category&lt;/option&gt;&#10;                    &lt;option value=&quot;Vegetables&quot;&gt;Vegetables&lt;/option&gt;&#10;                    &lt;option value=&quot;Fruits&quot;&gt;Fruits&lt;/option&gt;&#10;                    &lt;option value=&quot;Grains&quot;&gt;Grains&lt;/option&gt;&#10;                    &lt;option value=&quot;Dairy&quot;&gt;Dairy&lt;/option&gt;&#10;                    &lt;option value=&quot;Herbs&quot;&gt;Herbs&lt;/option&gt;&#10;                    &lt;option value=&quot;Honey&quot;&gt;Honey&lt;/option&gt;&#10;                  &lt;/select&gt;&#10;                &lt;/div&gt;&#10;&#10;                &lt;div className=&quot;md:col-span-2&quot;&gt;&#10;                  &lt;label&#10;                    htmlFor=&quot;description&quot;&#10;                    className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&#10;                  &gt;&#10;                    Description *&#10;                  &lt;/label&gt;&#10;                  &lt;textarea&#10;                    id=&quot;description&quot;&#10;                    name=&quot;description&quot;&#10;                    rows={4}&#10;                    value={formData.description}&#10;                    onChange={handleInputChange}&#10;                    required&#10;                    className=&quot;w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-transparent dark:bg-gray-700 dark:text-white&quot;&#10;                    placeholder=&quot;Describe your product, growing methods, quality, etc.&quot;&#10;                  /&gt;&#10;                &lt;/div&gt;&#10;              &lt;/div&gt;&#10;            &lt;/div&gt;&#10;&#10;            {/* Pricing &amp; Inventory */}&#10;            &lt;div&gt;&#10;              &lt;h2 className=&quot;text-xl font-semibold text-gray-900 dark:text-white mb-4&quot;&gt;&#10;                Pricing &amp; Inventory&#10;              &lt;/h2&gt;&#10;              &lt;div className=&quot;grid grid-cols-1 md:grid-cols-3 gap-6&quot;&gt;&#10;                &lt;div&gt;&#10;                  &lt;label&#10;                    htmlFor=&quot;price&quot;&#10;                    className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&#10;                  &gt;&#10;                    Price per Unit (৳) *&#10;                  &lt;/label&gt;&#10;                  &lt;input&#10;                    type=&quot;number&quot;&#10;                    id=&quot;price&quot;&#10;                    name=&quot;price&quot;&#10;                    min=&quot;0&quot;&#10;                    step=&quot;0.01&quot;&#10;                    value={formData.price}&#10;                    onChange={handleInputChange}&#10;                    required&#10;                    className=&quot;w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-transparent dark:bg-gray-700 dark:text-white&quot;&#10;                    placeholder=&quot;45.00&quot;&#10;                  /&gt;&#10;                &lt;/div&gt;&#10;&#10;                &lt;div&gt;&#10;                  &lt;label&#10;                    htmlFor=&quot;unit&quot;&#10;                    className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&#10;                  &gt;&#10;                    Unit *&#10;                  &lt;/label&gt;&#10;                  &lt;select&#10;                    id=&quot;unit&quot;&#10;                    name=&quot;unit&quot;&#10;                    value={formData.unit}&#10;                    onChange={handleInputChange}&#10;                    required&#10;                    className=&quot;w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-transparent dark:bg-gray-700 dark:text-white&quot;&#10;                  &gt;&#10;                    &lt;option value=&quot;&quot;&gt;Select Unit&lt;/option&gt;&#10;                    &lt;option value=&quot;kg&quot;&gt;Kilogram (kg)&lt;/option&gt;&#10;                    &lt;option value=&quot;g&quot;&gt;Gram (g)&lt;/option&gt;&#10;                    &lt;option value=&quot;piece&quot;&gt;Piece&lt;/option&gt;&#10;                    &lt;option value=&quot;bunch&quot;&gt;Bunch&lt;/option&gt;&#10;                    &lt;option value=&quot;liter&quot;&gt;Liter&lt;/option&gt;&#10;                    &lt;option value=&quot;ml&quot;&gt;Milliliter (ml)&lt;/option&gt;&#10;                    &lt;option value=&quot;dozen&quot;&gt;Dozen&lt;/option&gt;&#10;                    &lt;option value=&quot;bundle&quot;&gt;Bundle&lt;/option&gt;&#10;                  &lt;/select&gt;&#10;                &lt;/div&gt;&#10;&#10;                &lt;div&gt;&#10;                  &lt;label&#10;                    htmlFor=&quot;stock&quot;&#10;                    className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&#10;                  &gt;&#10;                    Available Stock *&#10;                  &lt;/label&gt;&#10;                  &lt;input&#10;                    type=&quot;number&quot;&#10;                    id=&quot;stock&quot;&#10;                    name=&quot;stock&quot;&#10;                    min=&quot;0&quot;&#10;                    step=&quot;1&quot;&#10;                    value={formData.stock}&#10;                    onChange={handleInputChange}&#10;                    onWheel={(e) =&gt; e.target.blur()} // Prevent mouse wheel changes&#10;                    onKeyDown={(e) =&gt; {&#10;                      // Prevent arrow keys from changing the value unintentionally&#10;                      if (e.key === &quot;ArrowUp&quot; || e.key === &quot;ArrowDown&quot;) {&#10;                        e.preventDefault();&#10;                      }&#10;                    }}&#10;                    required&#10;                    className=&quot;w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-transparent dark:bg-gray-700 dark:text-white&quot;&#10;                    placeholder=&quot;100&quot;&#10;                  /&gt;&#10;                &lt;/div&gt;&#10;              &lt;/div&gt;&#10;            &lt;/div&gt;&#10;&#10;            {/* Product Images */}&#10;            &lt;div&gt;&#10;              &lt;h2 className=&quot;text-xl font-semibold text-gray-900 dark:text-white mb-4&quot;&gt;&#10;                Product Images&#10;              &lt;/h2&gt;&#10;              &lt;div className=&quot;space-y-4&quot;&gt;&#10;                &lt;div&gt;&#10;                  &lt;label&#10;                    htmlFor=&quot;images&quot;&#10;                    className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&#10;                  &gt;&#10;                    Upload Images (Max 5 images) *&#10;                  &lt;/label&gt;&#10;                  &lt;div className=&quot;border-2 border-dashed border-gray-300 dark:border-gray-600 rounded-lg p-6 text-center hover:border-primary-500 transition&quot;&gt;&#10;                    &lt;input&#10;                      type=&quot;file&quot;&#10;                      id=&quot;images&quot;&#10;                      name=&quot;images&quot;&#10;                      multiple&#10;                      accept=&quot;image/*&quot;&#10;                      onChange={handleImageChange}&#10;                      className=&quot;hidden&quot;&#10;                    /&gt;&#10;                    &lt;label htmlFor=&quot;images&quot; className=&quot;cursor-pointer&quot;&gt;&#10;                      &lt;i className=&quot;fas fa-cloud-upload-alt text-4xl text-gray-400 mb-4&quot;&gt;&lt;/i&gt;&#10;                      &lt;p className=&quot;text-lg font-medium text-gray-900 dark:text-white&quot;&gt;&#10;                        Click to upload images&#10;                      &lt;/p&gt;&#10;                      &lt;p className=&quot;text-sm text-gray-500 dark:text-gray-400&quot;&gt;&#10;                        PNG, JPG, WebP - Large images will be automatically&#10;                        optimized&#10;                      &lt;/p&gt;&#10;                    &lt;/label&gt;&#10;                  &lt;/div&gt;&#10;&#10;                  {/* Image Previews */}&#10;                  {imagePreviews.length &gt; 0 &amp;&amp; (&#10;                    &lt;div className=&quot;mt-4&quot;&gt;&#10;                      &lt;p className=&quot;text-sm font-medium text-gray-700 dark:text-gray-300 mb-3&quot;&gt;&#10;                        Selected Images ({imagePreviews.length}/5)&#10;                      &lt;/p&gt;&#10;                      &lt;div className=&quot;grid grid-cols-2 md:grid-cols-5 gap-4&quot;&gt;&#10;                        {imagePreviews.map((preview, index) =&gt; (&#10;                          &lt;div&#10;                            key={index}&#10;                            className=&quot;relative group rounded-lg overflow-hidden bg-gray-100 dark:bg-gray-700&quot;&#10;                          &gt;&#10;                            &lt;Image&#10;                              src={preview}&#10;                              alt={`Product Image ${index + 1}`}&#10;                              width={200}&#10;                              height={150}&#10;                              className=&quot;w-full h-24 object-cover group-hover:scale-105 transition-transform duration-200&quot;&#10;                            /&gt;&#10;                            &lt;div className=&quot;absolute inset-0 bg-black bg-opacity-0 group-hover:bg-opacity-30 transition-opacity duration-200 flex items-center justify-center&quot;&gt;&#10;                              &lt;button&#10;                                type=&quot;button&quot;&#10;                                onClick={() =&gt; removeImage(index)}&#10;                                className=&quot;opacity-0 group-hover:opacity-100 bg-red-500 hover:bg-red-600 text-white rounded-full w-8 h-8 flex items-center justify-center transition-all duration-200 shadow-lg&quot;&#10;                                title=&quot;Remove image&quot;&#10;                              &gt;&#10;                                &lt;i className=&quot;fas fa-times text-sm&quot;&gt;&lt;/i&gt;&#10;                              &lt;/button&gt;&#10;                            &lt;/div&gt;&#10;                            &lt;div className=&quot;absolute bottom-1 left-1 bg-black bg-opacity-70 text-white text-xs px-1 py-0.5 rounded&quot;&gt;&#10;                              {index + 1}&#10;                            &lt;/div&gt;&#10;                          &lt;/div&gt;&#10;                        ))}&#10;&#10;                        {/* Add more images placeholder */}&#10;                        {imagePreviews.length &lt; 5 &amp;&amp; (&#10;                          &lt;div&#10;                            className=&quot;border-2 border-dashed border-gray-300 dark:border-gray-600 rounded-lg h-24 flex items-center justify-center cursor-pointer hover:border-primary-500 transition-colors&quot;&#10;                            onClick={() =&gt;&#10;                              document.getElementById(&quot;images&quot;).click()&#10;                            }&#10;                          &gt;&#10;                            &lt;div className=&quot;text-center&quot;&gt;&#10;                              &lt;i className=&quot;fas fa-plus text-gray-400 text-xl mb-1&quot;&gt;&lt;/i&gt;&#10;                              &lt;p className=&quot;text-xs text-gray-500 dark:text-gray-400&quot;&gt;&#10;                                Add More&#10;                              &lt;/p&gt;&#10;                            &lt;/div&gt;&#10;                          &lt;/div&gt;&#10;                        )}&#10;                      &lt;/div&gt;&#10;                    &lt;/div&gt;&#10;                  )}&#10;                &lt;/div&gt;&#10;              &lt;/div&gt;&#10;            &lt;/div&gt;&#10;&#10;            {/* Farm Information */}&#10;            &lt;div&gt;&#10;              &lt;h2 className=&quot;text-xl font-semibold text-gray-900 dark:text-white mb-4&quot;&gt;&#10;                Farm Information&#10;              &lt;/h2&gt;&#10;              &lt;div className=&quot;grid grid-cols-1 md:grid-cols-2 gap-6&quot;&gt;&#10;                &lt;div&gt;&#10;                  &lt;label&#10;                    htmlFor=&quot;farmLocation&quot;&#10;                    className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&#10;                  &gt;&#10;                    Farm Location&#10;                  &lt;/label&gt;&#10;                  &lt;input&#10;                    type=&quot;text&quot;&#10;                    id=&quot;farmLocation&quot;&#10;                    name=&quot;farmLocation&quot;&#10;                    value={formData.farmLocation}&#10;                    onChange={handleInputChange}&#10;                    className=&quot;w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-transparent dark:bg-gray-700 dark:text-white&quot;&#10;                    placeholder=&quot;e.g., Sylhet, Bangladesh&quot;&#10;                  /&gt;&#10;                &lt;/div&gt;&#10;&#10;                &lt;div&gt;&#10;                  &lt;label&#10;                    htmlFor=&quot;harvestDate&quot;&#10;                    className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&#10;                  &gt;&#10;                    Harvest Date&#10;                  &lt;/label&gt;&#10;                  &lt;input&#10;                    type=&quot;date&quot;&#10;                    id=&quot;harvestDate&quot;&#10;                    name=&quot;harvestDate&quot;&#10;                    value={formData.harvestDate}&#10;                    onChange={handleInputChange}&#10;                    className=&quot;w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-transparent dark:bg-gray-700 dark:text-white&quot;&#10;                  /&gt;&#10;                &lt;/div&gt;&#10;              &lt;/div&gt;&#10;            &lt;/div&gt;&#10;&#10;            {/* Product Features */}&#10;            &lt;div&gt;&#10;              &lt;h2 className=&quot;text-xl font-semibold text-gray-900 dark:text-white mb-4&quot;&gt;&#10;                Product Features&#10;              &lt;/h2&gt;&#10;              &lt;div className=&quot;grid grid-cols-2 md:grid-cols-4 gap-4&quot;&gt;&#10;                {[&#10;                  &quot;organic&quot;,&#10;                  &quot;pesticide-free&quot;,&#10;                  &quot;fresh&quot;,&#10;                  &quot;non-gmo&quot;,&#10;                  &quot;local&quot;,&#10;                  &quot;sustainable&quot;,&#10;                  &quot;fair-trade&quot;,&#10;                  &quot;gluten-free&quot;,&#10;                ].map((feature) =&gt; (&#10;                  &lt;label&#10;                    key={feature}&#10;                    className=&quot;flex items-center p-3 border border-gray-300 dark:border-gray-600 rounded-lg cursor-pointer hover:bg-gray-50 dark:hover:bg-gray-700&quot;&#10;                  &gt;&#10;                    &lt;input&#10;                      type=&quot;checkbox&quot;&#10;                      name=&quot;features&quot;&#10;                      value={feature}&#10;                      checked={formData.features.includes(feature)}&#10;                      onChange={handleFeatureChange}&#10;                      className=&quot;rounded border-gray-300 text-primary-600 focus:ring-primary-500&quot;&#10;                    /&gt;&#10;                    &lt;span className=&quot;ml-2 text-sm capitalize&quot;&gt;&#10;                      {feature.replace(&quot;-&quot;, &quot; &quot;)}&#10;                    &lt;/span&gt;&#10;                  &lt;/label&gt;&#10;                ))}&#10;              &lt;/div&gt;&#10;            &lt;/div&gt;&#10;&#10;            {/* Submit Button */}&#10;            &lt;div&gt;&#10;              &lt;button&#10;                type=&quot;submit&quot;&#10;                disabled={loading}&#10;                className={`w-full py-3 rounded-lg font-semibold focus:outline-none focus:ring-2 focus:ring-primary-500 focus:ring-offset-2 transition ${&#10;                  loading&#10;                    ? &quot;bg-gray-400 cursor-not-allowed text-white&quot;&#10;                    : &quot;bg-primary-600 text-white hover:bg-primary-700&quot;&#10;                }`}&#10;              &gt;&#10;                {loading ? (&#10;                  &lt;&gt;&#10;                    &lt;i className=&quot;fas fa-spinner fa-spin mr-2&quot;&gt;&lt;/i&gt;&#10;                    Adding Product...&#10;                  &lt;/&gt;&#10;                ) : (&#10;                  &lt;&gt;&#10;                    &lt;i className=&quot;fas fa-plus mr-2&quot;&gt;&lt;/i&gt;&#10;                    Add Product&#10;                  &lt;/&gt;&#10;                )}&#10;              &lt;/button&gt;&#10;            &lt;/div&gt;&#10;          &lt;/form&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;&#10;      {/* Footer */}&#10;      &lt;Footer /&gt;&#10;    &lt;/&gt;&#10;  );&#10;}&#10;" />
              <option name="updatedContent" value="&quot;use client&quot;;&#10;&#10;import { useState, useEffect } from &quot;react&quot;;&#10;import { useSession } from &quot;next-auth/react&quot;;&#10;import { useRouter } from &quot;next/navigation&quot;;&#10;import Link from &quot;next/link&quot;;&#10;import Image from &quot;next/image&quot;;&#10;import Footer from &quot;@/components/Footer&quot;;&#10;import { useDashboardData } from &quot;@/hooks/useDashboardData&quot;;&#10;&#10;export default function CreateProduct() {&#10;  const { data: session, status } = useSession();&#10;  const router = useRouter();&#10;  const { addProduct } = useDashboardData(); // Use the optimistic addProduct function&#10;  const [loading, setLoading] = useState(false);&#10;  const [imagePreviews, setImagePreviews] = useState([]);&#10;  const [imageFiles, setImageFiles] = useState([]);&#10;  const [formData, setFormData] = useState({&#10;    name: &quot;&quot;,&#10;    category: &quot;&quot;,&#10;    description: &quot;&quot;,&#10;    price: &quot;&quot;,&#10;    stock: &quot;&quot;,&#10;    unit: &quot;&quot;,&#10;    features: [],&#10;    images: [],&#10;    farmLocation: &quot;&quot;,&#10;    harvestDate: &quot;&quot;,&#10;  });&#10;&#10;  useEffect(() =&gt; {&#10;    if (status === &quot;unauthenticated&quot;) {&#10;      router.push(&quot;/login&quot;);&#10;      return;&#10;    }&#10;&#10;    if (status === &quot;authenticated&quot; &amp;&amp; session?.user) {&#10;      // Check if user is a farmer&#10;      const userType = session.user.userType || session.user.role || &quot;user&quot;;&#10;      if (userType !== &quot;farmer&quot;) {&#10;        router.push(&quot;/&quot;);&#10;        return;&#10;      }&#10;    }&#10;  }, [session, status, router]);&#10;&#10;  const handleInputChange = (e) =&gt; {&#10;    const { name, value } = e.target;&#10;    setFormData((prev) =&gt; ({&#10;      ...prev,&#10;      [name]: value,&#10;    }));&#10;  };&#10;&#10;  const handleFeatureChange = (e) =&gt; {&#10;    const { value, checked } = e.target;&#10;    setFormData((prev) =&gt; ({&#10;      ...prev,&#10;      features: checked&#10;        ? [...prev.features, value]&#10;        : prev.features.filter((feature) =&gt; feature !== value),&#10;    }));&#10;  };&#10;&#10;  const compressImage = (&#10;    file,&#10;    maxWidth = 1200,&#10;    maxHeight = 1200,&#10;    quality = 0.8,&#10;  ) =&gt; {&#10;    return new Promise((resolve) =&gt; {&#10;      const canvas = document.createElement(&quot;canvas&quot;);&#10;      const ctx = canvas.getContext(&quot;2d&quot;);&#10;      const img = new window.Image(); // Use native browser Image constructor&#10;&#10;      img.onload = () =&gt; {&#10;        // Calculate new dimensions while maintaining aspect ratio&#10;        let { width, height } = img;&#10;&#10;        if (width &gt; maxWidth) {&#10;          height = (height * maxWidth) / width;&#10;          width = maxWidth;&#10;        }&#10;&#10;        if (height &gt; maxHeight) {&#10;          width = (width * maxHeight) / height;&#10;          height = maxHeight;&#10;        }&#10;&#10;        canvas.width = width;&#10;        canvas.height = height;&#10;&#10;        // Draw and compress the image&#10;        ctx.drawImage(img, 0, 0, width, height);&#10;&#10;        canvas.toBlob(&#10;          (blob) =&gt; {&#10;            const reader = new FileReader();&#10;            reader.onload = (e) =&gt; resolve(e.target.result);&#10;            reader.readAsDataURL(blob);&#10;          },&#10;          &quot;image/jpeg&quot;,&#10;          quality,&#10;        );&#10;      };&#10;&#10;      img.src = URL.createObjectURL(file);&#10;    });&#10;  };&#10;&#10;  const handleImageChange = async (e) =&gt; {&#10;    const files = Array.from(e.target.files);&#10;&#10;    // Validate number of files&#10;    if (files.length &gt; 5) {&#10;      alert(&quot;You can upload a maximum of 5 images&quot;);&#10;      return;&#10;    }&#10;&#10;    // Validate each file&#10;    const validFiles = [];&#10;    const previews = [];&#10;    const base64Images = [];&#10;&#10;    for (const file of files) {&#10;      // Validate file type&#10;      if (!file.type.startsWith(&quot;image/&quot;)) {&#10;        alert(`${file.name} is not a valid image file`);&#10;        continue;&#10;      }&#10;&#10;      validFiles.push(file);&#10;      previews.push(URL.createObjectURL(file));&#10;&#10;      try {&#10;        // Compress large images automatically&#10;        let processedImageData;&#10;&#10;        if (file.size &gt; 2 * 1024 * 1024) {&#10;          // If file is larger than 2MB&#10;          console.log(&#10;            `Compressing large image: ${file.name} (${(file.size / 1024 / 1024).toFixed(2)}MB)`,&#10;          );&#10;          processedImageData = await compressImage(file, 1200, 1200, 0.8);&#10;        } else if (file.size &gt; 1 * 1024 * 1024) {&#10;          // If file is larger than 1MB&#10;          processedImageData = await compressImage(file, 1200, 1200, 0.9);&#10;        } else {&#10;          // For smaller files, just convert to base64 without compression&#10;          const reader = new FileReader();&#10;          processedImageData = await new Promise((resolve) =&gt; {&#10;            reader.onload = (event) =&gt; resolve(event.target.result);&#10;            reader.readAsDataURL(file);&#10;          });&#10;        }&#10;&#10;        base64Images.push(processedImageData);&#10;      } catch (error) {&#10;        console.error(`Error processing image ${file.name}:`, error);&#10;        alert(`Failed to process image ${file.name}. Please try again.`);&#10;      }&#10;    }&#10;&#10;    // Update state with processed images&#10;    setImageFiles(validFiles);&#10;    setImagePreviews(previews);&#10;    setFormData((prev) =&gt; ({&#10;      ...prev,&#10;      images: base64Images,&#10;    }));&#10;  };&#10;&#10;  const removeImage = (index) =&gt; {&#10;    const newPreviews = imagePreviews.filter((_, i) =&gt; i !== index);&#10;    const newFiles = imageFiles.filter((_, i) =&gt; i !== index);&#10;    const newImages = formData.images.filter((_, i) =&gt; i !== index);&#10;&#10;    setImagePreviews(newPreviews);&#10;    setImageFiles(newFiles);&#10;    setFormData((prev) =&gt; ({&#10;      ...prev,&#10;      images: newImages,&#10;    }));&#10;  };&#10;&#10;  const validateForm = () =&gt; {&#10;    if (!formData.name.trim()) {&#10;      alert(&quot;Product name is required&quot;);&#10;      return false;&#10;    }&#10;    if (!formData.category) {&#10;      alert(&quot;Category is required&quot;);&#10;      return false;&#10;    }&#10;    if (!formData.description.trim()) {&#10;      alert(&quot;Description is required&quot;);&#10;      return false;&#10;    }&#10;    if (!formData.price || parseFloat(formData.price) &lt;= 0) {&#10;      alert(&quot;Valid price is required&quot;);&#10;      return false;&#10;    }&#10;    if (!formData.stock || parseInt(formData.stock) &lt; 0) {&#10;      alert(&quot;Valid stock quantity is required&quot;);&#10;      return false;&#10;    }&#10;    if (!formData.unit) {&#10;      alert(&quot;Unit is required&quot;);&#10;      return false;&#10;    }&#10;    return true;&#10;  };&#10;&#10;  const handleSubmit = async (e) =&gt; {&#10;    e.preventDefault();&#10;&#10;    if (!validateForm()) return;&#10;&#10;    setLoading(true);&#10;    try {&#10;      // Use the same user ID logic as in manage page&#10;      const userId = session.user.userId || session.user.id || session.user._id;&#10;      const userEmail = session.user.email;&#10;&#10;      const productData = {&#10;        ...formData,&#10;        price: parseFloat(formData.price),&#10;        stock: parseInt(formData.stock),&#10;        farmerId: userId,&#10;        farmerEmail: userEmail,&#10;        farmer: {&#10;          id: userId,&#10;          email: userEmail,&#10;          name: session.user.name,&#10;        },&#10;        status: &quot;active&quot;,&#10;        createdAt: new Date().toISOString(),&#10;        updatedAt: new Date().toISOString(),&#10;        // Keep backward compatibility with single image&#10;        image: formData.images[0] || &quot;&quot;,&#10;      };&#10;&#10;      console.log(&quot;Creating product:&quot;, productData);&#10;&#10;      // Use the addProduct function from hook with optimistic updates&#10;      const result = await addProduct(productData);&#10;&#10;      if (!result.success) {&#10;        throw new Error(&quot;Failed to create product&quot;);&#10;      }&#10;&#10;      alert(&quot;Product added successfully!&quot;);&#10;&#10;      // Reset form&#10;      setFormData({&#10;        name: &quot;&quot;,&#10;        category: &quot;&quot;,&#10;        description: &quot;&quot;,&#10;        price: &quot;&quot;,&#10;        stock: &quot;&quot;,&#10;        unit: &quot;&quot;,&#10;        features: [],&#10;        images: [],&#10;        farmLocation: &quot;&quot;,&#10;        harvestDate: &quot;&quot;,&#10;      });&#10;      setImagePreviews([]);&#10;      setImageFiles([]);&#10;&#10;      // Redirect to manage products page&#10;      router.push(&quot;/manage&quot;);&#10;    } catch (error) {&#10;      console.error(&quot;Error creating product:&quot;, error);&#10;      alert(`Failed to add product: ${error.message || &quot;Please try again.&quot;}`);&#10;    } finally {&#10;      setLoading(false);&#10;    }&#10;  };&#10;&#10;  if (status === &quot;loading&quot;) {&#10;    return (&#10;      &lt;div className=&quot;min-h-screen bg-gray-50 dark:bg-gray-900 flex items-center justify-center&quot;&gt;&#10;        &lt;div className=&quot;text-center&quot;&gt;&#10;          &lt;i className=&quot;fas fa-spinner fa-spin text-4xl text-primary-600 mb-4&quot;&gt;&lt;/i&gt;&#10;          &lt;p className=&quot;text-gray-600 dark:text-gray-400&quot;&gt;Loading...&lt;/p&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;&#10;  return (&#10;    &lt;&gt;&#10;      {/* Breadcrumb */}&#10;      &lt;div className=&quot;max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-4&quot;&gt;&#10;        &lt;nav className=&quot;flex&quot; aria-label=&quot;Breadcrumb&quot;&gt;&#10;          &lt;ol className=&quot;flex items-center space-x-2 text-sm&quot;&gt;&#10;            &lt;li&gt;&#10;              &lt;Link href=&quot;/&quot; className=&quot;text-gray-500 hover:text-primary-600&quot;&gt;&#10;                Home&#10;              &lt;/Link&gt;&#10;            &lt;/li&gt;&#10;            &lt;li&gt;&#10;              &lt;i className=&quot;fas fa-chevron-right text-gray-400 text-xs&quot;&gt;&lt;/i&gt;&#10;            &lt;/li&gt;&#10;            &lt;li&gt;&#10;              &lt;Link&#10;                href=&quot;/manage&quot;&#10;                className=&quot;text-gray-500 hover:text-primary-600&quot;&#10;              &gt;&#10;                Manage Products&#10;              &lt;/Link&gt;&#10;            &lt;/li&gt;&#10;            &lt;li&gt;&#10;              &lt;i className=&quot;fas fa-chevron-right text-gray-400 text-xs&quot;&gt;&lt;/i&gt;&#10;            &lt;/li&gt;&#10;            &lt;li className=&quot;text-gray-900 dark:text-white&quot;&gt;Add Product&lt;/li&gt;&#10;          &lt;/ol&gt;&#10;        &lt;/nav&gt;&#10;      &lt;/div&gt;&#10;&#10;      {/* Add Product Form */}&#10;      &lt;div className=&quot;max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-8&quot;&gt;&#10;        &lt;div className=&quot;bg-white dark:bg-gray-800 rounded-2xl shadow-lg overflow-hidden&quot;&gt;&#10;          {/* Header */}&#10;          &lt;div className=&quot;bg-primary-600 text-white px-8 py-6&quot;&gt;&#10;            &lt;h1 className=&quot;text-3xl font-bold&quot;&gt;Add New Product&lt;/h1&gt;&#10;            &lt;p className=&quot;text-primary-100 mt-2&quot;&gt;&#10;              Share your fresh produce with customers&#10;            &lt;/p&gt;&#10;          &lt;/div&gt;&#10;&#10;          {/* Form */}&#10;          &lt;form onSubmit={handleSubmit} className=&quot;p-8 space-y-8&quot;&gt;&#10;            {/* Basic Information */}&#10;            &lt;div&gt;&#10;              &lt;h2 className=&quot;text-xl font-semibold text-gray-900 dark:text-white mb-4&quot;&gt;&#10;                Basic Information&#10;              &lt;/h2&gt;&#10;              &lt;div className=&quot;grid grid-cols-1 md:grid-cols-2 gap-6&quot;&gt;&#10;                &lt;div&gt;&#10;                  &lt;label&#10;                    htmlFor=&quot;name&quot;&#10;                    className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&#10;                  &gt;&#10;                    Product Name *&#10;                  &lt;/label&gt;&#10;                  &lt;input&#10;                    type=&quot;text&quot;&#10;                    id=&quot;name&quot;&#10;                    name=&quot;name&quot;&#10;                    value={formData.name}&#10;                    onChange={handleInputChange}&#10;                    required&#10;                    className=&quot;w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-transparent dark:bg-gray-700 dark:text-white&quot;&#10;                    placeholder=&quot;e.g., Fresh Tomatoes&quot;&#10;                  /&gt;&#10;                &lt;/div&gt;&#10;&#10;                &lt;div&gt;&#10;                  &lt;label&#10;                    htmlFor=&quot;category&quot;&#10;                    className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&#10;                  &gt;&#10;                    Category *&#10;                  &lt;/label&gt;&#10;                  &lt;select&#10;                    id=&quot;category&quot;&#10;                    name=&quot;category&quot;&#10;                    value={formData.category}&#10;                    onChange={handleInputChange}&#10;                    required&#10;                    className=&quot;w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-transparent dark:bg-gray-700 dark:text-white&quot;&#10;                  &gt;&#10;                    &lt;option value=&quot;&quot;&gt;Select Category&lt;/option&gt;&#10;                    &lt;option value=&quot;Vegetables&quot;&gt;Vegetables&lt;/option&gt;&#10;                    &lt;option value=&quot;Fruits&quot;&gt;Fruits&lt;/option&gt;&#10;                    &lt;option value=&quot;Grains&quot;&gt;Grains&lt;/option&gt;&#10;                    &lt;option value=&quot;Dairy&quot;&gt;Dairy&lt;/option&gt;&#10;                    &lt;option value=&quot;Herbs&quot;&gt;Herbs&lt;/option&gt;&#10;                    &lt;option value=&quot;Honey&quot;&gt;Honey&lt;/option&gt;&#10;                  &lt;/select&gt;&#10;                &lt;/div&gt;&#10;&#10;                &lt;div className=&quot;md:col-span-2&quot;&gt;&#10;                  &lt;label&#10;                    htmlFor=&quot;description&quot;&#10;                    className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&#10;                  &gt;&#10;                    Description *&#10;                  &lt;/label&gt;&#10;                  &lt;textarea&#10;                    id=&quot;description&quot;&#10;                    name=&quot;description&quot;&#10;                    rows={4}&#10;                    value={formData.description}&#10;                    onChange={handleInputChange}&#10;                    required&#10;                    className=&quot;w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-transparent dark:bg-gray-700 dark:text-white&quot;&#10;                    placeholder=&quot;Describe your product, growing methods, quality, etc.&quot;&#10;                  /&gt;&#10;                &lt;/div&gt;&#10;              &lt;/div&gt;&#10;            &lt;/div&gt;&#10;&#10;            {/* Pricing &amp; Inventory */}&#10;            &lt;div&gt;&#10;              &lt;h2 className=&quot;text-xl font-semibold text-gray-900 dark:text-white mb-4&quot;&gt;&#10;                Pricing &amp; Inventory&#10;              &lt;/h2&gt;&#10;              &lt;div className=&quot;grid grid-cols-1 md:grid-cols-3 gap-6&quot;&gt;&#10;                &lt;div&gt;&#10;                  &lt;label&#10;                    htmlFor=&quot;price&quot;&#10;                    className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&#10;                  &gt;&#10;                    Price per Unit (৳) *&#10;                  &lt;/label&gt;&#10;                  &lt;input&#10;                    type=&quot;number&quot;&#10;                    id=&quot;price&quot;&#10;                    name=&quot;price&quot;&#10;                    min=&quot;0&quot;&#10;                    step=&quot;0.01&quot;&#10;                    value={formData.price}&#10;                    onChange={handleInputChange}&#10;                    required&#10;                    className=&quot;w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-transparent dark:bg-gray-700 dark:text-white&quot;&#10;                    placeholder=&quot;45.00&quot;&#10;                  /&gt;&#10;                &lt;/div&gt;&#10;&#10;                &lt;div&gt;&#10;                  &lt;label&#10;                    htmlFor=&quot;unit&quot;&#10;                    className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&#10;                  &gt;&#10;                    Unit *&#10;                  &lt;/label&gt;&#10;                  &lt;select&#10;                    id=&quot;unit&quot;&#10;                    name=&quot;unit&quot;&#10;                    value={formData.unit}&#10;                    onChange={handleInputChange}&#10;                    required&#10;                    className=&quot;w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-transparent dark:bg-gray-700 dark:text-white&quot;&#10;                  &gt;&#10;                    &lt;option value=&quot;&quot;&gt;Select Unit&lt;/option&gt;&#10;                    &lt;option value=&quot;kg&quot;&gt;Kilogram (kg)&lt;/option&gt;&#10;                    &lt;option value=&quot;g&quot;&gt;Gram (g)&lt;/option&gt;&#10;                    &lt;option value=&quot;piece&quot;&gt;Piece&lt;/option&gt;&#10;                    &lt;option value=&quot;bunch&quot;&gt;Bunch&lt;/option&gt;&#10;                    &lt;option value=&quot;liter&quot;&gt;Liter&lt;/option&gt;&#10;                    &lt;option value=&quot;ml&quot;&gt;Milliliter (ml)&lt;/option&gt;&#10;                    &lt;option value=&quot;dozen&quot;&gt;Dozen&lt;/option&gt;&#10;                    &lt;option value=&quot;bundle&quot;&gt;Bundle&lt;/option&gt;&#10;                  &lt;/select&gt;&#10;                &lt;/div&gt;&#10;&#10;                &lt;div&gt;&#10;                  &lt;label&#10;                    htmlFor=&quot;stock&quot;&#10;                    className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&#10;                  &gt;&#10;                    Available Stock *&#10;                  &lt;/label&gt;&#10;                  &lt;input&#10;                    type=&quot;number&quot;&#10;                    id=&quot;stock&quot;&#10;                    name=&quot;stock&quot;&#10;                    min=&quot;0&quot;&#10;                    step=&quot;1&quot;&#10;                    value={formData.stock}&#10;                    onChange={handleInputChange}&#10;                    onWheel={(e) =&gt; e.target.blur()} // Prevent mouse wheel changes&#10;                    onKeyDown={(e) =&gt; {&#10;                      // Prevent arrow keys from changing the value unintentionally&#10;                      if (e.key === &quot;ArrowUp&quot; || e.key === &quot;ArrowDown&quot;) {&#10;                        e.preventDefault();&#10;                      }&#10;                    }}&#10;                    required&#10;                    className=&quot;w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-transparent dark:bg-gray-700 dark:text-white&quot;&#10;                    placeholder=&quot;100&quot;&#10;                  /&gt;&#10;                &lt;/div&gt;&#10;              &lt;/div&gt;&#10;            &lt;/div&gt;&#10;&#10;            {/* Product Images */}&#10;            &lt;div&gt;&#10;              &lt;h2 className=&quot;text-xl font-semibold text-gray-900 dark:text-white mb-4&quot;&gt;&#10;                Product Images&#10;              &lt;/h2&gt;&#10;              &lt;div className=&quot;space-y-4&quot;&gt;&#10;                &lt;div&gt;&#10;                  &lt;label&#10;                    htmlFor=&quot;images&quot;&#10;                    className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&#10;                  &gt;&#10;                    Upload Images (Max 5 images) *&#10;                  &lt;/label&gt;&#10;                  &lt;div className=&quot;border-2 border-dashed border-gray-300 dark:border-gray-600 rounded-lg p-6 text-center hover:border-primary-500 transition&quot;&gt;&#10;                    &lt;input&#10;                      type=&quot;file&quot;&#10;                      id=&quot;images&quot;&#10;                      name=&quot;images&quot;&#10;                      multiple&#10;                      accept=&quot;image/*&quot;&#10;                      onChange={handleImageChange}&#10;                      className=&quot;hidden&quot;&#10;                    /&gt;&#10;                    &lt;label htmlFor=&quot;images&quot; className=&quot;cursor-pointer&quot;&gt;&#10;                      &lt;i className=&quot;fas fa-cloud-upload-alt text-4xl text-gray-400 mb-4&quot;&gt;&lt;/i&gt;&#10;                      &lt;p className=&quot;text-lg font-medium text-gray-900 dark:text-white&quot;&gt;&#10;                        Click to upload images&#10;                      &lt;/p&gt;&#10;                      &lt;p className=&quot;text-sm text-gray-500 dark:text-gray-400&quot;&gt;&#10;                        PNG, JPG, WebP - Large images will be automatically&#10;                        optimized&#10;                      &lt;/p&gt;&#10;                    &lt;/label&gt;&#10;                  &lt;/div&gt;&#10;&#10;                  {/* Image Previews */}&#10;                  {imagePreviews.length &gt; 0 &amp;&amp; (&#10;                    &lt;div className=&quot;mt-4&quot;&gt;&#10;                      &lt;p className=&quot;text-sm font-medium text-gray-700 dark:text-gray-300 mb-3&quot;&gt;&#10;                        Selected Images ({imagePreviews.length}/5)&#10;                      &lt;/p&gt;&#10;                      &lt;div className=&quot;grid grid-cols-2 md:grid-cols-5 gap-4&quot;&gt;&#10;                        {imagePreviews.map((preview, index) =&gt; (&#10;                          &lt;div&#10;                            key={index}&#10;                            className=&quot;relative group rounded-lg overflow-hidden bg-gray-100 dark:bg-gray-700&quot;&#10;                          &gt;&#10;                            &lt;Image&#10;                              src={preview}&#10;                              alt={`Product Image ${index + 1}`}&#10;                              width={200}&#10;                              height={150}&#10;                              className=&quot;w-full h-24 object-cover group-hover:scale-105 transition-transform duration-200&quot;&#10;                            /&gt;&#10;                            &lt;div className=&quot;absolute inset-0 bg-black bg-opacity-0 group-hover:bg-opacity-30 transition-opacity duration-200 flex items-center justify-center&quot;&gt;&#10;                              &lt;button&#10;                                type=&quot;button&quot;&#10;                                onClick={() =&gt; removeImage(index)}&#10;                                className=&quot;opacity-0 group-hover:opacity-100 bg-red-500 hover:bg-red-600 text-white rounded-full w-8 h-8 flex items-center justify-center transition-all duration-200 shadow-lg&quot;&#10;                                title=&quot;Remove image&quot;&#10;                              &gt;&#10;                                &lt;i className=&quot;fas fa-times text-sm&quot;&gt;&lt;/i&gt;&#10;                              &lt;/button&gt;&#10;                            &lt;/div&gt;&#10;                            &lt;div className=&quot;absolute bottom-1 left-1 bg-black bg-opacity-70 text-white text-xs px-1 py-0.5 rounded&quot;&gt;&#10;                              {index + 1}&#10;                            &lt;/div&gt;&#10;                          &lt;/div&gt;&#10;                        ))}&#10;&#10;                        {/* Add more images placeholder */}&#10;                        {imagePreviews.length &lt; 5 &amp;&amp; (&#10;                          &lt;div&#10;                            className=&quot;border-2 border-dashed border-gray-300 dark:border-gray-600 rounded-lg h-24 flex items-center justify-center cursor-pointer hover:border-primary-500 transition-colors&quot;&#10;                            onClick={() =&gt;&#10;                              document.getElementById(&quot;images&quot;).click()&#10;                            }&#10;                          &gt;&#10;                            &lt;div className=&quot;text-center&quot;&gt;&#10;                              &lt;i className=&quot;fas fa-plus text-gray-400 text-xl mb-1&quot;&gt;&lt;/i&gt;&#10;                              &lt;p className=&quot;text-xs text-gray-500 dark:text-gray-400&quot;&gt;&#10;                                Add More&#10;                              &lt;/p&gt;&#10;                            &lt;/div&gt;&#10;                          &lt;/div&gt;&#10;                        )}&#10;                      &lt;/div&gt;&#10;                    &lt;/div&gt;&#10;                  )}&#10;                &lt;/div&gt;&#10;              &lt;/div&gt;&#10;            &lt;/div&gt;&#10;&#10;            {/* Farm Information */}&#10;            &lt;div&gt;&#10;              &lt;h2 className=&quot;text-xl font-semibold text-gray-900 dark:text-white mb-4&quot;&gt;&#10;                Farm Information&#10;              &lt;/h2&gt;&#10;              &lt;div className=&quot;grid grid-cols-1 md:grid-cols-2 gap-6&quot;&gt;&#10;                &lt;div&gt;&#10;                  &lt;label&#10;                    htmlFor=&quot;farmLocation&quot;&#10;                    className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&#10;                  &gt;&#10;                    Farm Location&#10;                  &lt;/label&gt;&#10;                  &lt;input&#10;                    type=&quot;text&quot;&#10;                    id=&quot;farmLocation&quot;&#10;                    name=&quot;farmLocation&quot;&#10;                    value={formData.farmLocation}&#10;                    onChange={handleInputChange}&#10;                    className=&quot;w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-transparent dark:bg-gray-700 dark:text-white&quot;&#10;                    placeholder=&quot;e.g., Sylhet, Bangladesh&quot;&#10;                  /&gt;&#10;                &lt;/div&gt;&#10;&#10;                &lt;div&gt;&#10;                  &lt;label&#10;                    htmlFor=&quot;harvestDate&quot;&#10;                    className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&#10;                  &gt;&#10;                    Harvest Date&#10;                  &lt;/label&gt;&#10;                  &lt;input&#10;                    type=&quot;date&quot;&#10;                    id=&quot;harvestDate&quot;&#10;                    name=&quot;harvestDate&quot;&#10;                    value={formData.harvestDate}&#10;                    onChange={handleInputChange}&#10;                    className=&quot;w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-transparent dark:bg-gray-700 dark:text-white&quot;&#10;                  /&gt;&#10;                &lt;/div&gt;&#10;              &lt;/div&gt;&#10;            &lt;/div&gt;&#10;&#10;            {/* Product Features */}&#10;            &lt;div&gt;&#10;              &lt;h2 className=&quot;text-xl font-semibold text-gray-900 dark:text-white mb-4&quot;&gt;&#10;                Product Features&#10;              &lt;/h2&gt;&#10;              &lt;div className=&quot;grid grid-cols-2 md:grid-cols-4 gap-4&quot;&gt;&#10;                {[&#10;                  &quot;organic&quot;,&#10;                  &quot;pesticide-free&quot;,&#10;                  &quot;fresh&quot;,&#10;                  &quot;non-gmo&quot;,&#10;                  &quot;local&quot;,&#10;                  &quot;sustainable&quot;,&#10;                  &quot;fair-trade&quot;,&#10;                  &quot;gluten-free&quot;,&#10;                ].map((feature) =&gt; (&#10;                  &lt;label&#10;                    key={feature}&#10;                    className=&quot;flex items-center p-3 border border-gray-300 dark:border-gray-600 rounded-lg cursor-pointer hover:bg-gray-50 dark:hover:bg-gray-700&quot;&#10;                  &gt;&#10;                    &lt;input&#10;                      type=&quot;checkbox&quot;&#10;                      name=&quot;features&quot;&#10;                      value={feature}&#10;                      checked={formData.features.includes(feature)}&#10;                      onChange={handleFeatureChange}&#10;                      className=&quot;rounded border-gray-300 text-primary-600 focus:ring-primary-500&quot;&#10;                    /&gt;&#10;                    &lt;span className=&quot;ml-2 text-sm capitalize&quot;&gt;&#10;                      {feature.replace(&quot;-&quot;, &quot; &quot;)}&#10;                    &lt;/span&gt;&#10;                  &lt;/label&gt;&#10;                ))}&#10;              &lt;/div&gt;&#10;            &lt;/div&gt;&#10;&#10;            {/* Submit Button */}&#10;            &lt;div&gt;&#10;              &lt;button&#10;                type=&quot;submit&quot;&#10;                disabled={loading}&#10;                className={`w-full py-3 rounded-lg font-semibold focus:outline-none focus:ring-2 focus:ring-primary-500 focus:ring-offset-2 transition ${&#10;                  loading&#10;                    ? &quot;bg-gray-400 cursor-not-allowed text-white&quot;&#10;                    : &quot;bg-primary-600 text-white hover:bg-primary-700&quot;&#10;                }`}&#10;              &gt;&#10;                {loading ? (&#10;                  &lt;&gt;&#10;                    &lt;i className=&quot;fas fa-spinner fa-spin mr-2&quot;&gt;&lt;/i&gt;&#10;                    Adding Product...&#10;                  &lt;/&gt;&#10;                ) : (&#10;                  &lt;&gt;&#10;                    &lt;i className=&quot;fas fa-plus mr-2&quot;&gt;&lt;/i&gt;&#10;                    Add Product&#10;                  &lt;/&gt;&#10;                )}&#10;              &lt;/button&gt;&#10;            &lt;/div&gt;&#10;          &lt;/form&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;&#10;      {/* Footer */}&#10;      &lt;Footer /&gt;&#10;    &lt;/&gt;&#10;  );&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/edit/[id]/page.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/edit/[id]/page.js" />
              <option name="originalContent" value="&quot;use client&quot;;&#10;&#10;import { useState, useEffect } from &quot;react&quot;;&#10;import { useSession } from &quot;next-auth/react&quot;;&#10;import { useRouter } from &quot;next/navigation&quot;;&#10;import Link from &quot;next/link&quot;;&#10;import Image from &quot;next/image&quot;;&#10;import Footer from &quot;@/components/Footer&quot;;&#10;import { use } from &quot;react&quot;;&#10;import { useQueryClient } from &quot;@tanstack/react-query&quot;;&#10;import globalCache from &quot;@/lib/cache&quot;;&#10;import { sessionCache } from &quot;@/lib/cache&quot;;&#10;&#10;export default function EditProduct({ params }) {&#10;  const { data: session, status } = useSession();&#10;  const router = useRouter();&#10;  const queryClient = useQueryClient();&#10;  const { id } = use(params); // Fix Next.js 15 params warning&#10;  const [loading, setLoading] = useState(false);&#10;  const [initialLoading, setInitialLoading] = useState(true);&#10;  const [imagePreviews, setImagePreviews] = useState([]);&#10;  const [imageFiles, setImageFiles] = useState([]);&#10;  const [formData, setFormData] = useState({&#10;    name: &quot;&quot;,&#10;    category: &quot;&quot;,&#10;    description: &quot;&quot;,&#10;    price: &quot;&quot;,&#10;    stock: &quot;&quot;,&#10;    unit: &quot;&quot;,&#10;    features: [],&#10;    images: [],&#10;    farmLocation: &quot;&quot;,&#10;    harvestDate: &quot;&quot;,&#10;  });&#10;&#10;  useEffect(() =&gt; {&#10;    if (status === &quot;unauthenticated&quot;) {&#10;      router.push(&quot;/login&quot;);&#10;      return;&#10;    }&#10;&#10;    if (status === &quot;authenticated&quot; &amp;&amp; session?.user) {&#10;      // Check if user is a farmer&#10;      const userType = session.user.userType || session.user.role || &quot;user&quot;;&#10;      if (userType !== &quot;farmer&quot;) {&#10;        router.push(&quot;/&quot;);&#10;        return;&#10;      }&#10;&#10;      // Fetch product data for editing&#10;      if (id) {&#10;        fetchProductForEdit(id);&#10;      }&#10;    }&#10;  }, [session, status, router, id]);&#10;&#10;  const fetchProductForEdit = async (productId) =&gt; {&#10;    try {&#10;      setInitialLoading(true);&#10;      const response = await fetch(`/api/products/${productId}`);&#10;&#10;      if (response.ok) {&#10;        const data = await response.json();&#10;        const product = data.product;&#10;&#10;        // Pre-populate form with existing product data&#10;        setFormData({&#10;          name: product.name || &quot;&quot;,&#10;          category: product.category || &quot;&quot;,&#10;          description: product.description || &quot;&quot;,&#10;          price: product.price?.toString() || &quot;&quot;,&#10;          stock: product.stock?.toString() || &quot;&quot;,&#10;          unit: product.unit || &quot;&quot;,&#10;          features: product.features || [],&#10;          images: product.images || (product.image ? [product.image] : []),&#10;          farmLocation: product.farmLocation || &quot;&quot;,&#10;          harvestDate: product.harvestDate&#10;            ? product.harvestDate.split(&quot;T&quot;)[0]&#10;            : &quot;&quot;,&#10;        });&#10;&#10;        // Set image previews if product has images&#10;        if (product.images &amp;&amp; product.images.length &gt; 0) {&#10;          setImagePreviews(product.images);&#10;        } else if (product.image) {&#10;          setImagePreviews([product.image]);&#10;        }&#10;      } else {&#10;        console.error(&quot;Failed to fetch product for editing&quot;);&#10;        alert(&quot;Failed to load product data. Redirecting to manage products.&quot;);&#10;        router.push(&quot;/manage&quot;);&#10;      }&#10;    } catch (error) {&#10;      console.error(&quot;Error fetching product for edit:&quot;, error);&#10;      alert(&quot;Error loading product data. Redirecting to manage products.&quot;);&#10;      router.push(&quot;/manage&quot;);&#10;    } finally {&#10;      setInitialLoading(false);&#10;    }&#10;  };&#10;&#10;  const handleInputChange = (e) =&gt; {&#10;    const { name, value } = e.target;&#10;    setFormData((prev) =&gt; ({&#10;      ...prev,&#10;      [name]: value,&#10;    }));&#10;  };&#10;&#10;  const handleFeatureChange = (e) =&gt; {&#10;    const { value, checked } = e.target;&#10;    setFormData((prev) =&gt; ({&#10;      ...prev,&#10;      features: checked&#10;        ? [...prev.features, value]&#10;        : prev.features.filter((feature) =&gt; feature !== value),&#10;    }));&#10;  };&#10;&#10;  const handleImageChange = (e) =&gt; {&#10;    const files = Array.from(e.target.files);&#10;&#10;    // Check if adding new images would exceed the limit&#10;    const currentImageCount = imagePreviews.length;&#10;    const newImageCount = files.length;&#10;    const totalImages = currentImageCount + newImageCount;&#10;&#10;    if (totalImages &gt; 5) {&#10;      alert(&#10;        `You can only have a maximum of 5 images. You currently have ${currentImageCount} images. You can add ${5 - currentImageCount} more.`,&#10;      );&#10;      return;&#10;    }&#10;&#10;    // Validate each file&#10;    const validFiles = [];&#10;    const newPreviews = [];&#10;    const newBase64Images = [];&#10;&#10;    files.forEach((file) =&gt; {&#10;      // Validate file size (max 5MB)&#10;      if (file.size &gt; 5 * 1024 * 1024) {&#10;        alert(`Image ${file.name} is too large. Maximum size is 5MB`);&#10;        return;&#10;      }&#10;&#10;      // Validate file type&#10;      if (!file.type.startsWith(&quot;image/&quot;)) {&#10;        alert(`${file.name} is not a valid image file`);&#10;        return;&#10;      }&#10;&#10;      validFiles.push(file);&#10;      newPreviews.push(URL.createObjectURL(file));&#10;&#10;      // Convert image to base64 for storage&#10;      const reader = new FileReader();&#10;      reader.onload = (event) =&gt; {&#10;        newBase64Images.push(event.target.result);&#10;&#10;        // When all files are processed, append to existing images&#10;        if (newBase64Images.length === validFiles.length) {&#10;          setFormData((prev) =&gt; ({&#10;            ...prev,&#10;            images: [...prev.images, ...newBase64Images], // Append to existing&#10;          }));&#10;        }&#10;      };&#10;      reader.readAsDataURL(file);&#10;    });&#10;&#10;    // Append new files and previews to existing ones&#10;    setImageFiles((prev) =&gt; [...prev, ...validFiles]);&#10;    setImagePreviews((prev) =&gt; [...prev, ...newPreviews]);&#10;  };&#10;&#10;  const removeImage = (index) =&gt; {&#10;    const newPreviews = imagePreviews.filter((_, i) =&gt; i !== index);&#10;    const newFiles = imageFiles.filter((_, i) =&gt; i !== index);&#10;    const newImages = formData.images.filter((_, i) =&gt; i !== index);&#10;&#10;    setImagePreviews(newPreviews);&#10;    setImageFiles(newFiles);&#10;    setFormData((prev) =&gt; ({&#10;      ...prev,&#10;      images: newImages,&#10;    }));&#10;  };&#10;&#10;  const validateForm = () =&gt; {&#10;    if (!formData.name.trim()) {&#10;      alert(&quot;Product name is required&quot;);&#10;      return false;&#10;    }&#10;    if (!formData.category) {&#10;      alert(&quot;Category is required&quot;);&#10;      return false;&#10;    }&#10;    if (!formData.description.trim()) {&#10;      alert(&quot;Description is required&quot;);&#10;      return false;&#10;    }&#10;    if (!formData.price || parseFloat(formData.price) &lt;= 0) {&#10;      alert(&quot;Valid price is required&quot;);&#10;      return false;&#10;    }&#10;    if (!formData.stock || parseInt(formData.stock) &lt; 0) {&#10;      alert(&quot;Valid stock quantity is required&quot;);&#10;      return false;&#10;    }&#10;    if (!formData.unit) {&#10;      alert(&quot;Unit is required&quot;);&#10;      return false;&#10;    }&#10;    return true;&#10;  };&#10;&#10;  const handleSubmit = async (e) =&gt; {&#10;    e.preventDefault();&#10;&#10;    if (!validateForm()) return;&#10;&#10;    setLoading(true);&#10;    try {&#10;      // Use the same user ID logic as in manage page&#10;      const userId = session.user.userId || session.user.id || session.user._id;&#10;      const userEmail = session.user.email;&#10;&#10;      const productData = {&#10;        ...formData,&#10;        price: parseFloat(formData.price),&#10;        stock: parseInt(formData.stock),&#10;        farmerId: userId,&#10;        farmerEmail: userEmail,&#10;        farmer: {&#10;          id: userId,&#10;          email: userEmail,&#10;          name: session.user.name,&#10;        },&#10;        status: &quot;active&quot;,&#10;        updatedAt: new Date().toISOString(),&#10;        // Keep backward compatibility with single image&#10;        image: formData.images[0] || &quot;&quot;,&#10;      };&#10;&#10;      console.log(&#10;        &quot; [Edit] Starting product update with optimistic strategy...&quot;,&#10;      );&#10;      console.log(&quot; [Edit] Product data:&quot;, productData);&#10;&#10;      // OPTIMISTIC UPDATE: Apply changes to cache immediately (same as bulk update)&#10;      const userIds = {&#10;        userId: session.user.userId || session.user.id || session.user._id,&#10;        userEmail: session.user.email,&#10;      };&#10;&#10;      console.log(&quot; [Edit] Applying optimistic cache update...&quot;);&#10;      queryClient.setQueryData(&#10;        [&quot;dashboard&quot;, userIds.userId, userIds.userEmail],&#10;        (oldData) =&gt; {&#10;          if (!oldData) return oldData;&#10;&#10;          const updatedProducts = oldData.products.map((product) =&gt; {&#10;            return product._id === id || product.id === id&#10;              ? { ...product, ...productData }&#10;              : product;&#10;          });&#10;&#10;          console.log(&quot;✅ [Edit] Optimistic update applied to dashboard cache&quot;);&#10;          return {&#10;            ...oldData,&#10;            products: updatedProducts,&#10;          };&#10;        },&#10;      );&#10;&#10;      // Also update other product queries optimistically&#10;      queryClient.setQueryData([&quot;products&quot;], (oldData) =&gt; {&#10;        if (!oldData?.products) return oldData;&#10;&#10;        const updatedProducts = oldData.products.map((product) =&gt; {&#10;          return product._id === id || product.id === id&#10;            ? { ...product, ...productData }&#10;            : product;&#10;        });&#10;&#10;        console.log(&quot;✅ [Edit] Optimistic update applied to products cache&quot;);&#10;        return {&#10;          ...oldData,&#10;          products: updatedProducts,&#10;        };&#10;      });&#10;&#10;      console.log(&quot; [Edit] Making API call...&quot;);&#10;      const response = await fetch(`/api/products/${id}`, {&#10;        method: &quot;PUT&quot;,&#10;        headers: {&#10;          &quot;Content-Type&quot;: &quot;application/json&quot;,&#10;        },&#10;        body: JSON.stringify(productData),&#10;      });&#10;&#10;      if (response.ok) {&#10;        const result = await response.json();&#10;        console.log(&quot;✅ [Edit] Product updated successfully:&quot;, result);&#10;&#10;        alert(&quot;Product updated successfully!&quot;);&#10;&#10;        // CRITICAL FIX: Only clear API service cache patterns, not all cache&#10;        // This preserves our optimistic updates while preventing stale API data&#10;        console.log(&quot; [Edit] Clearing API service cache patterns only...&quot;);&#10;&#10;        try {&#10;          // Clear specific patterns instead of all cache&#10;          globalCache.clearPattern(&quot;products&quot;);&#10;          globalCache.clearPattern(&quot;product&quot;);&#10;          globalCache.clearPattern(&quot;dashboard&quot;);&#10;          globalCache.clearPattern(&quot;farmers&quot;);&#10;&#10;          sessionCache.clearPattern(&quot;products&quot;);&#10;          sessionCache.clearPattern(&quot;product&quot;);&#10;          sessionCache.clearPattern(&quot;dashboard&quot;);&#10;          sessionCache.clearPattern(&quot;farmers&quot;);&#10;&#10;          // Clear browser storage&#10;          if (typeof window !== &quot;undefined&quot;) {&#10;            sessionStorage.removeItem(&quot;products-cache&quot;);&#10;            sessionStorage.removeItem(&quot;dashboard-cache&quot;);&#10;            sessionStorage.removeItem(&quot;farmfresh-products&quot;);&#10;            sessionStorage.removeItem(&quot;farmfresh-dashboard&quot;);&#10;          }&#10;        } catch (cacheError) {&#10;          console.warn(&quot;Cache clearing warning:&quot;, cacheError);&#10;        }&#10;&#10;        console.log(&#10;          &quot; [Edit] API update completed, starting immediate cache refresh...&quot;,&#10;        );&#10;&#10;        // FIXED: Use immediate invalidation instead of delayed (same as bulk update fix)&#10;        console.log(&quot; [Edit] Starting immediate cache refresh...&quot;);&#10;&#10;        // Immediate invalidation that forces refetch for products page&#10;        queryClient.invalidateQueries({&#10;          queryKey: [&quot;products&quot;],&#10;          exact: false,&#10;          refetchType: &quot;active&quot;, // Force immediate refetch&#10;        });&#10;&#10;        console.log(&quot;✅ [Edit] Immediate cache invalidation completed&quot;);&#10;&#10;        console.log(&quot;✅ [Edit] Product update completed successfully&quot;);&#10;&#10;        // Redirect to manage products page&#10;        router.push(&quot;/manage&quot;);&#10;      } else {&#10;        const errorData = await response.json();&#10;        console.error(&quot;❌ [Edit] Failed to update product:&quot;, errorData);&#10;&#10;        // Revert optimistic updates on error (same as bulk update)&#10;        console.log(&#10;          &quot; [Edit] Reverting optimistic updates due to API error...&quot;,&#10;        );&#10;        queryClient.invalidateQueries({&#10;          queryKey: [&quot;dashboard&quot;, userIds.userId, userIds.userEmail],&#10;          exact: true,&#10;        });&#10;        queryClient.invalidateQueries({&#10;          queryKey: [&quot;products&quot;],&#10;          exact: false,&#10;        });&#10;&#10;        alert(&#10;          `Failed to update product: ${errorData.error || &quot;Unknown error&quot;}`,&#10;        );&#10;      }&#10;    } catch (error) {&#10;      console.error(&quot;❌ [Edit] Error updating product:&quot;, error);&#10;&#10;      // Revert optimistic updates on error&#10;      const userIds = {&#10;        userId: session.user.userId || session.user.id || session.user._id,&#10;        userEmail: session.user.email,&#10;      };&#10;&#10;      console.log(&quot; [Edit] Reverting optimistic updates due to error...&quot;);&#10;      queryClient.invalidateQueries({&#10;        queryKey: [&quot;dashboard&quot;, userIds.userId, userIds.userEmail],&#10;        exact: true,&#10;      });&#10;      queryClient.invalidateQueries({&#10;        queryKey: [&quot;products&quot;],&#10;        exact: false,&#10;      });&#10;&#10;      alert(&quot;Failed to update product. Please try again.&quot;);&#10;    } finally {&#10;      setLoading(false);&#10;    }&#10;  };&#10;&#10;  if (status === &quot;loading&quot; || initialLoading) {&#10;    return (&#10;      &lt;div className=&quot;min-h-screen bg-gray-50 dark:bg-gray-900 flex items-center justify-center&quot;&gt;&#10;        &lt;div className=&quot;text-center&quot;&gt;&#10;          &lt;i className=&quot;fas fa-spinner fa-spin text-4xl text-primary-600 mb-4&quot;&gt;&lt;/i&gt;&#10;          &lt;p className=&quot;text-gray-600 dark:text-gray-400&quot;&gt;&#10;            Loading product data...&#10;          &lt;/p&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;&#10;  return (&#10;    &lt;&gt;&#10;      {/* Breadcrumb */}&#10;      &lt;div className=&quot;max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-4&quot;&gt;&#10;        &lt;nav className=&quot;flex&quot; aria-label=&quot;Breadcrumb&quot;&gt;&#10;          &lt;ol className=&quot;flex items-center space-x-2 text-sm&quot;&gt;&#10;            &lt;li&gt;&#10;              &lt;Link href=&quot;/&quot; className=&quot;text-gray-500 hover:text-primary-600&quot;&gt;&#10;                Home&#10;              &lt;/Link&gt;&#10;            &lt;/li&gt;&#10;            &lt;li&gt;&#10;              &lt;i className=&quot;fas fa-chevron-right text-gray-400 text-xs&quot;&gt;&lt;/i&gt;&#10;            &lt;/li&gt;&#10;            &lt;li&gt;&#10;              &lt;Link&#10;                href=&quot;/manage&quot;&#10;                className=&quot;text-gray-500 hover:text-primary-600&quot;&#10;              &gt;&#10;                Manage Products&#10;              &lt;/Link&gt;&#10;            &lt;/li&gt;&#10;            &lt;li&gt;&#10;              &lt;i className=&quot;fas fa-chevron-right text-gray-400 text-xs&quot;&gt;&lt;/i&gt;&#10;            &lt;/li&gt;&#10;            &lt;li className=&quot;text-gray-900 dark:text-white&quot;&gt;Edit Product&lt;/li&gt;&#10;          &lt;/ol&gt;&#10;        &lt;/nav&gt;&#10;      &lt;/div&gt;&#10;&#10;      {/* Edit Product Form */}&#10;      &lt;div className=&quot;max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-8&quot;&gt;&#10;        &lt;div className=&quot;bg-white dark:bg-gray-800 rounded-2xl shadow-lg overflow-hidden&quot;&gt;&#10;          {/* Header */}&#10;          &lt;div className=&quot;bg-primary-600 text-white px-8 py-6&quot;&gt;&#10;            &lt;h1 className=&quot;text-3xl font-bold&quot;&gt;Edit Product&lt;/h1&gt;&#10;            &lt;p className=&quot;text-primary-100 mt-2&quot;&gt;&#10;              Update your product information&#10;            &lt;/p&gt;&#10;          &lt;/div&gt;&#10;&#10;          {/* Form */}&#10;          &lt;form onSubmit={handleSubmit} className=&quot;p-8 space-y-8&quot;&gt;&#10;            {/* Basic Information */}&#10;            &lt;div&gt;&#10;              &lt;h2 className=&quot;text-xl font-semibold text-gray-900 dark:text-white mb-4&quot;&gt;&#10;                Basic Information&#10;              &lt;/h2&gt;&#10;              &lt;div className=&quot;grid grid-cols-1 md:grid-cols-2 gap-6&quot;&gt;&#10;                &lt;div&gt;&#10;                  &lt;label&#10;                    htmlFor=&quot;name&quot;&#10;                    className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&#10;                  &gt;&#10;                    Product Name *&#10;                  &lt;/label&gt;&#10;                  &lt;input&#10;                    type=&quot;text&quot;&#10;                    id=&quot;name&quot;&#10;                    name=&quot;name&quot;&#10;                    value={formData.name}&#10;                    onChange={handleInputChange}&#10;                    required&#10;                    className=&quot;w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-transparent dark:bg-gray-700 dark:text-white&quot;&#10;                    placeholder=&quot;e.g., Fresh Tomatoes&quot;&#10;                  /&gt;&#10;                &lt;/div&gt;&#10;&#10;                &lt;div&gt;&#10;                  &lt;label&#10;                    htmlFor=&quot;category&quot;&#10;                    className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&#10;                  &gt;&#10;                    Category *&#10;                  &lt;/label&gt;&#10;                  &lt;select&#10;                    id=&quot;category&quot;&#10;                    name=&quot;category&quot;&#10;                    value={formData.category}&#10;                    onChange={handleInputChange}&#10;                    required&#10;                    className=&quot;w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-transparent dark:bg-gray-700 dark:text-white&quot;&#10;                  &gt;&#10;                    &lt;option value=&quot;&quot;&gt;Select Category&lt;/option&gt;&#10;                    &lt;option value=&quot;Vegetables&quot;&gt;Vegetables&lt;/option&gt;&#10;                    &lt;option value=&quot;Fruits&quot;&gt;Fruits&lt;/option&gt;&#10;                    &lt;option value=&quot;Grains&quot;&gt;Grains&lt;/option&gt;&#10;                    &lt;option value=&quot;Dairy&quot;&gt;Dairy&lt;/option&gt;&#10;                    &lt;option value=&quot;Herbs&quot;&gt;Herbs&lt;/option&gt;&#10;                    &lt;option value=&quot;Honey&quot;&gt;Honey&lt;/option&gt;&#10;                  &lt;/select&gt;&#10;                &lt;/div&gt;&#10;&#10;                &lt;div className=&quot;md:col-span-2&quot;&gt;&#10;                  &lt;label&#10;                    htmlFor=&quot;description&quot;&#10;                    className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&#10;                  &gt;&#10;                    Description *&#10;                  &lt;/label&gt;&#10;                  &lt;textarea&#10;                    id=&quot;description&quot;&#10;                    name=&quot;description&quot;&#10;                    rows={4}&#10;                    value={formData.description}&#10;                    onChange={handleInputChange}&#10;                    required&#10;                    className=&quot;w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-transparent dark:bg-gray-700 dark:text-white&quot;&#10;                    placeholder=&quot;Describe your product, growing methods, quality, etc.&quot;&#10;                  /&gt;&#10;                &lt;/div&gt;&#10;              &lt;/div&gt;&#10;            &lt;/div&gt;&#10;&#10;            {/* Pricing &amp; Inventory */}&#10;            &lt;div&gt;&#10;              &lt;h2 className=&quot;text-xl font-semibold text-gray-900 dark:text-white mb-4&quot;&gt;&#10;                Pricing &amp; Inventory&#10;              &lt;/h2&gt;&#10;              &lt;div className=&quot;grid grid-cols-1 md:grid-cols-3 gap-6&quot;&gt;&#10;                &lt;div&gt;&#10;                  &lt;label&#10;                    htmlFor=&quot;price&quot;&#10;                    className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&#10;                  &gt;&#10;                    Price per Unit (৳) *&#10;                  &lt;/label&gt;&#10;                  &lt;input&#10;                    type=&quot;number&quot;&#10;                    id=&quot;price&quot;&#10;                    name=&quot;price&quot;&#10;                    min=&quot;0&quot;&#10;                    step=&quot;0.01&quot;&#10;                    value={formData.price}&#10;                    onChange={handleInputChange}&#10;                    required&#10;                    className=&quot;w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-transparent dark:bg-gray-700 dark:text-white&quot;&#10;                    placeholder=&quot;45.00&quot;&#10;                  /&gt;&#10;                &lt;/div&gt;&#10;&#10;                &lt;div&gt;&#10;                  &lt;label&#10;                    htmlFor=&quot;unit&quot;&#10;                    className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&#10;                  &gt;&#10;                    Unit *&#10;                  &lt;/label&gt;&#10;                  &lt;select&#10;                    id=&quot;unit&quot;&#10;                    name=&quot;unit&quot;&#10;                    value={formData.unit}&#10;                    onChange={handleInputChange}&#10;                    required&#10;                    className=&quot;w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-transparent dark:bg-gray-700 dark:text-white&quot;&#10;                  &gt;&#10;                    &lt;option value=&quot;&quot;&gt;Select Unit&lt;/option&gt;&#10;                    &lt;option value=&quot;kg&quot;&gt;Kilogram (kg)&lt;/option&gt;&#10;                    &lt;option value=&quot;g&quot;&gt;Gram (g)&lt;/option&gt;&#10;                    &lt;option value=&quot;piece&quot;&gt;Piece&lt;/option&gt;&#10;                    &lt;option value=&quot;bunch&quot;&gt;Bunch&lt;/option&gt;&#10;                    &lt;option value=&quot;liter&quot;&gt;Liter&lt;/option&gt;&#10;                    &lt;option value=&quot;ml&quot;&gt;Milliliter (ml)&lt;/option&gt;&#10;                    &lt;option value=&quot;dozen&quot;&gt;Dozen&lt;/option&gt;&#10;                    &lt;option value=&quot;bundle&quot;&gt;Bundle&lt;/option&gt;&#10;                  &lt;/select&gt;&#10;                &lt;/div&gt;&#10;&#10;                &lt;div&gt;&#10;                  &lt;label&#10;                    htmlFor=&quot;stock&quot;&#10;                    className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&#10;                  &gt;&#10;                    Available Stock *&#10;                  &lt;/label&gt;&#10;                  &lt;input&#10;                    type=&quot;number&quot;&#10;                    id=&quot;stock&quot;&#10;                    name=&quot;stock&quot;&#10;                    min=&quot;0&quot;&#10;                    value={formData.stock}&#10;                    onChange={handleInputChange}&#10;                    required&#10;                    className=&quot;w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-transparent dark:bg-gray-700 dark:text-white&quot;&#10;                    placeholder=&quot;100&quot;&#10;                  /&gt;&#10;                &lt;/div&gt;&#10;              &lt;/div&gt;&#10;            &lt;/div&gt;&#10;&#10;            {/* Product Images */}&#10;            &lt;div&gt;&#10;              &lt;h2 className=&quot;text-xl font-semibold text-gray-900 dark:text-white mb-4&quot;&gt;&#10;                Product Images&#10;              &lt;/h2&gt;&#10;              &lt;div className=&quot;space-y-4&quot;&gt;&#10;                &lt;div&gt;&#10;                  &lt;label&#10;                    htmlFor=&quot;images&quot;&#10;                    className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&#10;                  &gt;&#10;                    Upload Images (Max 5 images)&#10;                  &lt;/label&gt;&#10;                  &lt;div className=&quot;border-2 border-dashed border-gray-300 dark:border-gray-600 rounded-lg p-6 text-center hover:border-primary-500 transition&quot;&gt;&#10;                    &lt;input&#10;                      type=&quot;file&quot;&#10;                      id=&quot;images&quot;&#10;                      name=&quot;images&quot;&#10;                      multiple&#10;                      accept=&quot;image/*&quot;&#10;                      onChange={handleImageChange}&#10;                      className=&quot;hidden&quot;&#10;                    /&gt;&#10;                    &lt;label htmlFor=&quot;images&quot; className=&quot;cursor-pointer&quot;&gt;&#10;                      &lt;i className=&quot;fas fa-cloud-upload-alt text-4xl text-gray-400 mb-4&quot;&gt;&lt;/i&gt;&#10;                      &lt;p className=&quot;text-lg font-medium text-gray-900 dark:text-white&quot;&gt;&#10;                        Click to upload new images&#10;                      &lt;/p&gt;&#10;                      &lt;p className=&quot;text-sm text-gray-500 dark:text-gray-400&quot;&gt;&#10;                        PNG, JPG, WebP up to 5MB each&#10;                      &lt;/p&gt;&#10;                    &lt;/label&gt;&#10;                  &lt;/div&gt;&#10;&#10;                  {/* Image Previews */}&#10;                  {imagePreviews.length &gt; 0 &amp;&amp; (&#10;                    &lt;div className=&quot;mt-4&quot;&gt;&#10;                      &lt;p className=&quot;text-sm font-medium text-gray-700 dark:text-gray-300 mb-3&quot;&gt;&#10;                        Current Images ({imagePreviews.length}/5)&#10;                      &lt;/p&gt;&#10;                      &lt;div className=&quot;grid grid-cols-2 md:grid-cols-5 gap-4&quot;&gt;&#10;                        {imagePreviews.map((preview, index) =&gt; (&#10;                          &lt;div&#10;                            key={index}&#10;                            className=&quot;relative group rounded-lg overflow-hidden bg-gray-100 dark:bg-gray-700&quot;&#10;                          &gt;&#10;                            &lt;Image&#10;                              src={preview}&#10;                              alt={`Product Image ${index + 1}`}&#10;                              width={200}&#10;                              height={150}&#10;                              className=&quot;w-full h-24 object-cover group-hover:scale-105 transition-transform duration-200&quot;&#10;                            /&gt;&#10;                            &lt;div className=&quot;absolute inset-0 bg-black bg-opacity-0 group-hover:bg-opacity-30 transition-opacity duration-200 flex items-center justify-center&quot;&gt;&#10;                              &lt;button&#10;                                type=&quot;button&quot;&#10;                                onClick={() =&gt; removeImage(index)}&#10;                                className=&quot;opacity-0 group-hover:opacity-100 bg-red-500 hover:bg-red-600 text-white rounded-full w-8 h-8 flex items-center justify-center transition-all duration-200 shadow-lg&quot;&#10;                                title=&quot;Remove image&quot;&#10;                              &gt;&#10;                                &lt;i className=&quot;fas fa-times text-sm&quot;&gt;&lt;/i&gt;&#10;                              &lt;/button&gt;&#10;                            &lt;/div&gt;&#10;                            &lt;div className=&quot;absolute bottom-1 left-1 bg-black bg-opacity-70 text-white text-xs px-1 py-0.5 rounded&quot;&gt;&#10;                              {index + 1}&#10;                            &lt;/div&gt;&#10;                          &lt;/div&gt;&#10;                        ))}&#10;&#10;                        {/* Add more images placeholder */}&#10;                        {imagePreviews.length &lt; 5 &amp;&amp; (&#10;                          &lt;div&#10;                            className=&quot;border-2 border-dashed border-gray-300 dark:border-gray-600 rounded-lg h-24 flex items-center justify-center cursor-pointer hover:border-primary-500 transition-colors&quot;&#10;                            onClick={() =&gt;&#10;                              document.getElementById(&quot;images&quot;).click()&#10;                            }&#10;                          &gt;&#10;                            &lt;div className=&quot;text-center&quot;&gt;&#10;                              &lt;i className=&quot;fas fa-plus text-gray-400 text-xl mb-1&quot;&gt;&lt;/i&gt;&#10;                              &lt;p className=&quot;text-xs text-gray-500 dark:text-gray-400&quot;&gt;&#10;                                Add More&#10;                              &lt;/p&gt;&#10;                            &lt;/div&gt;&#10;                          &lt;/div&gt;&#10;                        )}&#10;                      &lt;/div&gt;&#10;                    &lt;/div&gt;&#10;                  )}&#10;                &lt;/div&gt;&#10;              &lt;/div&gt;&#10;            &lt;/div&gt;&#10;&#10;            {/* Farm Information */}&#10;            &lt;div&gt;&#10;              &lt;h2 className=&quot;text-xl font-semibold text-gray-900 dark:text-white mb-4&quot;&gt;&#10;                Farm Information&#10;              &lt;/h2&gt;&#10;              &lt;div className=&quot;grid grid-cols-1 md:grid-cols-2 gap-6&quot;&gt;&#10;                &lt;div&gt;&#10;                  &lt;label&#10;                    htmlFor=&quot;farmLocation&quot;&#10;                    className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&#10;                  &gt;&#10;                    Farm Location&#10;                  &lt;/label&gt;&#10;                  &lt;input&#10;                    type=&quot;text&quot;&#10;                    id=&quot;farmLocation&quot;&#10;                    name=&quot;farmLocation&quot;&#10;                    value={formData.farmLocation}&#10;                    onChange={handleInputChange}&#10;                    className=&quot;w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-transparent dark:bg-gray-700 dark:text-white&quot;&#10;                    placeholder=&quot;e.g., Sylhet, Bangladesh&quot;&#10;                  /&gt;&#10;                &lt;/div&gt;&#10;&#10;                &lt;div&gt;&#10;                  &lt;label&#10;                    htmlFor=&quot;harvestDate&quot;&#10;                    className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&#10;                  &gt;&#10;                    Harvest Date&#10;                  &lt;/label&gt;&#10;                  &lt;input&#10;                    type=&quot;date&quot;&#10;                    id=&quot;harvestDate&quot;&#10;                    name=&quot;harvestDate&quot;&#10;                    value={formData.harvestDate}&#10;                    onChange={handleInputChange}&#10;                    className=&quot;w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-transparent dark:bg-gray-700 dark:text-white&quot;&#10;                  /&gt;&#10;                &lt;/div&gt;&#10;              &lt;/div&gt;&#10;            &lt;/div&gt;&#10;&#10;            {/* Product Features */}&#10;            &lt;div&gt;&#10;              &lt;h2 className=&quot;text-xl font-semibold text-gray-900 dark:text-white mb-4&quot;&gt;&#10;                Product Features&#10;              &lt;/h2&gt;&#10;              &lt;div className=&quot;grid grid-cols-2 md:grid-cols-4 gap-4&quot;&gt;&#10;                {[&#10;                  &quot;organic&quot;,&#10;                  &quot;pesticide-free&quot;,&#10;                  &quot;fresh&quot;,&#10;                  &quot;non-gmo&quot;,&#10;                  &quot;local&quot;,&#10;                  &quot;sustainable&quot;,&#10;                  &quot;fair-trade&quot;,&#10;                  &quot;gluten-free&quot;,&#10;                ].map((feature) =&gt; (&#10;                  &lt;label&#10;                    key={feature}&#10;                    className=&quot;flex items-center p-3 border border-gray-300 dark:border-gray-600 rounded-lg cursor-pointer hover:bg-gray-50 dark:hover:bg-gray-700&quot;&#10;                  &gt;&#10;                    &lt;input&#10;                      type=&quot;checkbox&quot;&#10;                      name=&quot;features&quot;&#10;                      value={feature}&#10;                      checked={formData.features.includes(feature)}&#10;                      onChange={handleFeatureChange}&#10;                      className=&quot;rounded border-gray-300 text-primary-600 focus:ring-primary-500&quot;&#10;                    /&gt;&#10;                    &lt;span className=&quot;ml-2 text-sm capitalize&quot;&gt;&#10;                      {feature.replace(&quot;-&quot;, &quot; &quot;)}&#10;                    &lt;/span&gt;&#10;                  &lt;/label&gt;&#10;                ))}&#10;              &lt;/div&gt;&#10;            &lt;/div&gt;&#10;&#10;            {/* Submit Button */}&#10;            &lt;div className=&quot;flex space-x-4&quot;&gt;&#10;              &lt;Link&#10;                href=&quot;/manage&quot;&#10;                className=&quot;flex-1 py-3 px-6 border border-gray-300 dark:border-gray-600 text-gray-700 dark:text-gray-300 rounded-lg font-semibold text-center hover:bg-gray-50 dark:hover:bg-gray-700 transition&quot;&#10;              &gt;&#10;                &lt;i className=&quot;fas fa-times mr-2&quot;&gt;&lt;/i&gt;&#10;                Cancel&#10;              &lt;/Link&gt;&#10;              &lt;button&#10;                type=&quot;submit&quot;&#10;                disabled={loading}&#10;                className={`flex-1 py-3 rounded-lg font-semibold focus:outline-none focus:ring-2 focus:ring-primary-500 focus:ring-offset-2 transition ${&#10;                  loading&#10;                    ? &quot;bg-gray-400 cursor-not-allowed text-white&quot;&#10;                    : &quot;bg-primary-600 text-white hover:bg-primary-700&quot;&#10;                }`}&#10;              &gt;&#10;                {loading ? (&#10;                  &lt;&gt;&#10;                    &lt;i className=&quot;fas fa-spinner fa-spin mr-2&quot;&gt;&lt;/i&gt;&#10;                    Updating Product...&#10;                  &lt;/&gt;&#10;                ) : (&#10;                  &lt;&gt;&#10;                    &lt;i className=&quot;fas fa-save mr-2&quot;&gt;&lt;/i&gt;&#10;                    Update Product&#10;                  &lt;/&gt;&#10;                )}&#10;              &lt;/button&gt;&#10;            &lt;/div&gt;&#10;          &lt;/form&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;&#10;      {/* Footer */}&#10;      &lt;Footer /&gt;&#10;    &lt;/&gt;&#10;  );&#10;}&#10;" />
              <option name="updatedContent" value="&quot;use client&quot;;&#10;&#10;import { useState, useEffect } from &quot;react&quot;;&#10;import { useSession } from &quot;next-auth/react&quot;;&#10;import { useRouter } from &quot;next/navigation&quot;;&#10;import Link from &quot;next/link&quot;;&#10;import Image from &quot;next/image&quot;;&#10;import Footer from &quot;@/components/Footer&quot;;&#10;import { use } from &quot;react&quot;;&#10;import { useQueryClient } from &quot;@tanstack/react-query&quot;;&#10;import globalCache from &quot;@/lib/cache&quot;;&#10;import { sessionCache } from &quot;@/lib/cache&quot;;&#10;&#10;export default function EditProduct({ params }) {&#10;  const { data: session, status } = useSession();&#10;  const router = useRouter();&#10;  const queryClient = useQueryClient();&#10;  const { id } = use(params); // Fix Next.js 15 params warning&#10;  const [loading, setLoading] = useState(false);&#10;  const [initialLoading, setInitialLoading] = useState(true);&#10;  const [imagePreviews, setImagePreviews] = useState([]);&#10;  const [imageFiles, setImageFiles] = useState([]);&#10;  const [formData, setFormData] = useState({&#10;    name: &quot;&quot;,&#10;    category: &quot;&quot;,&#10;    description: &quot;&quot;,&#10;    price: &quot;&quot;,&#10;    stock: &quot;&quot;,&#10;    unit: &quot;&quot;,&#10;    features: [],&#10;    images: [],&#10;    farmLocation: &quot;&quot;,&#10;    harvestDate: &quot;&quot;,&#10;  });&#10;&#10;  useEffect(() =&gt; {&#10;    if (status === &quot;unauthenticated&quot;) {&#10;      router.push(&quot;/login&quot;);&#10;      return;&#10;    }&#10;&#10;    if (status === &quot;authenticated&quot; &amp;&amp; session?.user) {&#10;      // Check if user is a farmer&#10;      const userType = session.user.userType || session.user.role || &quot;user&quot;;&#10;      if (userType !== &quot;farmer&quot;) {&#10;        router.push(&quot;/&quot;);&#10;        return;&#10;      }&#10;&#10;      // Fetch product data for editing&#10;      if (id) {&#10;        fetchProductForEdit(id);&#10;      }&#10;    }&#10;  }, [session, status, router, id]);&#10;&#10;  const fetchProductForEdit = async (productId) =&gt; {&#10;    try {&#10;      setInitialLoading(true);&#10;      const response = await fetch(`/api/products/${productId}`);&#10;&#10;      if (response.ok) {&#10;        const data = await response.json();&#10;        const product = data.product;&#10;&#10;        // Pre-populate form with existing product data&#10;        setFormData({&#10;          name: product.name || &quot;&quot;,&#10;          category: product.category || &quot;&quot;,&#10;          description: product.description || &quot;&quot;,&#10;          price: product.price?.toString() || &quot;&quot;,&#10;          stock: product.stock?.toString() || &quot;&quot;,&#10;          unit: product.unit || &quot;&quot;,&#10;          features: product.features || [],&#10;          images: product.images || (product.image ? [product.image] : []),&#10;          farmLocation: product.farmLocation || &quot;&quot;,&#10;          harvestDate: product.harvestDate&#10;            ? product.harvestDate.split(&quot;T&quot;)[0]&#10;            : &quot;&quot;,&#10;        });&#10;&#10;        // Set image previews if product has images&#10;        if (product.images &amp;&amp; product.images.length &gt; 0) {&#10;          setImagePreviews(product.images);&#10;        } else if (product.image) {&#10;          setImagePreviews([product.image]);&#10;        }&#10;      } else {&#10;        console.error(&quot;Failed to fetch product for editing&quot;);&#10;        alert(&quot;Failed to load product data. Redirecting to manage products.&quot;);&#10;        router.push(&quot;/manage&quot;);&#10;      }&#10;    } catch (error) {&#10;      console.error(&quot;Error fetching product for edit:&quot;, error);&#10;      alert(&quot;Error loading product data. Redirecting to manage products.&quot;);&#10;      router.push(&quot;/manage&quot;);&#10;    } finally {&#10;      setInitialLoading(false);&#10;    }&#10;  };&#10;&#10;  const handleInputChange = (e) =&gt; {&#10;    const { name, value } = e.target;&#10;    setFormData((prev) =&gt; ({&#10;      ...prev,&#10;      [name]: value,&#10;    }));&#10;  };&#10;&#10;  const handleFeatureChange = (e) =&gt; {&#10;    const { value, checked } = e.target;&#10;    setFormData((prev) =&gt; ({&#10;      ...prev,&#10;      features: checked&#10;        ? [...prev.features, value]&#10;        : prev.features.filter((feature) =&gt; feature !== value),&#10;    }));&#10;  };&#10;&#10;  const handleImageChange = (e) =&gt; {&#10;    const files = Array.from(e.target.files);&#10;&#10;    // Check if adding new images would exceed the limit&#10;    const currentImageCount = imagePreviews.length;&#10;    const newImageCount = files.length;&#10;    const totalImages = currentImageCount + newImageCount;&#10;&#10;    if (totalImages &gt; 5) {&#10;      alert(&#10;        `You can only have a maximum of 5 images. You currently have ${currentImageCount} images. You can add ${5 - currentImageCount} more.`,&#10;      );&#10;      return;&#10;    }&#10;&#10;    // Validate each file&#10;    const validFiles = [];&#10;    const newPreviews = [];&#10;    const newBase64Images = [];&#10;&#10;    files.forEach((file) =&gt; {&#10;      // Validate file size (max 5MB)&#10;      if (file.size &gt; 5 * 1024 * 1024) {&#10;        alert(`Image ${file.name} is too large. Maximum size is 5MB`);&#10;        return;&#10;      }&#10;&#10;      // Validate file type&#10;      if (!file.type.startsWith(&quot;image/&quot;)) {&#10;        alert(`${file.name} is not a valid image file`);&#10;        return;&#10;      }&#10;&#10;      validFiles.push(file);&#10;      newPreviews.push(URL.createObjectURL(file));&#10;&#10;      // Convert image to base64 for storage&#10;      const reader = new FileReader();&#10;      reader.onload = (event) =&gt; {&#10;        newBase64Images.push(event.target.result);&#10;&#10;        // When all files are processed, append to existing images&#10;        if (newBase64Images.length === validFiles.length) {&#10;          setFormData((prev) =&gt; ({&#10;            ...prev,&#10;            images: [...prev.images, ...newBase64Images], // Append to existing&#10;          }));&#10;        }&#10;      };&#10;      reader.readAsDataURL(file);&#10;    });&#10;&#10;    // Append new files and previews to existing ones&#10;    setImageFiles((prev) =&gt; [...prev, ...validFiles]);&#10;    setImagePreviews((prev) =&gt; [...prev, ...newPreviews]);&#10;  };&#10;&#10;  const removeImage = (index) =&gt; {&#10;    const newPreviews = imagePreviews.filter((_, i) =&gt; i !== index);&#10;    const newFiles = imageFiles.filter((_, i) =&gt; i !== index);&#10;    const newImages = formData.images.filter((_, i) =&gt; i !== index);&#10;&#10;    setImagePreviews(newPreviews);&#10;    setImageFiles(newFiles);&#10;    setFormData((prev) =&gt; ({&#10;      ...prev,&#10;      images: newImages,&#10;    }));&#10;  };&#10;&#10;  const validateForm = () =&gt; {&#10;    if (!formData.name.trim()) {&#10;      alert(&quot;Product name is required&quot;);&#10;      return false;&#10;    }&#10;    if (!formData.category) {&#10;      alert(&quot;Category is required&quot;);&#10;      return false;&#10;    }&#10;    if (!formData.description.trim()) {&#10;      alert(&quot;Description is required&quot;);&#10;      return false;&#10;    }&#10;    if (!formData.price || parseFloat(formData.price) &lt;= 0) {&#10;      alert(&quot;Valid price is required&quot;);&#10;      return false;&#10;    }&#10;    if (!formData.stock || parseInt(formData.stock) &lt; 0) {&#10;      alert(&quot;Valid stock quantity is required&quot;);&#10;      return false;&#10;    }&#10;    if (!formData.unit) {&#10;      alert(&quot;Unit is required&quot;);&#10;      return false;&#10;    }&#10;    return true;&#10;  };&#10;&#10;  const handleSubmit = async (e) =&gt; {&#10;    e.preventDefault();&#10;&#10;    if (!validateForm()) return;&#10;&#10;    setLoading(true);&#10;    try {&#10;      // Use the same user ID logic as in manage page&#10;      const userId = session.user.userId || session.user.id || session.user._id;&#10;      const userEmail = session.user.email;&#10;&#10;      const productData = {&#10;        ...formData,&#10;        price: parseFloat(formData.price),&#10;        stock: parseInt(formData.stock),&#10;        farmerId: userId,&#10;        farmerEmail: userEmail,&#10;        farmer: {&#10;          id: userId,&#10;          email: userEmail,&#10;          name: session.user.name,&#10;        },&#10;        status: &quot;active&quot;,&#10;        updatedAt: new Date().toISOString(),&#10;        // Keep backward compatibility with single image&#10;        image: formData.images[0] || &quot;&quot;,&#10;      };&#10;&#10;      console.log(&#10;        &quot; [Edit] Starting product update with optimistic strategy...&quot;,&#10;      );&#10;      console.log(&quot; [Edit] Product data:&quot;, productData);&#10;&#10;      // OPTIMISTIC UPDATE: Apply changes to cache immediately (same as bulk update)&#10;      const userIds = {&#10;        userId: session.user.userId || session.user.id || session.user._id,&#10;        userEmail: session.user.email,&#10;      };&#10;&#10;      console.log(&quot; [Edit] Applying optimistic cache update...&quot;);&#10;      queryClient.setQueryData(&#10;        [&quot;dashboard&quot;, userIds.userId, userIds.userEmail],&#10;        (oldData) =&gt; {&#10;          if (!oldData) return oldData;&#10;&#10;          const updatedProducts = oldData.products.map((product) =&gt; {&#10;            return product._id === id || product.id === id&#10;              ? { ...product, ...productData }&#10;              : product;&#10;          });&#10;&#10;          console.log(&quot;✅ [Edit] Optimistic update applied to dashboard cache&quot;);&#10;          return {&#10;            ...oldData,&#10;            products: updatedProducts,&#10;          };&#10;        },&#10;      );&#10;&#10;      // Also update other product queries optimistically&#10;      const productsQueryKeys = queryClient.getQueryCache().findAll({&#10;        queryKey: [&quot;products&quot;],&#10;      });&#10;&#10;      productsQueryKeys.forEach((query) =&gt; {&#10;        queryClient.setQueryData(query.queryKey, (oldData) =&gt; {&#10;          if (!oldData?.products) return oldData;&#10;&#10;          const updatedProducts = oldData.products.map((product) =&gt; {&#10;            return product._id === id || product.id === id&#10;              ? { ...product, ...productData }&#10;              : product;&#10;          });&#10;&#10;          console.log(&quot;✅ [Edit] Optimistic update applied to products cache&quot;);&#10;          return {&#10;            ...oldData,&#10;            products: updatedProducts,&#10;          };&#10;        });&#10;      });&#10;&#10;      console.log(&quot; [Edit] Making API call...&quot;);&#10;      const response = await fetch(`/api/products/${id}`, {&#10;        method: &quot;PUT&quot;,&#10;        headers: {&#10;          &quot;Content-Type&quot;: &quot;application/json&quot;,&#10;        },&#10;        body: JSON.stringify(productData),&#10;      });&#10;&#10;      if (response.ok) {&#10;        const result = await response.json();&#10;        console.log(&quot;✅ [Edit] Product updated successfully:&quot;, result);&#10;&#10;        alert(&quot;Product updated successfully!&quot;);&#10;&#10;        // CRITICAL FIX: Only clear API service cache patterns, not all cache&#10;        // This preserves our optimistic updates while preventing stale API data&#10;        console.log(&quot; [Edit] Clearing API service cache patterns only...&quot;);&#10;&#10;        try {&#10;          // Clear specific patterns instead of all cache&#10;          globalCache.clearPattern(&quot;products&quot;);&#10;          globalCache.clearPattern(&quot;product&quot;);&#10;          globalCache.clearPattern(&quot;dashboard&quot;);&#10;          globalCache.clearPattern(&quot;farmers&quot;);&#10;&#10;          sessionCache.clearPattern(&quot;products&quot;);&#10;          sessionCache.clearPattern(&quot;product&quot;);&#10;          sessionCache.clearPattern(&quot;dashboard&quot;);&#10;          sessionCache.clearPattern(&quot;farmers&quot;);&#10;&#10;          // Clear browser storage&#10;          if (typeof window !== &quot;undefined&quot;) {&#10;            sessionStorage.removeItem(&quot;products-cache&quot;);&#10;            sessionStorage.removeItem(&quot;dashboard-cache&quot;);&#10;            sessionStorage.removeItem(&quot;farmfresh-products&quot;);&#10;            sessionStorage.removeItem(&quot;farmfresh-dashboard&quot;);&#10;          }&#10;        } catch (cacheError) {&#10;          console.warn(&quot;Cache clearing warning:&quot;, cacheError);&#10;        }&#10;&#10;        console.log(&#10;          &quot; [Edit] API update completed, starting delayed background refresh...&quot;,&#10;        );&#10;&#10;        // FIXED: Use the same delayed invalidation strategy as bulk update&#10;        setTimeout(async () =&gt; {&#10;          console.log(&quot; [Edit] Starting gentle background cache refresh...&quot;);&#10;&#10;          // Use gentle invalidation that doesn't immediately refetch (same as bulk update)&#10;          queryClient.invalidateQueries({&#10;            queryKey: [&quot;dashboard&quot;, userIds.userId, userIds.userEmail],&#10;            exact: true,&#10;            refetchType: &quot;none&quot;, // Don't refetch immediately - keep optimistic updates&#10;          });&#10;&#10;          queryClient.invalidateQueries({&#10;            queryKey: [&quot;products&quot;],&#10;            exact: false,&#10;            refetchType: &quot;none&quot;, // Don't refetch immediately&#10;          });&#10;&#10;          console.log(&quot;✅ [Edit] Gentle background invalidation completed&quot;);&#10;        }, 5000); // Wait 5 seconds before background sync (same as bulk update)&#10;&#10;        console.log(&quot;✅ [Edit] Product update completed successfully&quot;);&#10;&#10;        // Redirect to manage products page&#10;        router.push(&quot;/manage&quot;);&#10;      } else {&#10;        const errorData = await response.json();&#10;        console.error(&quot;❌ [Edit] Failed to update product:&quot;, errorData);&#10;&#10;        // Revert optimistic updates on error (same as bulk update)&#10;        console.log(&#10;          &quot; [Edit] Reverting optimistic updates due to API error...&quot;,&#10;        );&#10;        queryClient.invalidateQueries({&#10;          queryKey: [&quot;dashboard&quot;, userIds.userId, userIds.userEmail],&#10;          exact: true,&#10;        });&#10;        queryClient.invalidateQueries({&#10;          queryKey: [&quot;products&quot;],&#10;          exact: false,&#10;        });&#10;&#10;        alert(&#10;          `Failed to update product: ${errorData.error || &quot;Unknown error&quot;}`,&#10;        );&#10;      }&#10;    } catch (error) {&#10;      console.error(&quot;❌ [Edit] Error updating product:&quot;, error);&#10;&#10;      // Revert optimistic updates on error&#10;      const userIds = {&#10;        userId: session.user.userId || session.user.id || session.user._id,&#10;        userEmail: session.user.email,&#10;      };&#10;&#10;      console.log(&quot; [Edit] Reverting optimistic updates due to error...&quot;);&#10;      queryClient.invalidateQueries({&#10;        queryKey: [&quot;dashboard&quot;, userIds.userId, userIds.userEmail],&#10;        exact: true,&#10;      });&#10;      queryClient.invalidateQueries({&#10;        queryKey: [&quot;products&quot;],&#10;        exact: false,&#10;      });&#10;&#10;      alert(&quot;Failed to update product. Please try again.&quot;);&#10;    } finally {&#10;      setLoading(false);&#10;    }&#10;  };&#10;&#10;  if (status === &quot;loading&quot; || initialLoading) {&#10;    return (&#10;      &lt;div className=&quot;min-h-screen bg-gray-50 dark:bg-gray-900 flex items-center justify-center&quot;&gt;&#10;        &lt;div className=&quot;text-center&quot;&gt;&#10;          &lt;i className=&quot;fas fa-spinner fa-spin text-4xl text-primary-600 mb-4&quot;&gt;&lt;/i&gt;&#10;          &lt;p className=&quot;text-gray-600 dark:text-gray-400&quot;&gt;&#10;            Loading product data...&#10;          &lt;/p&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;&#10;  return (&#10;    &lt;&gt;&#10;      {/* Breadcrumb */}&#10;      &lt;div className=&quot;max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-4&quot;&gt;&#10;        &lt;nav className=&quot;flex&quot; aria-label=&quot;Breadcrumb&quot;&gt;&#10;          &lt;ol className=&quot;flex items-center space-x-2 text-sm&quot;&gt;&#10;            &lt;li&gt;&#10;              &lt;Link href=&quot;/&quot; className=&quot;text-gray-500 hover:text-primary-600&quot;&gt;&#10;                Home&#10;              &lt;/Link&gt;&#10;            &lt;/li&gt;&#10;            &lt;li&gt;&#10;              &lt;i className=&quot;fas fa-chevron-right text-gray-400 text-xs&quot;&gt;&lt;/i&gt;&#10;            &lt;/li&gt;&#10;            &lt;li&gt;&#10;              &lt;Link&#10;                href=&quot;/manage&quot;&#10;                className=&quot;text-gray-500 hover:text-primary-600&quot;&#10;              &gt;&#10;                Manage Products&#10;              &lt;/Link&gt;&#10;            &lt;/li&gt;&#10;            &lt;li&gt;&#10;              &lt;i className=&quot;fas fa-chevron-right text-gray-400 text-xs&quot;&gt;&lt;/i&gt;&#10;            &lt;/li&gt;&#10;            &lt;li className=&quot;text-gray-900 dark:text-white&quot;&gt;Edit Product&lt;/li&gt;&#10;          &lt;/ol&gt;&#10;        &lt;/nav&gt;&#10;      &lt;/div&gt;&#10;&#10;      {/* Edit Product Form */}&#10;      &lt;div className=&quot;max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-8&quot;&gt;&#10;        &lt;div className=&quot;bg-white dark:bg-gray-800 rounded-2xl shadow-lg overflow-hidden&quot;&gt;&#10;          {/* Header */}&#10;          &lt;div className=&quot;bg-primary-600 text-white px-8 py-6&quot;&gt;&#10;            &lt;h1 className=&quot;text-3xl font-bold&quot;&gt;Edit Product&lt;/h1&gt;&#10;            &lt;p className=&quot;text-primary-100 mt-2&quot;&gt;&#10;              Update your product information&#10;            &lt;/p&gt;&#10;          &lt;/div&gt;&#10;&#10;          {/* Form */}&#10;          &lt;form onSubmit={handleSubmit} className=&quot;p-8 space-y-8&quot;&gt;&#10;            {/* Basic Information */}&#10;            &lt;div&gt;&#10;              &lt;h2 className=&quot;text-xl font-semibold text-gray-900 dark:text-white mb-4&quot;&gt;&#10;                Basic Information&#10;              &lt;/h2&gt;&#10;              &lt;div className=&quot;grid grid-cols-1 md:grid-cols-2 gap-6&quot;&gt;&#10;                &lt;div&gt;&#10;                  &lt;label&#10;                    htmlFor=&quot;name&quot;&#10;                    className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&#10;                  &gt;&#10;                    Product Name *&#10;                  &lt;/label&gt;&#10;                  &lt;input&#10;                    type=&quot;text&quot;&#10;                    id=&quot;name&quot;&#10;                    name=&quot;name&quot;&#10;                    value={formData.name}&#10;                    onChange={handleInputChange}&#10;                    required&#10;                    className=&quot;w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-transparent dark:bg-gray-700 dark:text-white&quot;&#10;                    placeholder=&quot;e.g., Fresh Tomatoes&quot;&#10;                  /&gt;&#10;                &lt;/div&gt;&#10;&#10;                &lt;div&gt;&#10;                  &lt;label&#10;                    htmlFor=&quot;category&quot;&#10;                    className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&#10;                  &gt;&#10;                    Category *&#10;                  &lt;/label&gt;&#10;                  &lt;select&#10;                    id=&quot;category&quot;&#10;                    name=&quot;category&quot;&#10;                    value={formData.category}&#10;                    onChange={handleInputChange}&#10;                    required&#10;                    className=&quot;w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-transparent dark:bg-gray-700 dark:text-white&quot;&#10;                  &gt;&#10;                    &lt;option value=&quot;&quot;&gt;Select Category&lt;/option&gt;&#10;                    &lt;option value=&quot;Vegetables&quot;&gt;Vegetables&lt;/option&gt;&#10;                    &lt;option value=&quot;Fruits&quot;&gt;Fruits&lt;/option&gt;&#10;                    &lt;option value=&quot;Grains&quot;&gt;Grains&lt;/option&gt;&#10;                    &lt;option value=&quot;Dairy&quot;&gt;Dairy&lt;/option&gt;&#10;                    &lt;option value=&quot;Herbs&quot;&gt;Herbs&lt;/option&gt;&#10;                    &lt;option value=&quot;Honey&quot;&gt;Honey&lt;/option&gt;&#10;                  &lt;/select&gt;&#10;                &lt;/div&gt;&#10;&#10;                &lt;div className=&quot;md:col-span-2&quot;&gt;&#10;                  &lt;label&#10;                    htmlFor=&quot;description&quot;&#10;                    className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&#10;                  &gt;&#10;                    Description *&#10;                  &lt;/label&gt;&#10;                  &lt;textarea&#10;                    id=&quot;description&quot;&#10;                    name=&quot;description&quot;&#10;                    rows={4}&#10;                    value={formData.description}&#10;                    onChange={handleInputChange}&#10;                    required&#10;                    className=&quot;w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-transparent dark:bg-gray-700 dark:text-white&quot;&#10;                    placeholder=&quot;Describe your product, growing methods, quality, etc.&quot;&#10;                  /&gt;&#10;                &lt;/div&gt;&#10;              &lt;/div&gt;&#10;            &lt;/div&gt;&#10;&#10;            {/* Pricing &amp; Inventory */}&#10;            &lt;div&gt;&#10;              &lt;h2 className=&quot;text-xl font-semibold text-gray-900 dark:text-white mb-4&quot;&gt;&#10;                Pricing &amp; Inventory&#10;              &lt;/h2&gt;&#10;              &lt;div className=&quot;grid grid-cols-1 md:grid-cols-3 gap-6&quot;&gt;&#10;                &lt;div&gt;&#10;                  &lt;label&#10;                    htmlFor=&quot;price&quot;&#10;                    className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&#10;                  &gt;&#10;                    Price per Unit (৳) *&#10;                  &lt;/label&gt;&#10;                  &lt;input&#10;                    type=&quot;number&quot;&#10;                    id=&quot;price&quot;&#10;                    name=&quot;price&quot;&#10;                    min=&quot;0&quot;&#10;                    step=&quot;0.01&quot;&#10;                    value={formData.price}&#10;                    onChange={handleInputChange}&#10;                    required&#10;                    className=&quot;w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-transparent dark:bg-gray-700 dark:text-white&quot;&#10;                    placeholder=&quot;45.00&quot;&#10;                  /&gt;&#10;                &lt;/div&gt;&#10;&#10;                &lt;div&gt;&#10;                  &lt;label&#10;                    htmlFor=&quot;unit&quot;&#10;                    className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&#10;                  &gt;&#10;                    Unit *&#10;                  &lt;/label&gt;&#10;                  &lt;select&#10;                    id=&quot;unit&quot;&#10;                    name=&quot;unit&quot;&#10;                    value={formData.unit}&#10;                    onChange={handleInputChange}&#10;                    required&#10;                    className=&quot;w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-transparent dark:bg-gray-700 dark:text-white&quot;&#10;                  &gt;&#10;                    &lt;option value=&quot;&quot;&gt;Select Unit&lt;/option&gt;&#10;                    &lt;option value=&quot;kg&quot;&gt;Kilogram (kg)&lt;/option&gt;&#10;                    &lt;option value=&quot;g&quot;&gt;Gram (g)&lt;/option&gt;&#10;                    &lt;option value=&quot;piece&quot;&gt;Piece&lt;/option&gt;&#10;                    &lt;option value=&quot;bunch&quot;&gt;Bunch&lt;/option&gt;&#10;                    &lt;option value=&quot;liter&quot;&gt;Liter&lt;/option&gt;&#10;                    &lt;option value=&quot;ml&quot;&gt;Milliliter (ml)&lt;/option&gt;&#10;                    &lt;option value=&quot;dozen&quot;&gt;Dozen&lt;/option&gt;&#10;                    &lt;option value=&quot;bundle&quot;&gt;Bundle&lt;/option&gt;&#10;                  &lt;/select&gt;&#10;                &lt;/div&gt;&#10;&#10;                &lt;div&gt;&#10;                  &lt;label&#10;                    htmlFor=&quot;stock&quot;&#10;                    className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&#10;                  &gt;&#10;                    Available Stock *&#10;                  &lt;/label&gt;&#10;                  &lt;input&#10;                    type=&quot;number&quot;&#10;                    id=&quot;stock&quot;&#10;                    name=&quot;stock&quot;&#10;                    min=&quot;0&quot;&#10;                    value={formData.stock}&#10;                    onChange={handleInputChange}&#10;                    required&#10;                    className=&quot;w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-transparent dark:bg-gray-700 dark:text-white&quot;&#10;                    placeholder=&quot;100&quot;&#10;                  /&gt;&#10;                &lt;/div&gt;&#10;              &lt;/div&gt;&#10;            &lt;/div&gt;&#10;&#10;            {/* Product Images */}&#10;            &lt;div&gt;&#10;              &lt;h2 className=&quot;text-xl font-semibold text-gray-900 dark:text-white mb-4&quot;&gt;&#10;                Product Images&#10;              &lt;/h2&gt;&#10;              &lt;div className=&quot;space-y-4&quot;&gt;&#10;                &lt;div&gt;&#10;                  &lt;label&#10;                    htmlFor=&quot;images&quot;&#10;                    className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&#10;                  &gt;&#10;                    Upload Images (Max 5 images)&#10;                  &lt;/label&gt;&#10;                  &lt;div className=&quot;border-2 border-dashed border-gray-300 dark:border-gray-600 rounded-lg p-6 text-center hover:border-primary-500 transition&quot;&gt;&#10;                    &lt;input&#10;                      type=&quot;file&quot;&#10;                      id=&quot;images&quot;&#10;                      name=&quot;images&quot;&#10;                      multiple&#10;                      accept=&quot;image/*&quot;&#10;                      onChange={handleImageChange}&#10;                      className=&quot;hidden&quot;&#10;                    /&gt;&#10;                    &lt;label htmlFor=&quot;images&quot; className=&quot;cursor-pointer&quot;&gt;&#10;                      &lt;i className=&quot;fas fa-cloud-upload-alt text-4xl text-gray-400 mb-4&quot;&gt;&lt;/i&gt;&#10;                      &lt;p className=&quot;text-lg font-medium text-gray-900 dark:text-white&quot;&gt;&#10;                        Click to upload new images&#10;                      &lt;/p&gt;&#10;                      &lt;p className=&quot;text-sm text-gray-500 dark:text-gray-400&quot;&gt;&#10;                        PNG, JPG, WebP up to 5MB each&#10;                      &lt;/p&gt;&#10;                    &lt;/label&gt;&#10;                  &lt;/div&gt;&#10;&#10;                  {/* Image Previews */}&#10;                  {imagePreviews.length &gt; 0 &amp;&amp; (&#10;                    &lt;div className=&quot;mt-4&quot;&gt;&#10;                      &lt;p className=&quot;text-sm font-medium text-gray-700 dark:text-gray-300 mb-3&quot;&gt;&#10;                        Current Images ({imagePreviews.length}/5)&#10;                      &lt;/p&gt;&#10;                      &lt;div className=&quot;grid grid-cols-2 md:grid-cols-5 gap-4&quot;&gt;&#10;                        {imagePreviews.map((preview, index) =&gt; (&#10;                          &lt;div&#10;                            key={index}&#10;                            className=&quot;relative group rounded-lg overflow-hidden bg-gray-100 dark:bg-gray-700&quot;&#10;                          &gt;&#10;                            &lt;Image&#10;                              src={preview}&#10;                              alt={`Product Image ${index + 1}`}&#10;                              width={200}&#10;                              height={150}&#10;                              className=&quot;w-full h-24 object-cover group-hover:scale-105 transition-transform duration-200&quot;&#10;                            /&gt;&#10;                            &lt;div className=&quot;absolute inset-0 bg-black bg-opacity-0 group-hover:bg-opacity-30 transition-opacity duration-200 flex items-center justify-center&quot;&gt;&#10;                              &lt;button&#10;                                type=&quot;button&quot;&#10;                                onClick={() =&gt; removeImage(index)}&#10;                                className=&quot;opacity-0 group-hover:opacity-100 bg-red-500 hover:bg-red-600 text-white rounded-full w-8 h-8 flex items-center justify-center transition-all duration-200 shadow-lg&quot;&#10;                                title=&quot;Remove image&quot;&#10;                              &gt;&#10;                                &lt;i className=&quot;fas fa-times text-sm&quot;&gt;&lt;/i&gt;&#10;                              &lt;/button&gt;&#10;                            &lt;/div&gt;&#10;                            &lt;div className=&quot;absolute bottom-1 left-1 bg-black bg-opacity-70 text-white text-xs px-1 py-0.5 rounded&quot;&gt;&#10;                              {index + 1}&#10;                            &lt;/div&gt;&#10;                          &lt;/div&gt;&#10;                        ))}&#10;&#10;                        {/* Add more images placeholder */}&#10;                        {imagePreviews.length &lt; 5 &amp;&amp; (&#10;                          &lt;div&#10;                            className=&quot;border-2 border-dashed border-gray-300 dark:border-gray-600 rounded-lg h-24 flex items-center justify-center cursor-pointer hover:border-primary-500 transition-colors&quot;&#10;                            onClick={() =&gt;&#10;                              document.getElementById(&quot;images&quot;).click()&#10;                            }&#10;                          &gt;&#10;                            &lt;div className=&quot;text-center&quot;&gt;&#10;                              &lt;i className=&quot;fas fa-plus text-gray-400 text-xl mb-1&quot;&gt;&lt;/i&gt;&#10;                              &lt;p className=&quot;text-xs text-gray-500 dark:text-gray-400&quot;&gt;&#10;                                Add More&#10;                              &lt;/p&gt;&#10;                            &lt;/div&gt;&#10;                          &lt;/div&gt;&#10;                        )}&#10;                      &lt;/div&gt;&#10;                    &lt;/div&gt;&#10;                  )}&#10;                &lt;/div&gt;&#10;              &lt;/div&gt;&#10;            &lt;/div&gt;&#10;&#10;            {/* Farm Information */}&#10;            &lt;div&gt;&#10;              &lt;h2 className=&quot;text-xl font-semibold text-gray-900 dark:text-white mb-4&quot;&gt;&#10;                Farm Information&#10;              &lt;/h2&gt;&#10;              &lt;div className=&quot;grid grid-cols-1 md:grid-cols-2 gap-6&quot;&gt;&#10;                &lt;div&gt;&#10;                  &lt;label&#10;                    htmlFor=&quot;farmLocation&quot;&#10;                    className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&#10;                  &gt;&#10;                    Farm Location&#10;                  &lt;/label&gt;&#10;                  &lt;input&#10;                    type=&quot;text&quot;&#10;                    id=&quot;farmLocation&quot;&#10;                    name=&quot;farmLocation&quot;&#10;                    value={formData.farmLocation}&#10;                    onChange={handleInputChange}&#10;                    className=&quot;w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-transparent dark:bg-gray-700 dark:text-white&quot;&#10;                    placeholder=&quot;e.g., Sylhet, Bangladesh&quot;&#10;                  /&gt;&#10;                &lt;/div&gt;&#10;&#10;                &lt;div&gt;&#10;                  &lt;label&#10;                    htmlFor=&quot;harvestDate&quot;&#10;                    className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&#10;                  &gt;&#10;                    Harvest Date&#10;                  &lt;/label&gt;&#10;                  &lt;input&#10;                    type=&quot;date&quot;&#10;                    id=&quot;harvestDate&quot;&#10;                    name=&quot;harvestDate&quot;&#10;                    value={formData.harvestDate}&#10;                    onChange={handleInputChange}&#10;                    className=&quot;w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-transparent dark:bg-gray-700 dark:text-white&quot;&#10;                  /&gt;&#10;                &lt;/div&gt;&#10;              &lt;/div&gt;&#10;            &lt;/div&gt;&#10;&#10;            {/* Product Features */}&#10;            &lt;div&gt;&#10;              &lt;h2 className=&quot;text-xl font-semibold text-gray-900 dark:text-white mb-4&quot;&gt;&#10;                Product Features&#10;              &lt;/h2&gt;&#10;              &lt;div className=&quot;grid grid-cols-2 md:grid-cols-4 gap-4&quot;&gt;&#10;                {[&#10;                  &quot;organic&quot;,&#10;                  &quot;pesticide-free&quot;,&#10;                  &quot;fresh&quot;,&#10;                  &quot;non-gmo&quot;,&#10;                  &quot;local&quot;,&#10;                  &quot;sustainable&quot;,&#10;                  &quot;fair-trade&quot;,&#10;                  &quot;gluten-free&quot;,&#10;                ].map((feature) =&gt; (&#10;                  &lt;label&#10;                    key={feature}&#10;                    className=&quot;flex items-center p-3 border border-gray-300 dark:border-gray-600 rounded-lg cursor-pointer hover:bg-gray-50 dark:hover:bg-gray-700&quot;&#10;                  &gt;&#10;                    &lt;input&#10;                      type=&quot;checkbox&quot;&#10;                      name=&quot;features&quot;&#10;                      value={feature}&#10;                      checked={formData.features.includes(feature)}&#10;                      onChange={handleFeatureChange}&#10;                      className=&quot;rounded border-gray-300 text-primary-600 focus:ring-primary-500&quot;&#10;                    /&gt;&#10;                    &lt;span className=&quot;ml-2 text-sm capitalize&quot;&gt;&#10;                      {feature.replace(&quot;-&quot;, &quot; &quot;)}&#10;                    &lt;/span&gt;&#10;                  &lt;/label&gt;&#10;                ))}&#10;              &lt;/div&gt;&#10;            &lt;/div&gt;&#10;&#10;            {/* Submit Button */}&#10;            &lt;div className=&quot;flex space-x-4&quot;&gt;&#10;              &lt;Link&#10;                href=&quot;/manage&quot;&#10;                className=&quot;flex-1 py-3 px-6 border border-gray-300 dark:border-gray-600 text-gray-700 dark:text-gray-300 rounded-lg font-semibold text-center hover:bg-gray-50 dark:hover:bg-gray-700 transition&quot;&#10;              &gt;&#10;                &lt;i className=&quot;fas fa-times mr-2&quot;&gt;&lt;/i&gt;&#10;                Cancel&#10;              &lt;/Link&gt;&#10;              &lt;button&#10;                type=&quot;submit&quot;&#10;                disabled={loading}&#10;                className={`flex-1 py-3 rounded-lg font-semibold focus:outline-none focus:ring-2 focus:ring-primary-500 focus:ring-offset-2 transition ${&#10;                  loading&#10;                    ? &quot;bg-gray-400 cursor-not-allowed text-white&quot;&#10;                    : &quot;bg-primary-600 text-white hover:bg-primary-700&quot;&#10;                }`}&#10;              &gt;&#10;                {loading ? (&#10;                  &lt;&gt;&#10;                    &lt;i className=&quot;fas fa-spinner fa-spin mr-2&quot;&gt;&lt;/i&gt;&#10;                    Updating Product...&#10;                  &lt;/&gt;&#10;                ) : (&#10;                  &lt;&gt;&#10;                    &lt;i className=&quot;fas fa-save mr-2&quot;&gt;&lt;/i&gt;&#10;                    Update Product&#10;                  &lt;/&gt;&#10;                )}&#10;              &lt;/button&gt;&#10;            &lt;/div&gt;&#10;          &lt;/form&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;&#10;      {/* Footer */}&#10;      &lt;Footer /&gt;&#10;    &lt;/&gt;&#10;  );&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/farmer-dashboard/page.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/farmer-dashboard/page.js" />
              <option name="updatedContent" value="&quot;use client&quot;;&#10;                    &lt;/div&gt;&#10;&#10;                    &lt;div&gt;&#10;                      &lt;label className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&gt;&#10;                        City&#10;                      &lt;/label&gt;&#10;                      &lt;input&#10;                        type=&quot;text&quot;&#10;                        value={farmerData.contactInfo.address.city}&#10;                        onChange={(e) =&gt;&#10;                          handleNestedChange(&quot;contactInfo&quot;, &quot;address&quot;, &quot;city&quot;, e.target.value)&#10;                        }&#10;                        className=&quot;w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:ring-primary-500 focus:border-primary-500 dark:bg-gray-700 dark:text-white&quot;&#10;                      /&gt;&#10;                    &lt;/div&gt;&#10;&#10;                    &lt;div&gt;&#10;                      &lt;label className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&gt;&#10;                        State/Province&#10;                      &lt;/label&gt;&#10;                      &lt;input&#10;                        type=&quot;text&quot;&#10;                        value={farmerData.contactInfo.address.state}&#10;                        onChange={(e) =&gt;&#10;                          handleNestedChange(&quot;contactInfo&quot;, &quot;address&quot;, &quot;state&quot;, e.target.value)&#10;                        }&#10;                        className=&quot;w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:ring-primary-500 focus:border-primary-500 dark:bg-gray-700 dark:text-white&quot;&#10;                      /&gt;&#10;                    &lt;/div&gt;&#10;&#10;                    &lt;div&gt;&#10;                      &lt;label className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&gt;&#10;                        ZIP/Postal Code&#10;                      &lt;/label&gt;&#10;                      &lt;input&#10;                        type=&quot;text&quot;&#10;                        value={farmerData.contactInfo.address.zipCode}&#10;                        onChange={(e) =&gt;&#10;                          handleNestedChange(&quot;contactInfo&quot;, &quot;address&quot;, &quot;zipCode&quot;, e.target.value)&#10;                        }&#10;                        className=&quot;w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:ring-primary-500 focus:border-primary-500 dark:bg-gray-700 dark:text-white&quot;&#10;                      /&gt;&#10;                    &lt;/div&gt;&#10;&#10;                    &lt;div&gt;&#10;                      &lt;label className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&gt;&#10;                        Country&#10;                      &lt;/label&gt;&#10;                      &lt;select&#10;                        value={farmerData.contactInfo.address.country}&#10;                        onChange={(e) =&gt;&#10;                          handleNestedChange(&quot;contactInfo&quot;, &quot;address&quot;, &quot;country&quot;, e.target.value)&#10;                        }&#10;                        className=&quot;w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:ring-primary-500 focus:border-primary-500 dark:bg-gray-700 dark:text-white&quot;&#10;                      &gt;&#10;                        &lt;option value=&quot;&quot;&gt;Select Country&lt;/option&gt;&#10;                        &lt;option value=&quot;US&quot;&gt;United States&lt;/option&gt;&#10;                        &lt;option value=&quot;CA&quot;&gt;Canada&lt;/option&gt;&#10;                        &lt;option value=&quot;UK&quot;&gt;United Kingdom&lt;/option&gt;&#10;                        &lt;option value=&quot;AU&quot;&gt;Australia&lt;/option&gt;&#10;                      &lt;/select&gt;&#10;                    &lt;/div&gt;&#10;                  &lt;/div&gt;&#10;                &lt;/div&gt;&#10;&#10;                &lt;button&#10;                  onClick={() =&gt; handleSaveChanges(&quot;contactInfo&quot;)}&#10;                  disabled={loading}&#10;                  className=&quot;bg-primary-600 text-white px-6 py-2 rounded-md hover:bg-primary-700 focus:ring-2 focus:ring-primary-500 disabled:opacity-50 disabled:cursor-not-allowed&quot;&#10;                &gt;&#10;                  {loading ? &quot;Saving...&quot; : &quot;Save Contact Information&quot;}&#10;                &lt;/button&gt;&#10;              &lt;/div&gt;&#10;            )}&#10;&#10;            {/* Settings Tab */}&#10;            {activeTab === &quot;settings&quot; &amp;&amp; (&#10;              &lt;div className=&quot;space-y-6&quot;&gt;&#10;                &lt;h3 className=&quot;text-lg font-medium text-gray-900 dark:text-white&quot;&gt;&#10;                  Settings&#10;                &lt;/h3&gt;&#10;&#10;                {/* Notification Settings */}&#10;                &lt;div&gt;&#10;                  &lt;h4 className=&quot;text-md font-medium text-gray-900 dark:text-white mb-4&quot;&gt;&#10;                    Notification Preferences&#10;                  &lt;/h4&gt;&#10;                  &lt;div className=&quot;space-y-3&quot;&gt;&#10;                    &lt;label className=&quot;flex items-center&quot;&gt;&#10;                      &lt;input&#10;                        type=&quot;checkbox&quot;&#10;                        checked={farmerData.settings.notifications.orderAlerts}&#10;                        onChange={(e) =&gt;&#10;                          handleNestedChange(&quot;settings&quot;, &quot;notifications&quot;, &quot;orderAlerts&quot;, e.target.checked)&#10;                        }&#10;                        className=&quot;rounded border-gray-300 text-primary-600 shadow-sm focus:border-primary-300 focus:ring focus:ring-primary-200 focus:ring-opacity-50&quot;&#10;                      /&gt;&#10;                      &lt;span className=&quot;ml-2 text-sm text-gray-700 dark:text-gray-300&quot;&gt;&#10;                        New order alerts&#10;                      &lt;/span&gt;&#10;                    &lt;/label&gt;&#10;&#10;                    &lt;label className=&quot;flex items-center&quot;&gt;&#10;                      &lt;input&#10;                        type=&quot;checkbox&quot;&#10;                        checked={farmerData.settings.notifications.lowStockAlerts}&#10;                        onChange={(e) =&gt;&#10;                          handleNestedChange(&quot;settings&quot;, &quot;notifications&quot;, &quot;lowStockAlerts&quot;, e.target.checked)&#10;                        }&#10;                        className=&quot;rounded border-gray-300 text-primary-600 shadow-sm focus:border-primary-300 focus:ring focus:ring-primary-200 focus:ring-opacity-50&quot;&#10;                      /&gt;&#10;                      &lt;span className=&quot;ml-2 text-sm text-gray-700 dark:text-gray-300&quot;&gt;&#10;                        Low stock alerts&#10;                      &lt;/span&gt;&#10;                    &lt;/label&gt;&#10;&#10;                    &lt;label className=&quot;flex items-center&quot;&gt;&#10;                      &lt;input&#10;                        type=&quot;checkbox&quot;&#10;                        checked={farmerData.settings.notifications.customerMessages}&#10;                        onChange={(e) =&gt;&#10;                          handleNestedChange(&quot;settings&quot;, &quot;notifications&quot;, &quot;customerMessages&quot;, e.target.checked)&#10;                        }&#10;                        className=&quot;rounded border-gray-300 text-primary-600 shadow-sm focus:border-primary-300 focus:ring focus:ring-primary-200 focus:ring-opacity-50&quot;&#10;                      /&gt;&#10;                      &lt;span className=&quot;ml-2 text-sm text-gray-700 dark:text-gray-300&quot;&gt;&#10;                        Customer messages&#10;                      &lt;/span&gt;&#10;                    &lt;/label&gt;&#10;&#10;                    &lt;label className=&quot;flex items-center&quot;&gt;&#10;                      &lt;input&#10;                        type=&quot;checkbox&quot;&#10;                        checked={farmerData.settings.notifications.marketingUpdates}&#10;                        onChange={(e) =&gt;&#10;                          handleNestedChange(&quot;settings&quot;, &quot;notifications&quot;, &quot;marketingUpdates&quot;, e.target.checked)&#10;                        }&#10;                        className=&quot;rounded border-gray-300 text-primary-600 shadow-sm focus:border-primary-300 focus:ring focus:ring-primary-200 focus:ring-opacity-50&quot;&#10;                      /&gt;&#10;                      &lt;span className=&quot;ml-2 text-sm text-gray-700 dark:text-gray-300&quot;&gt;&#10;                        Marketing updates&#10;                      &lt;/span&gt;&#10;                    &lt;/label&gt;&#10;                  &lt;/div&gt;&#10;                &lt;/div&gt;&#10;&#10;                {/* Business Settings */}&#10;                &lt;div&gt;&#10;                  &lt;h4 className=&quot;text-md font-medium text-gray-900 dark:text-white mb-4&quot;&gt;&#10;                    Business Settings&#10;                  &lt;/h4&gt;&#10;                  &lt;div className=&quot;space-y-3&quot;&gt;&#10;                    &lt;label className=&quot;flex items-center&quot;&gt;&#10;                      &lt;input&#10;                        type=&quot;checkbox&quot;&#10;                        checked={farmerData.settings.autoAcceptOrders}&#10;                        onChange={(e) =&gt;&#10;                          handleNestedChange(&quot;settings&quot;, &quot;&quot;, &quot;autoAcceptOrders&quot;, e.target.checked)&#10;                        }&#10;                        className=&quot;rounded border-gray-300 text-primary-600 shadow-sm focus:border-primary-300 focus:ring focus:ring-primary-200 focus:ring-opacity-50&quot;&#10;                      /&gt;&#10;                      &lt;span className=&quot;ml-2 text-sm text-gray-700 dark:text-gray-300&quot;&gt;&#10;                        Auto-accept orders&#10;                      &lt;/span&gt;&#10;                    &lt;/label&gt;&#10;&#10;                    &lt;label className=&quot;flex items-center&quot;&gt;&#10;                      &lt;input&#10;                        type=&quot;checkbox&quot;&#10;                        checked={farmerData.settings.showFarmLocation}&#10;                        onChange={(e) =&gt;&#10;                          handleNestedChange(&quot;settings&quot;, &quot;&quot;, &quot;showFarmLocation&quot;, e.target.checked)&#10;                        }&#10;                        className=&quot;rounded border-gray-300 text-primary-600 shadow-sm focus:border-primary-300 focus:ring focus:ring-primary-200 focus:ring-opacity-50&quot;&#10;                      /&gt;&#10;                      &lt;span className=&quot;ml-2 text-sm text-gray-700 dark:text-gray-300&quot;&gt;&#10;                        Show farm location to customers&#10;                      &lt;/span&gt;&#10;                    &lt;/label&gt;&#10;                  &lt;/div&gt;&#10;                &lt;/div&gt;&#10;&#10;                &lt;button&#10;                  onClick={() =&gt; handleSaveChanges(&quot;settings&quot;)}&#10;                  disabled={loading}&#10;                  className=&quot;bg-primary-600 text-white px-6 py-2 rounded-md hover:bg-primary-700 focus:ring-2 focus:ring-primary-500 disabled:opacity-50 disabled:cursor-not-allowed&quot;&#10;                &gt;&#10;                  {loading ? &quot;Saving...&quot; : &quot;Save Settings&quot;}&#10;                &lt;/button&gt;&#10;              &lt;/div&gt;&#10;            )}&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/manage/page.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/manage/page.js" />
              <option name="originalContent" value="&quot;use client&quot;;&#10;&#10;import { useState, useEffect, useCallback, useMemo } from &quot;react&quot;;&#10;import { useSession } from &quot;next-auth/react&quot;;&#10;import { useRouter } from &quot;next/navigation&quot;;&#10;import Footer from &quot;@/components/Footer&quot;;&#10;import ManagePageLoadingSkeleton from &quot;@/components/ManagePageLoadingSkeleton&quot;;&#10;import { useDashboardData } from &quot;@/hooks/useDashboardData&quot;;&#10;&#10;// Component imports&#10;import DashboardHeader from &quot;@/components/dashboard/DashboardHeader&quot;;&#10;import NavigationTabs from &quot;@/components/dashboard/NavigationTabs&quot;;&#10;import DashboardTab from &quot;@/components/dashboard/tabs/DashboardTab&quot;;&#10;import ProductsTab from &quot;@/components/dashboard/tabs/ProductsTab&quot;;&#10;import OrdersTab from &quot;@/components/dashboard/tabs/OrdersTab&quot;;&#10;import AnalyticsTab from &quot;@/components/dashboard/tabs/AnalyticsTab&quot;;&#10;import SettingsTab from &quot;@/components/dashboard/tabs/SettingsTab&quot;;&#10;&#10;// Constants&#10;const TABS = {&#10;  DASHBOARD: &quot;dashboard&quot;,&#10;  PRODUCTS: &quot;products&quot;,&#10;  ORDERS: &quot;orders&quot;,&#10;  ANALYTICS: &quot;analytics&quot;,&#10;  SETTINGS: &quot;settings&quot;,&#10;};&#10;&#10;const PRODUCT_STATUS = {&#10;  ACTIVE: &quot;active&quot;,&#10;  INACTIVE: &quot;inactive&quot;,&#10;  OUT_OF_STOCK: &quot;out-of-stock&quot;,&#10;  LOW_STOCK: &quot;low-stock&quot;,&#10;};&#10;&#10;const ORDER_STATUS = {&#10;  PENDING: &quot;pending&quot;,&#10;  CONFIRMED: &quot;confirmed&quot;,&#10;  DELIVERED: &quot;delivered&quot;,&#10;  CANCELLED: &quot;cancelled&quot;,&#10;  RETURNED: &quot;returned&quot;,&#10;};&#10;&#10;const DEFAULT_PAGINATION = {&#10;  page: 1,&#10;  limit: 12,&#10;};&#10;&#10;export default function FarmerDashboard() {&#10;  const { data: session, status } = useSession();&#10;  const router = useRouter();&#10;&#10;  // Use React Query hook for dashboard data&#10;  const {&#10;    products,&#10;    orders,&#10;    isLoading,&#10;    error,&#10;    isRefetching,&#10;    refetch: refetchDashboard,&#10;    refreshDashboard,&#10;    bulkUpdateProducts,&#10;    deleteProduct, // Import deleteProduct function&#10;  } = useDashboardData();&#10;&#10;  // UI state&#10;  const [activeTab, setActiveTab] = useState(TABS.DASHBOARD);&#10;  const [actionLoading, setActionLoading] = useState({});&#10;  const [autoRefresh, setAutoRefresh] = useState(true);&#10;&#10;  // Filter and search state&#10;  const [filters, setFilters] = useState({&#10;    search: &quot;&quot;,&#10;    category: &quot;&quot;,&#10;    status: &quot;&quot;,&#10;    sort: &quot;&quot;,&#10;  });&#10;&#10;  // Pagination state&#10;  const [pagination, setPagination] = useState(DEFAULT_PAGINATION);&#10;  const [viewMode, setViewMode] = useState(&quot;grid&quot;);&#10;&#10;  // Authentication and authorization check&#10;  useEffect(() =&gt; {&#10;    if (status === &quot;loading&quot;) return;&#10;&#10;    if (status === &quot;unauthenticated&quot;) {&#10;      router.push(&quot;/login&quot;);&#10;      return;&#10;    }&#10;&#10;    if (status === &quot;authenticated&quot; &amp;&amp; session?.user) {&#10;      const userType = session.user.userType || session.user.role || &quot;user&quot;;&#10;      const isFarmer =&#10;        userType === &quot;farmer&quot; ||&#10;        userType === &quot;Farmer&quot; ||&#10;        session.user.type === &quot;farmer&quot; ||&#10;        session.user.accountType === &quot;farmer&quot;;&#10;&#10;      if (!isFarmer) {&#10;        router.push(&quot;/&quot;);&#10;        return;&#10;      }&#10;    }&#10;  }, [session?.user?.id, session?.user?.email, status, router]);&#10;&#10;  // Manual refresh handler&#10;  const handleRefresh = useCallback(async () =&gt; {&#10;    await refetchDashboard();&#10;  }, [refetchDashboard]);&#10;&#10;  // Auto-refresh functionality&#10;  useEffect(() =&gt; {&#10;    if (!autoRefresh) return;&#10;&#10;    const interval = setInterval(() =&gt; {&#10;      refreshDashboard();&#10;    }, 30000); // 30 seconds&#10;&#10;    return () =&gt; clearInterval(interval);&#10;  }, [autoRefresh, refreshDashboard]);&#10;&#10;  // Calculate analytics with memoization&#10;  const analytics = useMemo(() =&gt; {&#10;    const validOrders = orders.filter(&#10;      (order) =&gt;&#10;        order.status !== ORDER_STATUS.CANCELLED &amp;&amp;&#10;        order.status !== ORDER_STATUS.RETURNED,&#10;    );&#10;&#10;    // Only count DELIVERED orders for revenue calculation&#10;    const deliveredOrders = orders.filter(&#10;      (order) =&gt; order.status === ORDER_STATUS.DELIVERED,&#10;    );&#10;&#10;    const totalProducts = products.length;&#10;    const activeProducts = products.filter(&#10;      (p) =&gt; p.stock &gt; 0 &amp;&amp; p.status !== PRODUCT_STATUS.INACTIVE,&#10;    ).length;&#10;&#10;    const totalOrders = orders.length;&#10;    const pendingOrders = orders.filter(&#10;      (o) =&gt; o.status === ORDER_STATUS.PENDING,&#10;    ).length;&#10;&#10;    // Use DELIVERED orders only for revenue calculation&#10;    const totalRevenue = deliveredOrders.reduce((sum, order) =&gt; {&#10;      const revenue = parseFloat(order.farmerSubtotal || order.total || 0);&#10;      console.log(&#10;        `Dashboard Analytics - Order ${order._id}: Status=${order.status}, FarmerSubtotal=${order.farmerSubtotal}, Total=${order.total}, Revenue=${revenue}`,&#10;      );&#10;      return sum + revenue;&#10;    }, 0);&#10;&#10;    console.log(&#10;      `Dashboard Analytics Summary - Delivered Orders: ${deliveredOrders.length}, Total Revenue: ${totalRevenue}, Debug API Revenue: 26525.91`,&#10;    );&#10;&#10;    const now = new Date();&#10;    const thisMonthValidOrders = validOrders.filter((order) =&gt; {&#10;      const orderDate = new Date(order.createdAt);&#10;      return (&#10;        orderDate.getMonth() === now.getMonth() &amp;&amp;&#10;        orderDate.getFullYear() === now.getFullYear()&#10;      );&#10;    });&#10;&#10;    // Keep averageOrderValue based on validOrders (all orders) but use delivered revenue&#10;    const averageOrderValue =&#10;      deliveredOrders.length &gt; 0 ? totalRevenue / deliveredOrders.length : 0;&#10;&#10;    const recentOrders = orders.slice(0, 5).map((order) =&gt; ({&#10;      _id: order._id,&#10;      id: order.id,&#10;      customerName: order.customerName,&#10;      total: order.total || order.farmerSubtotal,&#10;      createdAt: order.createdAt,&#10;      status: order.status,&#10;      items: order.items?.length || 0,&#10;    }));&#10;&#10;    return {&#10;      totalProducts,&#10;      activeProducts,&#10;      totalOrders,&#10;      pendingOrders,&#10;      totalRevenue,&#10;      thisMonthOrders: thisMonthValidOrders.length,&#10;      averageOrderValue,&#10;      lowStockProducts: products.filter((p) =&gt; p.stock &lt;= 10).length,&#10;      recentOrders,&#10;    };&#10;  }, [products.length, orders.length]);&#10;&#10;  // Filter and sort products&#10;  const filteredAndSortedProducts = useMemo(() =&gt; {&#10;    let filtered = [...products];&#10;&#10;    if (filters.search) {&#10;      const searchRegex = new RegExp(filters.search.trim(), &quot;i&quot;);&#10;      filtered = filtered.filter(&#10;        (product) =&gt;&#10;          searchRegex.test(product.name) ||&#10;          searchRegex.test(product.description || &quot;&quot;) ||&#10;          searchRegex.test(product.category || &quot;&quot;),&#10;      );&#10;    }&#10;&#10;    if (filters.category) {&#10;      filtered = filtered.filter(&#10;        (product) =&gt;&#10;          product.category?.toLowerCase() === filters.category.toLowerCase(),&#10;      );&#10;    }&#10;&#10;    if (filters.status) {&#10;      switch (filters.status) {&#10;        case PRODUCT_STATUS.ACTIVE:&#10;          filtered = filtered.filter(&#10;            (product) =&gt;&#10;              product.stock &gt; 0 &amp;&amp; product.status !== PRODUCT_STATUS.INACTIVE,&#10;          );&#10;          break;&#10;        case PRODUCT_STATUS.INACTIVE:&#10;          filtered = filtered.filter(&#10;            (product) =&gt; product.status === PRODUCT_STATUS.INACTIVE,&#10;          );&#10;          break;&#10;        case PRODUCT_STATUS.OUT_OF_STOCK:&#10;          filtered = filtered.filter((product) =&gt; product.stock === 0);&#10;          break;&#10;        case PRODUCT_STATUS.LOW_STOCK:&#10;          filtered = filtered.filter(&#10;            (product) =&gt; product.stock &gt; 0 &amp;&amp; product.stock &lt;= 5,&#10;          );&#10;          break;&#10;      }&#10;    }&#10;&#10;    if (filters.sort) {&#10;      const [key, order] = filters.sort.split(&quot;-&quot;);&#10;      filtered.sort((a, b) =&gt; {&#10;        let valueA, valueB;&#10;&#10;        switch (key) {&#10;          case &quot;price&quot;:&#10;            valueA = a.price || 0;&#10;            valueB = b.price || 0;&#10;            break;&#10;          case &quot;name&quot;:&#10;            valueA = a.name || &quot;&quot;;&#10;            valueB = b.name || &quot;&quot;;&#10;            return order === &quot;asc&quot;&#10;              ? valueA.localeCompare(valueB)&#10;              : valueB.localeCompare(valueA);&#10;          case &quot;stock&quot;:&#10;            valueA = a.stock || 0;&#10;            valueB = b.stock || 0;&#10;            break;&#10;          case &quot;date&quot;:&#10;            valueA = new Date(a.createdAt || 0);&#10;            valueB = new Date(b.createdAt || 0);&#10;            break;&#10;          default:&#10;            return 0;&#10;        }&#10;&#10;        return order === &quot;asc&quot; ? valueA - valueB : valueB - valueA;&#10;      });&#10;    }&#10;&#10;    return filtered;&#10;  }, [products, filters]);&#10;&#10;  // Reset pagination when filters change&#10;  useEffect(() =&gt; {&#10;    setPagination((prev) =&gt; ({ ...prev, page: 1 }));&#10;  }, [filters]);&#10;&#10;  // Paginated products&#10;  const paginatedProducts = useMemo(() =&gt; {&#10;    const startIndex = (pagination.page - 1) * pagination.limit;&#10;    const endIndex = startIndex + pagination.limit;&#10;    return filteredAndSortedProducts.slice(startIndex, endIndex);&#10;  }, [filteredAndSortedProducts, pagination]);&#10;&#10;  // Total pages calculation&#10;  const totalPages = Math.ceil(&#10;    filteredAndSortedProducts.length / pagination.limit,&#10;  );&#10;&#10;  // Product management functions&#10;  const handleStatusToggle = useCallback(&#10;    async (productId, currentStatus) =&gt; {&#10;      console.log(&quot;handleStatusToggle called with:&quot;, {&#10;        productId,&#10;        currentStatus,&#10;        type: typeof currentStatus,&#10;      });&#10;&#10;      // Normalize the current status to lowercase for comparison&#10;      const normalizedCurrentStatus = currentStatus?.toLowerCase();&#10;      const normalizedActiveStatus = PRODUCT_STATUS.ACTIVE.toLowerCase();&#10;&#10;      const newStatus =&#10;        normalizedCurrentStatus === normalizedActiveStatus&#10;          ? PRODUCT_STATUS.INACTIVE&#10;          : PRODUCT_STATUS.ACTIVE;&#10;&#10;      console.log(&quot;Status toggle:&quot;, {&#10;        currentStatus,&#10;        normalizedCurrentStatus,&#10;        newStatus,&#10;        comparison: normalizedCurrentStatus === normalizedActiveStatus,&#10;      });&#10;&#10;      const actionText =&#10;        newStatus === PRODUCT_STATUS.ACTIVE ? &quot;activate&quot; : &quot;deactivate&quot;;&#10;&#10;      if (!confirm(`Are you sure you want to ${actionText} this product?`)) {&#10;        return;&#10;      }&#10;&#10;      setActionLoading((prev) =&gt; ({ ...prev, [productId]: &quot;status&quot; }));&#10;&#10;      try {&#10;        console.log(&quot;Sending status update:&quot;, { productId, status: newStatus });&#10;&#10;        // Use the bulkUpdateProducts from hook (includes cache invalidation like farmer updates)&#10;        const result = await bulkUpdateProducts(&#10;          [productId], // Single product as array&#10;          { status: newStatus },&#10;        );&#10;&#10;        if (!result.success) {&#10;          throw new Error(result.error || `Failed to ${actionText} product`);&#10;        }&#10;&#10;        // Dispatch custom event to notify products page of status change&#10;        window.dispatchEvent(&#10;          new CustomEvent(&quot;productStatusUpdated&quot;, {&#10;            detail: {&#10;              productId: productId,&#10;              newStatus: newStatus,&#10;              timestamp: Date.now(),&#10;            },&#10;          }),&#10;        );&#10;&#10;        // Also set localStorage flag for cross-tab communication&#10;        localStorage.setItem(&#10;          &quot;productStatusUpdated&quot;,&#10;          JSON.stringify({&#10;            productId: productId,&#10;            newStatus: newStatus,&#10;            timestamp: Date.now(),&#10;          }),&#10;        );&#10;&#10;        const successMsg =&#10;          newStatus === PRODUCT_STATUS.ACTIVE&#10;            ? &quot;Product activated successfully!&quot;&#10;            : &quot;Product deactivated successfully!&quot;;&#10;&#10;        alert(successMsg);&#10;      } catch (error) {&#10;        console.error(&quot;Error updating product status:&quot;, error);&#10;        alert(`Failed to ${actionText} product: ${error.message}`);&#10;      } finally {&#10;        setActionLoading((prev) =&gt; ({ ...prev, [productId]: null }));&#10;      }&#10;    },&#10;    [bulkUpdateProducts],&#10;  );&#10;&#10;  const handleDeleteProduct = useCallback(&#10;    async (productId) =&gt; {&#10;      const confirmMessage =&#10;        &quot;⚠️ Are you sure you want to delete this product?\n\n&quot; +&#10;        &quot;This action cannot be undone and will remove:\n&quot; +&#10;        &quot;• The product listing\n&quot; +&#10;        &quot;• All associated data\n&quot; +&#10;        &quot;• Product from any pending orders&quot;;&#10;&#10;      if (!confirm(confirmMessage)) return;&#10;&#10;      setActionLoading((prev) =&gt; ({ ...prev, [productId]: &quot;delete&quot; }));&#10;&#10;      try {&#10;        // Use the deleteProduct function from hook (includes optimistic cache updates)&#10;        const result = await deleteProduct(productId);&#10;&#10;        if (!result.success) {&#10;          throw new Error(&quot;Failed to delete product&quot;);&#10;        }&#10;&#10;        alert(&quot;Product deleted successfully!&quot;);&#10;      } catch (error) {&#10;        console.error(&quot;Error deleting product:&quot;, error);&#10;&#10;        // Handle specific error cases&#10;        if (error.message.includes(&quot;pending orders&quot;)) {&#10;          alert(&#10;            &quot;❌ Cannot Delete Product\n\n&quot; +&#10;              &quot;This product has pending orders and cannot be deleted.\n&quot; +&#10;              &quot;Please wait for all orders to be completed or cancelled before deleting this product.\n\n&quot; +&#10;              &quot;You can temporarily deactivate the product instead by clicking the pause button.&quot;,&#10;          );&#10;        } else if (error.message.includes(&quot;not found&quot;)) {&#10;          alert(&quot;❌ Product not found. It may have already been deleted.&quot;);&#10;        } else {&#10;          alert(`❌ Failed to delete product: ${error.message}`);&#10;        }&#10;      } finally {&#10;        setActionLoading((prev) =&gt; ({ ...prev, [productId]: null }));&#10;      }&#10;    },&#10;    [deleteProduct],&#10;  );&#10;&#10;  // Update functions&#10;  const updateFilters = useCallback((newFilters) =&gt; {&#10;    setFilters((prev) =&gt; ({ ...prev, ...newFilters }));&#10;  }, []);&#10;&#10;  const updatePagination = useCallback((newPagination) =&gt; {&#10;    setPagination((prev) =&gt; ({ ...prev, ...newPagination }));&#10;  }, []);&#10;&#10;  // Utility functions&#10;  const formatPrice = useCallback((price) =&gt; {&#10;    return new Intl.NumberFormat(&quot;en-BD&quot;, {&#10;      style: &quot;currency&quot;,&#10;      currency: &quot;BDT&quot;,&#10;      minimumFractionDigits: 0,&#10;    }).format(price || 0);&#10;  }, []);&#10;&#10;  const formatDate = useCallback((dateString) =&gt; {&#10;    return new Date(dateString).toLocaleDateString(&quot;en-US&quot;, {&#10;      year: &quot;numeric&quot;,&#10;      month: &quot;short&quot;,&#10;      day: &quot;numeric&quot;,&#10;    });&#10;  }, []);&#10;&#10;  const getProductStatusBadge = useCallback((product) =&gt; {&#10;    if (product.status === PRODUCT_STATUS.INACTIVE) {&#10;      return (&#10;        &lt;span className=&quot;inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200&quot;&gt;&#10;          &lt;i className=&quot;fas fa-pause mr-1&quot;&gt;&lt;/i&gt;&#10;          Inactive&#10;        &lt;/span&gt;&#10;      );&#10;    }&#10;    if (product.stock === 0) {&#10;      return (&#10;        &lt;span className=&quot;inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-200&quot;&gt;&#10;          &lt;i className=&quot;fas fa-exclamation-triangle mr-1&quot;&gt;&lt;/i&gt;&#10;          Out of Stock&#10;        &lt;/span&gt;&#10;      );&#10;    }&#10;    if (product.stock &lt;= 5) {&#10;      return (&#10;        &lt;span className=&quot;inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-orange-100 text-orange-800 dark:bg-orange-900 dark:text-orange-200&quot;&gt;&#10;          &lt;i className=&quot;fas fa-exclamation-circle mr-1&quot;&gt;&lt;/i&gt;&#10;          Low Stock&#10;        &lt;/span&gt;&#10;      );&#10;    }&#10;    return (&#10;      &lt;span className=&quot;inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200&quot;&gt;&#10;        &lt;i className=&quot;fas fa-check-circle mr-1&quot;&gt;&lt;/i&gt;&#10;        Active&#10;      &lt;/span&gt;&#10;    );&#10;  }, []);&#10;&#10;  // Component props&#10;  const commonProps = {&#10;    session,&#10;    products,&#10;    orders,&#10;    analytics,&#10;    handleRefresh,&#10;    refreshing: isRefetching,&#10;    formatPrice,&#10;    formatDate,&#10;    loading: isLoading,&#10;    error,&#10;    bulkUpdateProducts, // Add this prop for DashboardTab&#10;  };&#10;&#10;  const productProps = {&#10;    ...commonProps,&#10;    paginatedProducts,&#10;    filteredProducts: filteredAndSortedProducts,&#10;    totalProducts: products.length,&#10;    filters,&#10;    updateFilters,&#10;    pagination: { ...pagination, totalPages },&#10;    updatePagination,&#10;    viewMode,&#10;    setViewMode,&#10;    handleStatusToggle,&#10;    handleDeleteProduct,&#10;    actionLoading,&#10;    getProductStatusBadge,&#10;    // Add missing bulk update functionality for ProductsTab&#10;    bulkUpdateProducts,&#10;  };&#10;&#10;  // Loading state - Use dedicated manage page skeleton&#10;  if (isLoading || status === &quot;loading&quot;) {&#10;    return &lt;ManagePageLoadingSkeleton /&gt;;&#10;  }&#10;&#10;  // Error state&#10;  if (error &amp;&amp; !products.length &amp;&amp; !orders.length) {&#10;    return (&#10;      &lt;div className=&quot;min-h-screen bg-gray-50 dark:bg-gray-900 flex items-center justify-center&quot;&gt;&#10;        &lt;div className=&quot;text-center max-w-md mx-auto p-6&quot;&gt;&#10;          &lt;div className=&quot;text-red-500 text-6xl mb-4&quot;&gt;&#10;            &lt;i className=&quot;fas fa-exclamation-triangle&quot;&gt;&lt;/i&gt;&#10;          &lt;/div&gt;&#10;          &lt;h2 className=&quot;text-2xl font-bold text-gray-900 dark:text-white mb-2&quot;&gt;&#10;            Dashboard Error&#10;          &lt;/h2&gt;&#10;          &lt;p className=&quot;text-gray-600 dark:text-gray-400 mb-6&quot;&gt;&#10;            {error.message}&#10;          &lt;/p&gt;&#10;          &lt;button&#10;            onClick={handleRefresh}&#10;            disabled={isRefetching}&#10;            className=&quot;bg-primary-600 hover:bg-primary-700 text-white px-6 py-3 rounded-lg font-medium transition disabled:opacity-50&quot;&#10;          &gt;&#10;            {isRefetching ? (&#10;              &lt;&gt;&#10;                &lt;i className=&quot;fas fa-spinner fa-spin mr-2&quot;&gt;&lt;/i&gt;&#10;                Retrying...&#10;              &lt;/&gt;&#10;            ) : (&#10;              &lt;&gt;&#10;                &lt;i className=&quot;fas fa-redo mr-2&quot;&gt;&lt;/i&gt;&#10;                Try Again&#10;              &lt;/&gt;&#10;            )}&#10;          &lt;/button&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;&#10;  return (&#10;    &lt;&gt;&#10;      &lt;div className=&quot;min-h-screen bg-gray-50 dark:bg-gray-900&quot;&gt;&#10;        &lt;DashboardHeader {...commonProps} /&gt;&#10;&#10;        {error &amp;&amp; (&#10;          &lt;div className=&quot;max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 pt-4&quot;&gt;&#10;            &lt;div className=&quot;bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg p-4&quot;&gt;&#10;              &lt;div className=&quot;flex items-center&quot;&gt;&#10;                &lt;i className=&quot;fas fa-exclamation-triangle text-red-500 mr-2&quot;&gt;&lt;/i&gt;&#10;                &lt;span className=&quot;text-red-700 dark:text-red-300&quot;&gt;&#10;                  {error.message}&#10;                &lt;/span&gt;&#10;                &lt;button&#10;                  onClick={handleRefresh}&#10;                  className=&quot;ml-auto text-primary-600 hover:text-primary-800&quot;&#10;                &gt;&#10;                  &lt;i className=&quot;fas fa-redo&quot;&gt;&lt;/i&gt;&#10;                &lt;/button&gt;&#10;              &lt;/div&gt;&#10;            &lt;/div&gt;&#10;          &lt;/div&gt;&#10;        )}&#10;&#10;        &lt;NavigationTabs activeTab={activeTab} setActiveTab={setActiveTab} /&gt;&#10;&#10;        &lt;div className=&quot;max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8&quot;&gt;&#10;          {activeTab === TABS.DASHBOARD &amp;&amp; &lt;DashboardTab {...commonProps} /&gt;}&#10;          {activeTab === TABS.PRODUCTS &amp;&amp; &lt;ProductsTab {...productProps} /&gt;}&#10;          {activeTab === TABS.ORDERS &amp;&amp; &lt;OrdersTab {...commonProps} /&gt;}&#10;          {activeTab === TABS.ANALYTICS &amp;&amp; &lt;AnalyticsTab {...commonProps} /&gt;}&#10;          {activeTab === TABS.SETTINGS &amp;&amp; &lt;SettingsTab {...commonProps} /&gt;}&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;      &lt;Footer /&gt;&#10;    &lt;/&gt;&#10;  );&#10;}&#10;" />
              <option name="updatedContent" value="&quot;use client&quot;;&#10;&#10;import { useState, useEffect, useCallback, useMemo } from &quot;react&quot;;&#10;import { useSession } from &quot;next-auth/react&quot;;&#10;import { useRouter } from &quot;next/navigation&quot;;&#10;import Footer from &quot;@/components/Footer&quot;;&#10;import ManagePageLoadingSkeleton from &quot;@/components/ManagePageLoadingSkeleton&quot;;&#10;import { useDashboardData } from &quot;@/hooks/useDashboardData&quot;;&#10;&#10;// Component imports&#10;import DashboardHeader from &quot;@/components/dashboard/DashboardHeader&quot;;&#10;import NavigationTabs from &quot;@/components/dashboard/NavigationTabs&quot;;&#10;import DashboardTab from &quot;@/components/dashboard/tabs/DashboardTab&quot;;&#10;import ProductsTab from &quot;@/components/dashboard/tabs/ProductsTab&quot;;&#10;import OrdersTab from &quot;@/components/dashboard/tabs/OrdersTab&quot;;&#10;import AnalyticsTab from &quot;@/components/dashboard/tabs/AnalyticsTab&quot;;&#10;import SettingsTab from &quot;@/components/dashboard/tabs/SettingsTab&quot;;&#10;&#10;// Constants&#10;const TABS = {&#10;  DASHBOARD: &quot;dashboard&quot;,&#10;  PRODUCTS: &quot;products&quot;,&#10;  ORDERS: &quot;orders&quot;,&#10;  ANALYTICS: &quot;analytics&quot;,&#10;  SETTINGS: &quot;settings&quot;,&#10;};&#10;&#10;const PRODUCT_STATUS = {&#10;  ACTIVE: &quot;active&quot;,&#10;  INACTIVE: &quot;inactive&quot;,&#10;  OUT_OF_STOCK: &quot;out-of-stock&quot;,&#10;  LOW_STOCK: &quot;low-stock&quot;,&#10;};&#10;&#10;const ORDER_STATUS = {&#10;  PENDING: &quot;pending&quot;,&#10;  CONFIRMED: &quot;confirmed&quot;,&#10;  DELIVERED: &quot;delivered&quot;,&#10;  CANCELLED: &quot;cancelled&quot;,&#10;  RETURNED: &quot;returned&quot;,&#10;};&#10;&#10;const DEFAULT_PAGINATION = {&#10;  page: 1,&#10;  limit: 12,&#10;};&#10;&#10;export default function FarmerDashboard() {&#10;  const { data: session, status } = useSession();&#10;  const router = useRouter();&#10;&#10;  // Use React Query hook for dashboard data&#10;  const {&#10;    products,&#10;    orders,&#10;    isLoading,&#10;    error,&#10;    isRefetching,&#10;    refetch: refetchDashboard,&#10;    refreshDashboard,&#10;    bulkUpdateProducts,&#10;    deleteProduct, // Import deleteProduct function&#10;  } = useDashboardData();&#10;&#10;  // UI state&#10;  const [activeTab, setActiveTab] = useState(TABS.DASHBOARD);&#10;  const [actionLoading, setActionLoading] = useState({});&#10;  const [autoRefresh, setAutoRefresh] = useState(true);&#10;&#10;  // Filter and search state&#10;  const [filters, setFilters] = useState({&#10;    search: &quot;&quot;,&#10;    category: &quot;&quot;,&#10;    status: &quot;&quot;,&#10;    sort: &quot;&quot;,&#10;  });&#10;&#10;  // Pagination state&#10;  const [pagination, setPagination] = useState(DEFAULT_PAGINATION);&#10;  const [viewMode, setViewMode] = useState(&quot;grid&quot;);&#10;&#10;  // Authentication and authorization check&#10;  useEffect(() =&gt; {&#10;    if (status === &quot;loading&quot;) return;&#10;&#10;    if (status === &quot;unauthenticated&quot;) {&#10;      router.push(&quot;/login&quot;);&#10;      return;&#10;    }&#10;&#10;    if (status === &quot;authenticated&quot; &amp;&amp; session?.user) {&#10;      const userType = session.user.userType || session.user.role || &quot;user&quot;;&#10;      const isFarmer =&#10;        userType === &quot;farmer&quot; ||&#10;        userType === &quot;Farmer&quot; ||&#10;        session.user.type === &quot;farmer&quot; ||&#10;        session.user.accountType === &quot;farmer&quot;;&#10;&#10;      if (!isFarmer) {&#10;        router.push(&quot;/&quot;);&#10;        return;&#10;      }&#10;    }&#10;  }, [session?.user?.id, session?.user?.email, status, router]);&#10;&#10;  // Manual refresh handler&#10;  const handleRefresh = useCallback(async () =&gt; {&#10;    await refetchDashboard();&#10;  }, [refetchDashboard]);&#10;&#10;  // Auto-refresh functionality&#10;  useEffect(() =&gt; {&#10;    if (!autoRefresh) return;&#10;&#10;    const interval = setInterval(() =&gt; {&#10;      refreshDashboard();&#10;    }, 30000); // 30 seconds&#10;&#10;    return () =&gt; clearInterval(interval);&#10;  }, [autoRefresh, refreshDashboard]);&#10;&#10;  // Calculate analytics with memoization&#10;  const analytics = useMemo(() =&gt; {&#10;    const validOrders = orders.filter(&#10;      (order) =&gt;&#10;        order.status !== ORDER_STATUS.CANCELLED &amp;&amp;&#10;        order.status !== ORDER_STATUS.RETURNED,&#10;    );&#10;&#10;    // Only count DELIVERED orders for revenue calculation&#10;    const deliveredOrders = orders.filter(&#10;      (order) =&gt; order.status === ORDER_STATUS.DELIVERED,&#10;    );&#10;&#10;    const totalProducts = products.length;&#10;    const activeProducts = products.filter(&#10;      (p) =&gt; p.stock &gt; 0 &amp;&amp; p.status !== PRODUCT_STATUS.INACTIVE,&#10;    ).length;&#10;&#10;    const totalOrders = orders.length;&#10;    const pendingOrders = orders.filter(&#10;      (o) =&gt; o.status === ORDER_STATUS.PENDING,&#10;    ).length;&#10;&#10;    // Use DELIVERED orders only for revenue calculation&#10;    const totalRevenue = deliveredOrders.reduce((sum, order) =&gt; {&#10;      const revenue = parseFloat(order.farmerSubtotal || order.total || 0);&#10;      console.log(&#10;        `Dashboard Analytics - Order ${order._id}: Status=${order.status}, FarmerSubtotal=${order.farmerSubtotal}, Total=${order.total}, Revenue=${revenue}`,&#10;      );&#10;      return sum + revenue;&#10;    }, 0);&#10;&#10;    console.log(&#10;      `Dashboard Analytics Summary - Delivered Orders: ${deliveredOrders.length}, Total Revenue: ${totalRevenue}, Debug API Revenue: 26525.91`,&#10;    );&#10;&#10;    const now = new Date();&#10;    const thisMonthValidOrders = validOrders.filter((order) =&gt; {&#10;      const orderDate = new Date(order.createdAt);&#10;      return (&#10;        orderDate.getMonth() === now.getMonth() &amp;&amp;&#10;        orderDate.getFullYear() === now.getFullYear()&#10;      );&#10;    });&#10;&#10;    // Keep averageOrderValue based on validOrders (all orders) but use delivered revenue&#10;    const averageOrderValue =&#10;      deliveredOrders.length &gt; 0 ? totalRevenue / deliveredOrders.length : 0;&#10;&#10;    const recentOrders = orders.slice(0, 5).map((order) =&gt; ({&#10;      _id: order._id,&#10;      id: order.id,&#10;      customerName: order.customerName,&#10;      total: order.total || order.farmerSubtotal,&#10;      createdAt: order.createdAt,&#10;      status: order.status,&#10;      items: order.items?.length || 0,&#10;    }));&#10;&#10;    return {&#10;      totalProducts,&#10;      activeProducts,&#10;      totalOrders,&#10;      pendingOrders,&#10;      totalRevenue,&#10;      thisMonthOrders: thisMonthValidOrders.length,&#10;      averageOrderValue,&#10;      lowStockProducts: products.filter((p) =&gt; p.stock &lt;= 10).length,&#10;      recentOrders,&#10;    };&#10;  }, [products.length, orders.length]);&#10;&#10;  // Filter and sort products&#10;  const filteredAndSortedProducts = useMemo(() =&gt; {&#10;    let filtered = [...products];&#10;&#10;    if (filters.search) {&#10;      const searchRegex = new RegExp(filters.search.trim(), &quot;i&quot;);&#10;      filtered = filtered.filter(&#10;        (product) =&gt;&#10;          searchRegex.test(product.name) ||&#10;          searchRegex.test(product.description || &quot;&quot;) ||&#10;          searchRegex.test(product.category || &quot;&quot;),&#10;      );&#10;    }&#10;&#10;    if (filters.category) {&#10;      filtered = filtered.filter(&#10;        (product) =&gt;&#10;          product.category?.toLowerCase() === filters.category.toLowerCase(),&#10;      );&#10;    }&#10;&#10;    if (filters.status) {&#10;      switch (filters.status) {&#10;        case PRODUCT_STATUS.ACTIVE:&#10;          filtered = filtered.filter(&#10;            (product) =&gt;&#10;              product.stock &gt; 0 &amp;&amp; product.status !== PRODUCT_STATUS.INACTIVE,&#10;          );&#10;          break;&#10;        case PRODUCT_STATUS.INACTIVE:&#10;          filtered = filtered.filter(&#10;            (product) =&gt; product.status === PRODUCT_STATUS.INACTIVE,&#10;          );&#10;          break;&#10;        case PRODUCT_STATUS.OUT_OF_STOCK:&#10;          filtered = filtered.filter((product) =&gt; product.stock === 0);&#10;          break;&#10;        case PRODUCT_STATUS.LOW_STOCK:&#10;          filtered = filtered.filter(&#10;            (product) =&gt; product.stock &gt; 0 &amp;&amp; product.stock &lt;= 5,&#10;          );&#10;          break;&#10;      }&#10;    }&#10;&#10;    if (filters.sort) {&#10;      const [key, order] = filters.sort.split(&quot;-&quot;);&#10;      filtered.sort((a, b) =&gt; {&#10;        let valueA, valueB;&#10;&#10;        switch (key) {&#10;          case &quot;price&quot;:&#10;            valueA = a.price || 0;&#10;            valueB = b.price || 0;&#10;            break;&#10;          case &quot;name&quot;:&#10;            valueA = a.name || &quot;&quot;;&#10;            valueB = b.name || &quot;&quot;;&#10;            return order === &quot;asc&quot;&#10;              ? valueA.localeCompare(valueB)&#10;              : valueB.localeCompare(valueA);&#10;          case &quot;stock&quot;:&#10;            valueA = a.stock || 0;&#10;            valueB = b.stock || 0;&#10;            break;&#10;          case &quot;date&quot;:&#10;            valueA = new Date(a.createdAt || 0);&#10;            valueB = new Date(b.createdAt || 0);&#10;            break;&#10;          default:&#10;            return 0;&#10;        }&#10;&#10;        return order === &quot;asc&quot; ? valueA - valueB : valueB - valueA;&#10;      });&#10;    }&#10;&#10;    return filtered;&#10;  }, [products, filters]);&#10;&#10;  // Reset pagination when filters change&#10;  useEffect(() =&gt; {&#10;    setPagination((prev) =&gt; ({ ...prev, page: 1 }));&#10;  }, [filters]);&#10;&#10;  // Paginated products&#10;  const paginatedProducts = useMemo(() =&gt; {&#10;    const startIndex = (pagination.page - 1) * pagination.limit;&#10;    const endIndex = startIndex + pagination.limit;&#10;    return filteredAndSortedProducts.slice(startIndex, endIndex);&#10;  }, [filteredAndSortedProducts, pagination]);&#10;&#10;  // Total pages calculation&#10;  const totalPages = Math.ceil(&#10;    filteredAndSortedProducts.length / pagination.limit,&#10;  );&#10;&#10;  // Product management functions&#10;  const handleStatusToggle = useCallback(&#10;    async (productId, currentStatus) =&gt; {&#10;      console.log(&quot;handleStatusToggle called with:&quot;, {&#10;        productId,&#10;        currentStatus,&#10;        type: typeof currentStatus,&#10;      });&#10;&#10;      // Normalize the current status to lowercase for comparison&#10;      const normalizedCurrentStatus = currentStatus?.toLowerCase();&#10;      const normalizedActiveStatus = PRODUCT_STATUS.ACTIVE.toLowerCase();&#10;&#10;      const newStatus =&#10;        normalizedCurrentStatus === normalizedActiveStatus&#10;          ? PRODUCT_STATUS.INACTIVE&#10;          : PRODUCT_STATUS.ACTIVE;&#10;&#10;      console.log(&quot;Status toggle:&quot;, {&#10;        currentStatus,&#10;        normalizedCurrentStatus,&#10;        newStatus,&#10;        comparison: normalizedCurrentStatus === normalizedActiveStatus,&#10;      });&#10;&#10;      const actionText =&#10;        newStatus === PRODUCT_STATUS.ACTIVE ? &quot;activate&quot; : &quot;deactivate&quot;;&#10;&#10;      if (!confirm(`Are you sure you want to ${actionText} this product?`)) {&#10;        return;&#10;      }&#10;&#10;      setActionLoading((prev) =&gt; ({ ...prev, [productId]: &quot;status&quot; }));&#10;&#10;      try {&#10;        console.log(&quot;Sending status update:&quot;, { productId, status: newStatus });&#10;&#10;        // Use the bulkUpdateProducts from hook (includes cache invalidation like farmer updates)&#10;        const result = await bulkUpdateProducts(&#10;          [productId], // Single product as array&#10;          { status: newStatus },&#10;        );&#10;&#10;        if (!result.success) {&#10;          throw new Error(result.error || `Failed to ${actionText} product`);&#10;        }&#10;&#10;        // Dispatch custom event to notify products page of status change&#10;        window.dispatchEvent(&#10;          new CustomEvent(&quot;productStatusUpdated&quot;, {&#10;            detail: {&#10;              productId: productId,&#10;              newStatus: newStatus,&#10;              timestamp: Date.now(),&#10;            },&#10;          }),&#10;        );&#10;&#10;        // Also set localStorage flag for cross-tab communication&#10;        localStorage.setItem(&#10;          &quot;productStatusUpdated&quot;,&#10;          JSON.stringify({&#10;            productId: productId,&#10;            newStatus: newStatus,&#10;            timestamp: Date.now(),&#10;          }),&#10;        );&#10;&#10;        const successMsg =&#10;          newStatus === PRODUCT_STATUS.ACTIVE&#10;            ? &quot;Product activated successfully!&quot;&#10;            : &quot;Product deactivated successfully!&quot;;&#10;&#10;        alert(successMsg);&#10;      } catch (error) {&#10;        console.error(&quot;Error updating product status:&quot;, error);&#10;        alert(`Failed to ${actionText} product: ${error.message}`);&#10;      } finally {&#10;        setActionLoading((prev) =&gt; ({ ...prev, [productId]: null }));&#10;      }&#10;    },&#10;    [bulkUpdateProducts],&#10;  );&#10;&#10;  const handleDeleteProduct = useCallback(&#10;    async (productId) =&gt; {&#10;      const confirmMessage =&#10;        &quot;⚠️ Are you sure you want to delete this product?\n\n&quot; +&#10;        &quot;This action cannot be undone and will remove:\n&quot; +&#10;        &quot;• The product listing\n&quot; +&#10;        &quot;• All associated data\n&quot; +&#10;        &quot;• Product from any pending orders&quot;;&#10;&#10;      if (!confirm(confirmMessage)) return;&#10;&#10;      setActionLoading((prev) =&gt; ({ ...prev, [productId]: &quot;delete&quot; }));&#10;&#10;      try {&#10;        // Use the deleteProduct function from hook (includes optimistic cache updates)&#10;        const result = await deleteProduct(productId);&#10;&#10;        if (!result.success) {&#10;          throw new Error(&quot;Failed to delete product&quot;);&#10;        }&#10;&#10;        alert(&quot;Product deleted successfully!&quot;);&#10;      } catch (error) {&#10;        console.error(&quot;Error deleting product:&quot;, error);&#10;&#10;        // Handle specific error cases&#10;        if (error.message.includes(&quot;pending orders&quot;)) {&#10;          alert(&#10;            &quot;❌ Cannot Delete Product\n\n&quot; +&#10;              &quot;This product has pending orders and cannot be deleted.\n&quot; +&#10;              &quot;Please wait for all orders to be completed or cancelled before deleting this product.\n\n&quot; +&#10;              &quot;You can temporarily deactivate the product instead by clicking the pause button.&quot;,&#10;          );&#10;        } else if (error.message.includes(&quot;not found&quot;)) {&#10;          alert(&quot;❌ Product not found. It may have already been deleted.&quot;);&#10;        } else {&#10;          alert(`❌ Failed to delete product: ${error.message}`);&#10;        }&#10;      } finally {&#10;        setActionLoading((prev) =&gt; ({ ...prev, [productId]: null }));&#10;      }&#10;    },&#10;    [deleteProduct],&#10;  );&#10;&#10;  // Update functions&#10;  const updateFilters = useCallback((newFilters) =&gt; {&#10;    setFilters((prev) =&gt; ({ ...prev, ...newFilters }));&#10;  }, []);&#10;&#10;  const updatePagination = useCallback((newPagination) =&gt; {&#10;    setPagination((prev) =&gt; ({ ...prev, ...newPagination }));&#10;  }, []);&#10;&#10;  // Utility functions&#10;  const formatPrice = useCallback((price) =&gt; {&#10;    return new Intl.NumberFormat(&quot;en-BD&quot;, {&#10;      style: &quot;currency&quot;,&#10;      currency: &quot;BDT&quot;,&#10;      minimumFractionDigits: 0,&#10;    }).format(price || 0);&#10;  }, []);&#10;&#10;  const formatDate = useCallback((dateString) =&gt; {&#10;    return new Date(dateString).toLocaleDateString(&quot;en-US&quot;, {&#10;      year: &quot;numeric&quot;,&#10;      month: &quot;short&quot;,&#10;      day: &quot;numeric&quot;,&#10;    });&#10;  }, []);&#10;&#10;  const getProductStatusBadge = useCallback((product) =&gt; {&#10;    if (product.status === PRODUCT_STATUS.INACTIVE) {&#10;      return (&#10;        &lt;span className=&quot;inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200&quot;&gt;&#10;          &lt;i className=&quot;fas fa-pause mr-1&quot;&gt;&lt;/i&gt;&#10;          Inactive&#10;        &lt;/span&gt;&#10;      );&#10;    }&#10;    if (product.stock === 0) {&#10;      return (&#10;        &lt;span className=&quot;inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-200&quot;&gt;&#10;          &lt;i className=&quot;fas fa-exclamation-triangle mr-1&quot;&gt;&lt;/i&gt;&#10;          Out of Stock&#10;        &lt;/span&gt;&#10;      );&#10;    }&#10;    if (product.stock &lt;= 5) {&#10;      return (&#10;        &lt;span className=&quot;inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-orange-100 text-orange-800 dark:bg-orange-900 dark:text-orange-200&quot;&gt;&#10;          &lt;i className=&quot;fas fa-exclamation-circle mr-1&quot;&gt;&lt;/i&gt;&#10;          Low Stock&#10;        &lt;/span&gt;&#10;      );&#10;    }&#10;    return (&#10;      &lt;span className=&quot;inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200&quot;&gt;&#10;        &lt;i className=&quot;fas fa-check-circle mr-1&quot;&gt;&lt;/i&gt;&#10;        Active&#10;      &lt;/span&gt;&#10;    );&#10;  }, []);&#10;&#10;  // Component props&#10;  const commonProps = {&#10;    session,&#10;    products,&#10;    orders,&#10;    analytics,&#10;    handleRefresh,&#10;    refreshing: isRefetching,&#10;    formatPrice,&#10;    formatDate,&#10;    loading: isLoading,&#10;    error,&#10;    bulkUpdateProducts, // Add this prop for DashboardTab&#10;  };&#10;&#10;  const productProps = {&#10;    ...commonProps,&#10;    paginatedProducts,&#10;    filteredProducts: filteredAndSortedProducts,&#10;    totalProducts: products.length,&#10;    // Fix: Map filters object to individual props expected by ProductsTab&#10;    searchTerm: filters.search,&#10;    setSearchTerm: (value) =&gt; setFilters(prev =&gt; ({ ...prev, search: value })),&#10;    selectedCategory: filters.category,&#10;    setSelectedCategory: (value) =&gt; setFilters(prev =&gt; ({ ...prev, category: value })),&#10;    selectedStatus: filters.status,&#10;    setSelectedStatus: (value) =&gt; setFilters(prev =&gt; ({ ...prev, status: value })),&#10;    selectedSort: filters.sort,&#10;    setSelectedSort: (value) =&gt; setFilters(prev =&gt; ({ ...prev, sort: value })),&#10;    // Keep existing props&#10;    filters,&#10;    updateFilters,&#10;    pagination: { ...pagination, totalPages },&#10;    updatePagination,&#10;    viewMode,&#10;    setViewMode,&#10;    handleStatusToggle,&#10;    handleDeleteProduct,&#10;    actionLoading,&#10;    getProductStatusBadge,&#10;    // Add missing bulk update functionality for ProductsTab&#10;    bulkUpdateProducts,&#10;  };&#10;&#10;  // Loading state - Use dedicated manage page skeleton&#10;  if (isLoading || status === &quot;loading&quot;) {&#10;    return &lt;ManagePageLoadingSkeleton /&gt;;&#10;  }&#10;&#10;  // Error state&#10;  if (error &amp;&amp; !products.length &amp;&amp; !orders.length) {&#10;    return (&#10;      &lt;div className=&quot;min-h-screen bg-gray-50 dark:bg-gray-900 flex items-center justify-center&quot;&gt;&#10;        &lt;div className=&quot;text-center max-w-md mx-auto p-6&quot;&gt;&#10;          &lt;div className=&quot;text-red-500 text-6xl mb-4&quot;&gt;&#10;            &lt;i className=&quot;fas fa-exclamation-triangle&quot;&gt;&lt;/i&gt;&#10;          &lt;/div&gt;&#10;          &lt;h2 className=&quot;text-2xl font-bold text-gray-900 dark:text-white mb-2&quot;&gt;&#10;            Dashboard Error&#10;          &lt;/h2&gt;&#10;          &lt;p className=&quot;text-gray-600 dark:text-gray-400 mb-6&quot;&gt;&#10;            {error.message}&#10;          &lt;/p&gt;&#10;          &lt;button&#10;            onClick={handleRefresh}&#10;            disabled={isRefetching}&#10;            className=&quot;bg-primary-600 hover:bg-primary-700 text-white px-6 py-3 rounded-lg font-medium transition disabled:opacity-50&quot;&#10;          &gt;&#10;            {isRefetching ? (&#10;              &lt;&gt;&#10;                &lt;i className=&quot;fas fa-spinner fa-spin mr-2&quot;&gt;&lt;/i&gt;&#10;                Retrying...&#10;              &lt;/&gt;&#10;            ) : (&#10;              &lt;&gt;&#10;                &lt;i className=&quot;fas fa-redo mr-2&quot;&gt;&lt;/i&gt;&#10;                Try Again&#10;              &lt;/&gt;&#10;            )}&#10;          &lt;/button&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;&#10;  return (&#10;    &lt;&gt;&#10;      &lt;div className=&quot;min-h-screen bg-gray-50 dark:bg-gray-900&quot;&gt;&#10;        &lt;DashboardHeader {...commonProps} /&gt;&#10;&#10;        {error &amp;&amp; (&#10;          &lt;div className=&quot;max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 pt-4&quot;&gt;&#10;            &lt;div className=&quot;bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg p-4&quot;&gt;&#10;              &lt;div className=&quot;flex items-center&quot;&gt;&#10;                &lt;i className=&quot;fas fa-exclamation-triangle text-red-500 mr-2&quot;&gt;&lt;/i&gt;&#10;                &lt;span className=&quot;text-red-700 dark:text-red-300&quot;&gt;&#10;                  {error.message}&#10;                &lt;/span&gt;&#10;                &lt;button&#10;                  onClick={handleRefresh}&#10;                  className=&quot;ml-auto text-primary-600 hover:text-primary-800&quot;&#10;                &gt;&#10;                  &lt;i className=&quot;fas fa-redo&quot;&gt;&lt;/i&gt;&#10;                &lt;/button&gt;&#10;              &lt;/div&gt;&#10;            &lt;/div&gt;&#10;          &lt;/div&gt;&#10;        )}&#10;&#10;        &lt;NavigationTabs activeTab={activeTab} setActiveTab={setActiveTab} /&gt;&#10;&#10;        &lt;div className=&quot;max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8&quot;&gt;&#10;          {activeTab === TABS.DASHBOARD &amp;&amp; &lt;DashboardTab {...commonProps} /&gt;}&#10;          {activeTab === TABS.PRODUCTS &amp;&amp; &lt;ProductsTab {...productProps} /&gt;}&#10;          {activeTab === TABS.ORDERS &amp;&amp; &lt;OrdersTab {...commonProps} /&gt;}&#10;          {activeTab === TABS.ANALYTICS &amp;&amp; &lt;AnalyticsTab {...commonProps} /&gt;}&#10;          {activeTab === TABS.SETTINGS &amp;&amp; &lt;SettingsTab {...commonProps} /&gt;}&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;      &lt;Footer /&gt;&#10;    &lt;/&gt;&#10;  );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/products/page-simple.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/products/page-simple.js" />
              <option name="updatedContent" value="&quot;use client&quot;;&#10;      &lt;div className=&quot;min-h-screen bg-gray-50 pt-20&quot;&gt;&#10;        &lt;div className=&quot;max-w-7xl mx-auto px-4&quot;&gt;&#10;          &lt;div className=&quot;text-center py-12&quot;&gt;&#10;            &lt;p className=&quot;text-red-600&quot;&gt;Error loading products: {error.message}&lt;/p&gt;&#10;            &lt;button&#10;              onClick={() =&gt; refetchProducts()}&#10;              className=&quot;mt-4 px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600&quot;&#10;            &gt;&#10;              Try Again&#10;            &lt;/button&gt;&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;&#10;  return (&#10;    &lt;div className=&quot;min-h-screen bg-gray-50 pt-20&quot;&gt;&#10;      &lt;div className=&quot;max-w-7xl mx-auto px-4&quot;&gt;&#10;        {/* Header */}&#10;        &lt;div className=&quot;py-8&quot;&gt;&#10;          &lt;h1 className=&quot;text-3xl font-bold text-gray-900 mb-2&quot;&gt;All Products&lt;/h1&gt;&#10;          &lt;p className=&quot;text-gray-600&quot;&gt;&#10;            Showing {displayProducts.length} products (sorted by newest first)&#10;          &lt;/p&gt;&#10;          &lt;button&#10;            onClick={() =&gt; {&#10;              console.log(&quot; Manual refresh triggered&quot;);&#10;              productsCache.invalidateProducts();&#10;            }}&#10;            className=&quot;mt-4 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600&quot;&#10;          &gt;&#10;            Refresh Products&#10;          &lt;/button&gt;&#10;        &lt;/div&gt;&#10;&#10;        {/* Products Grid */}&#10;        &lt;div className=&quot;grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6 pb-12&quot;&gt;&#10;          {displayProducts.map((product) =&gt; (&#10;            &lt;ProductCard key={product._id} product={product} /&gt;&#10;          ))}&#10;        &lt;/div&gt;&#10;&#10;        {displayProducts.length === 0 &amp;&amp; (&#10;          &lt;div className=&quot;text-center py-12&quot;&gt;&#10;            &lt;p className=&quot;text-gray-500 text-lg&quot;&gt;No products available&lt;/p&gt;&#10;          &lt;/div&gt;&#10;        )}&#10;      &lt;/div&gt;&#10;&#10;      &lt;Footer /&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/profile/farmer.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/profile/farmer.js" />
              <option name="updatedContent" value="&quot;use client&quot;;&#10;&#10;import { useState, useEffect } from &quot;react&quot;;&#10;import { useAuth } from &quot;../../contexts/AuthContext&quot;;&#10;import { useRouter } from &quot;next/navigation&quot;;&#10;import { useTheme } from &quot;../../contexts/ThemeContext&quot;;&#10;&#10;export default function FarmerProfilePage() {&#10;  const { user, isAuthenticated, updateUser } = useAuth();&#10;  const { isDarkMode } = useTheme();&#10;  const router = useRouter();&#10;&#10;  const [activeTab, setActiveTab] = useState(&quot;personal&quot;);&#10;  const [loading, setLoading] = useState(false);&#10;  const [message, setMessage] = useState({ type: &quot;&quot;, text: &quot;&quot; });&#10;  const [profileData, setProfileData] = useState({&#10;    name: &quot;&quot;,&#10;    email: &quot;&quot;,&#10;    phone: &quot;&quot;,&#10;    farmInfo: {&#10;      farmName: &quot;&quot;,&#10;      farmDescription: &quot;&quot;,&#10;      farmSize: &quot;&quot;,&#10;      farmType: &quot;&quot;,&#10;      certifications: [],&#10;      establishedYear: &quot;&quot;,&#10;      farmingMethods: [],&#10;    },&#10;    address: {&#10;      street: &quot;&quot;,&#10;      city: &quot;&quot;,&#10;      state: &quot;&quot;,&#10;      zipCode: &quot;&quot;,&#10;      country: &quot;&quot;,&#10;    },&#10;    businessInfo: {&#10;      businessLicense: &quot;&quot;,&#10;      taxId: &quot;&quot;,&#10;      deliveryRadius: &quot;&quot;,&#10;      minimumOrder: &quot;&quot;,&#10;      website: &quot;&quot;,&#10;      socialMedia: {&#10;        facebook: &quot;&quot;,&#10;        instagram: &quot;&quot;,&#10;        twitter: &quot;&quot;,&#10;      },&#10;    },&#10;    preferences: {&#10;      notifications: {&#10;        email: true,&#10;        sms: false,&#10;        orderUpdates: true,&#10;        lowStockAlerts: true,&#10;        customerMessages: true,&#10;        marketingUpdates: false,&#10;      },&#10;      language: &quot;en&quot;,&#10;      currency: &quot;USD&quot;,&#10;      autoAcceptOrders: false,&#10;      showFarmLocation: true,&#10;    },&#10;    security: {&#10;      currentPassword: &quot;&quot;,&#10;      newPassword: &quot;&quot;,&#10;      confirmPassword: &quot;&quot;,&#10;    },&#10;  });&#10;&#10;  // Redirect if not authenticated or not a farmer&#10;  useEffect(() =&gt; {&#10;    if (!isAuthenticated) {&#10;      router.push(&quot;/login&quot;);&#10;      return;&#10;    }&#10;&#10;    // Check if user is a farmer, if not redirect to regular profile&#10;    if (user &amp;&amp; user.role !== &quot;farmer&quot;) {&#10;      router.push(&quot;/profile&quot;);&#10;      return;&#10;    }&#10;&#10;    // Initialize profile data with user data&#10;    if (user) {&#10;      setProfileData((prev) =&gt; ({&#10;        ...prev,&#10;        name: user.name || &quot;&quot;,&#10;        email: user.email || &quot;&quot;,&#10;        phone: user.phone || &quot;&quot;,&#10;        address: user.address || prev.address,&#10;        farmInfo: user.farmInfo || prev.farmInfo,&#10;        businessInfo: user.businessInfo || prev.businessInfo,&#10;        preferences: user.preferences || prev.preferences,&#10;      }));&#10;    }&#10;  }, [user, isAuthenticated, router]);&#10;&#10;  const handleInputChange = (field, value) =&gt; {&#10;    setProfileData((prev) =&gt; ({&#10;      ...prev,&#10;      [field]: value,&#10;    }));&#10;  };&#10;&#10;  const handleNestedChange = (section, subsection, field, value) =&gt; {&#10;    if (subsection) {&#10;      setProfileData((prev) =&gt; ({&#10;        ...prev,&#10;        [section]: {&#10;          ...prev[section],&#10;          [subsection]: {&#10;            ...prev[section][subsection],&#10;            [field]: value,&#10;          },&#10;        },&#10;      }));&#10;    } else {&#10;      setProfileData((prev) =&gt; ({&#10;        ...prev,&#10;        [section]: {&#10;          ...prev[section],&#10;          [field]: value,&#10;        },&#10;      }));&#10;    }&#10;  };&#10;&#10;  const handleArrayChange = (section, field, value) =&gt; {&#10;    const arrayValue = value.split(&quot;,&quot;).map(item =&gt; item.trim()).filter(item =&gt; item);&#10;    setProfileData((prev) =&gt; ({&#10;      ...prev,&#10;      [section]: {&#10;        ...prev[section],&#10;        [field]: arrayValue,&#10;      },&#10;    }));&#10;  };&#10;&#10;  const handlePersonalInfoUpdate = async () =&gt; {&#10;    try {&#10;      setLoading(true);&#10;      setMessage({ type: &quot;&quot;, text: &quot;&quot; });&#10;&#10;      const response = await fetch(&quot;/api/auth/users&quot;, {&#10;        method: &quot;PUT&quot;,&#10;        headers: { &quot;Content-Type&quot;: &quot;application/json&quot; },&#10;        body: JSON.stringify({&#10;          name: profileData.name,&#10;          phone: profileData.phone,&#10;          address: profileData.address,&#10;          farmInfo: profileData.farmInfo,&#10;          businessInfo: profileData.businessInfo,&#10;          preferences: profileData.preferences,&#10;        }),&#10;      });&#10;&#10;      if (response.ok) {&#10;        const updatedUser = await response.json();&#10;        updateUser(updatedUser.user);&#10;        setMessage({ type: &quot;success&quot;, text: &quot;Profile updated successfully!&quot; });&#10;&#10;        // Also update localStorage to persist data&#10;        localStorage.setItem(&#10;          &quot;farmfresh_user&quot;,&#10;          JSON.stringify(updatedUser.user),&#10;        );&#10;      } else {&#10;        const errorData = await response.json();&#10;        setMessage({&#10;          type: &quot;error&quot;,&#10;          text: errorData.error || &quot;Failed to update profile&quot;,&#10;        });&#10;      }&#10;    } catch (error) {&#10;      setMessage({&#10;        type: &quot;error&quot;,&#10;        text: &quot;An error occurred while updating profile&quot;,&#10;      });&#10;    } finally {&#10;      setLoading(false);&#10;    }&#10;  };&#10;&#10;  const handlePasswordChange = async () =&gt; {&#10;    try {&#10;      setLoading(true);&#10;      setMessage({ type: &quot;&quot;, text: &quot;&quot; });&#10;&#10;      if (&#10;        profileData.security.newPassword !==&#10;        profileData.security.confirmPassword&#10;      ) {&#10;        setMessage({ type: &quot;error&quot;, text: &quot;New passwords don't match&quot; });&#10;        return;&#10;      }&#10;&#10;      if (profileData.security.newPassword.length &lt; 6) {&#10;        setMessage({&#10;          type: &quot;error&quot;,&#10;          text: &quot;Password must be at least 6 characters long&quot;,&#10;        });&#10;        return;&#10;      }&#10;&#10;      const response = await fetch(&quot;/api/auth/users&quot;, {&#10;        method: &quot;PUT&quot;,&#10;        headers: { &quot;Content-Type&quot;: &quot;application/json&quot; },&#10;        body: JSON.stringify({&#10;          currentPassword: profileData.security.currentPassword,&#10;          newPassword: profileData.security.newPassword,&#10;        }),&#10;      });&#10;&#10;      if (response.ok) {&#10;        setMessage({ type: &quot;success&quot;, text: &quot;Password updated successfully!&quot; });&#10;        setProfileData((prev) =&gt; ({&#10;          ...prev,&#10;          security: {&#10;            currentPassword: &quot;&quot;,&#10;            newPassword: &quot;&quot;,&#10;            confirmPassword: &quot;&quot;,&#10;          },&#10;        }));&#10;      } else {&#10;        const errorData = await response.json();&#10;        setMessage({&#10;          type: &quot;error&quot;,&#10;          text: errorData.error || &quot;Failed to update password&quot;,&#10;        });&#10;      }&#10;    } catch (error) {&#10;      setMessage({&#10;        type: &quot;error&quot;,&#10;        text: &quot;An error occurred while updating password&quot;,&#10;      });&#10;    } finally {&#10;      setLoading(false);&#10;    }&#10;  };&#10;&#10;  const tabs = [&#10;    { id: &quot;personal&quot;, label: &quot;Personal Info&quot;, icon: &quot;fas fa-user&quot; },&#10;    { id: &quot;farm&quot;, label: &quot;Farm Info&quot;, icon: &quot;fas fa-seedling&quot; },&#10;    { id: &quot;business&quot;, label: &quot;Business&quot;, icon: &quot;fas fa-building&quot; },&#10;    { id: &quot;address&quot;, label: &quot;Address&quot;, icon: &quot;fas fa-map-marker-alt&quot; },&#10;    { id: &quot;preferences&quot;, label: &quot;Preferences&quot;, icon: &quot;fas fa-cog&quot; },&#10;    { id: &quot;security&quot;, label: &quot;Security&quot;, icon: &quot;fas fa-shield-alt&quot; },&#10;  ];&#10;&#10;  if (!isAuthenticated) {&#10;    return (&#10;      &lt;div className=&quot;min-h-screen flex items-center justify-center&quot;&gt;&#10;        &lt;div className=&quot;animate-spin rounded-full h-12 w-12 border-b-2 border-primary-600&quot;&gt;&lt;/div&gt;&#10;      &lt;/div&gt;&#10;    );&#10;  }&#10;&#10;  return (&#10;    &lt;div className=&quot;min-h-screen bg-gray-50 dark:bg-gray-900 py-8&quot;&gt;&#10;      &lt;div className=&quot;max-w-7xl mx-auto px-4 sm:px-6 lg:px-8&quot;&gt;&#10;        {/* Header */}&#10;        &lt;div className=&quot;mb-8&quot;&gt;&#10;          &lt;h1 className=&quot;text-3xl font-bold text-gray-900 dark:text-white&quot;&gt;&#10;            Farmer Profile Settings&#10;          &lt;/h1&gt;&#10;          &lt;p className=&quot;mt-2 text-gray-600 dark:text-gray-400&quot;&gt;&#10;            Manage your farmer account settings and farm information&#10;          &lt;/p&gt;&#10;        &lt;/div&gt;&#10;&#10;        &lt;div className=&quot;bg-white dark:bg-gray-800 rounded-lg shadow-sm&quot;&gt;&#10;          {/* Tab Navigation */}&#10;          &lt;div className=&quot;border-b border-gray-200 dark:border-gray-700&quot;&gt;&#10;            &lt;nav className=&quot;flex space-x-8 px-6 overflow-x-auto&quot;&gt;&#10;              {tabs.map((tab) =&gt; (&#10;                &lt;button&#10;                  key={tab.id}&#10;                  onClick={() =&gt; setActiveTab(tab.id)}&#10;                  className={`py-4 px-1 border-b-2 font-medium text-sm flex items-center space-x-2 whitespace-nowrap ${&#10;                    activeTab === tab.id&#10;                      ? &quot;border-primary-500 text-primary-600 dark:text-primary-400&quot;&#10;                      : &quot;border-transparent text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-300&quot;&#10;                  }`}&#10;                &gt;&#10;                  &lt;i className={tab.icon}&gt;&lt;/i&gt;&#10;                  &lt;span&gt;{tab.label}&lt;/span&gt;&#10;                &lt;/button&gt;&#10;              ))}&#10;            &lt;/nav&gt;&#10;          &lt;/div&gt;&#10;&#10;          {/* Tab Content */}&#10;          &lt;div className=&quot;p-6&quot;&gt;&#10;            {message.text &amp;&amp; (&#10;              &lt;div&#10;                className={`mb-4 p-4 rounded-md ${&#10;                  message.type === &quot;success&quot;&#10;                    ? &quot;bg-green-50 dark:bg-green-900 text-green-700 dark:text-green-300 border border-green-200 dark:border-green-800&quot;&#10;                    : &quot;bg-red-50 dark:bg-red-900 text-red-700 dark:text-red-300 border border-red-200 dark:border-red-800&quot;&#10;                }`}&#10;              &gt;&#10;                {message.text}&#10;              &lt;/div&gt;&#10;            )}&#10;&#10;            {/* Personal Information Tab */}&#10;            {activeTab === &quot;personal&quot; &amp;&amp; (&#10;              &lt;div className=&quot;space-y-6&quot;&gt;&#10;                &lt;h3 className=&quot;text-lg font-medium text-gray-900 dark:text-white&quot;&gt;&#10;                  Personal Information&#10;                &lt;/h3&gt;&#10;&#10;                &lt;div className=&quot;grid grid-cols-1 md:grid-cols-2 gap-6&quot;&gt;&#10;                  &lt;div&gt;&#10;                    &lt;label className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&gt;&#10;                      Full Name&#10;                    &lt;/label&gt;&#10;                    &lt;input&#10;                      type=&quot;text&quot;&#10;                      value={profileData.name}&#10;                      onChange={(e) =&gt;&#10;                        handleInputChange(&quot;name&quot;, e.target.value)&#10;                      }&#10;                      className=&quot;w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:ring-primary-500 focus:border-primary-500 dark:bg-gray-700 dark:text-white&quot;&#10;                    /&gt;&#10;                  &lt;/div&gt;&#10;&#10;                  &lt;div&gt;&#10;                    &lt;label className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&gt;&#10;                      Email Address&#10;                    &lt;/label&gt;&#10;                    &lt;input&#10;                      type=&quot;email&quot;&#10;                      value={profileData.email}&#10;                      disabled&#10;                      className=&quot;w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm bg-gray-50 dark:bg-gray-600 text-gray-500 dark:text-gray-400&quot;&#10;                    /&gt;&#10;                    &lt;p className=&quot;mt-1 text-xs text-gray-500 dark:text-gray-400&quot;&gt;&#10;                      Email cannot be changed&#10;                    &lt;/p&gt;&#10;                  &lt;/div&gt;&#10;&#10;                  &lt;div&gt;&#10;                    &lt;label className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&gt;&#10;                      Phone Number&#10;                    &lt;/label&gt;&#10;                    &lt;input&#10;                      type=&quot;tel&quot;&#10;                      value={profileData.phone}&#10;                      onChange={(e) =&gt;&#10;                        handleInputChange(&quot;phone&quot;, e.target.value)&#10;                      }&#10;                      className=&quot;w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:ring-primary-500 focus:border-primary-500 dark:bg-gray-700 dark:text-white&quot;&#10;                    /&gt;&#10;                  &lt;/div&gt;&#10;                &lt;/div&gt;&#10;&#10;                &lt;button&#10;                  onClick={handlePersonalInfoUpdate}&#10;                  disabled={loading}&#10;                  className=&quot;bg-primary-600 text-white px-6 py-2 rounded-md hover:bg-primary-700 focus:ring-2 focus:ring-primary-500 disabled:opacity-50 disabled:cursor-not-allowed&quot;&#10;                &gt;&#10;                  {loading ? &quot;Saving...&quot; : &quot;Save Changes&quot;}&#10;                &lt;/button&gt;&#10;              &lt;/div&gt;&#10;            )}&#10;&#10;            {/* Farm Information Tab */}&#10;            {activeTab === &quot;farm&quot; &amp;&amp; (&#10;              &lt;div className=&quot;space-y-6&quot;&gt;&#10;                &lt;h3 className=&quot;text-lg font-medium text-gray-900 dark:text-white&quot;&gt;&#10;                  Farm Information&#10;                &lt;/h3&gt;&#10;&#10;                &lt;div className=&quot;grid grid-cols-1 md:grid-cols-2 gap-6&quot;&gt;&#10;                  &lt;div&gt;&#10;                    &lt;label className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&gt;&#10;                      Farm Name *&#10;                    &lt;/label&gt;&#10;                    &lt;input&#10;                      type=&quot;text&quot;&#10;                      value={profileData.farmInfo.farmName}&#10;                      onChange={(e) =&gt;&#10;                        handleNestedChange(&quot;farmInfo&quot;, &quot;&quot;, &quot;farmName&quot;, e.target.value)&#10;                      }&#10;                      className=&quot;w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:ring-primary-500 focus:border-primary-500 dark:bg-gray-700 dark:text-white&quot;&#10;                      placeholder=&quot;Green Valley Farm&quot;&#10;                    /&gt;&#10;                  &lt;/div&gt;&#10;&#10;                  &lt;div&gt;&#10;                    &lt;label className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&gt;&#10;                      Farm Type&#10;                    &lt;/label&gt;&#10;                    &lt;select&#10;                      value={profileData.farmInfo.farmType}&#10;                      onChange={(e) =&gt;&#10;                        handleNestedChange(&quot;farmInfo&quot;, &quot;&quot;, &quot;farmType&quot;, e.target.value)&#10;                      }&#10;                      className=&quot;w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:ring-primary-500 focus:border-primary-500 dark:bg-gray-700 dark:text-white&quot;&#10;                    &gt;&#10;                      &lt;option value=&quot;&quot;&gt;Select Farm Type&lt;/option&gt;&#10;                      &lt;option value=&quot;organic&quot;&gt;Organic Farm&lt;/option&gt;&#10;                      &lt;option value=&quot;conventional&quot;&gt;Conventional Farm&lt;/option&gt;&#10;                      &lt;option value=&quot;hydroponic&quot;&gt;Hydroponic Farm&lt;/option&gt;&#10;                      &lt;option value=&quot;greenhouse&quot;&gt;Greenhouse Farm&lt;/option&gt;&#10;                      &lt;option value=&quot;mixed&quot;&gt;Mixed Farm&lt;/option&gt;&#10;                    &lt;/select&gt;&#10;                  &lt;/div&gt;&#10;&#10;                  &lt;div&gt;&#10;                    &lt;label className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&gt;&#10;                      Farm Size (acres)&#10;                    &lt;/label&gt;&#10;                    &lt;input&#10;                      type=&quot;number&quot;&#10;                      value={profileData.farmInfo.farmSize}&#10;                      onChange={(e) =&gt;&#10;                        handleNestedChange(&quot;farmInfo&quot;, &quot;&quot;, &quot;farmSize&quot;, e.target.value)&#10;                      }&#10;                      className=&quot;w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:ring-primary-500 focus:border-primary-500 dark:bg-gray-700 dark:text-white&quot;&#10;                      placeholder=&quot;10&quot;&#10;                    /&gt;&#10;                  &lt;/div&gt;&#10;&#10;                  &lt;div&gt;&#10;                    &lt;label className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&gt;&#10;                      Established Year&#10;                    &lt;/label&gt;&#10;                    &lt;input&#10;                      type=&quot;number&quot;&#10;                      value={profileData.farmInfo.establishedYear}&#10;                      onChange={(e) =&gt;&#10;                        handleNestedChange(&quot;farmInfo&quot;, &quot;&quot;, &quot;establishedYear&quot;, e.target.value)&#10;                      }&#10;                      className=&quot;w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:ring-primary-500 focus:border-primary-500 dark:bg-gray-700 dark:text-white&quot;&#10;                      placeholder=&quot;2020&quot;&#10;                    /&gt;&#10;                  &lt;/div&gt;&#10;&#10;                  &lt;div className=&quot;md:col-span-2&quot;&gt;&#10;                    &lt;label className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&gt;&#10;                      Farm Description&#10;                    &lt;/label&gt;&#10;                    &lt;textarea&#10;                      value={profileData.farmInfo.farmDescription}&#10;                      onChange={(e) =&gt;&#10;                        handleNestedChange(&quot;farmInfo&quot;, &quot;&quot;, &quot;farmDescription&quot;, e.target.value)&#10;                      }&#10;                      rows={4}&#10;                      className=&quot;w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:ring-primary-500 focus:border-primary-500 dark:bg-gray-700 dark:text-white&quot;&#10;                      placeholder=&quot;Tell customers about your farm, your farming philosophy, and what makes your products special...&quot;&#10;                    /&gt;&#10;                  &lt;/div&gt;&#10;&#10;                  &lt;div&gt;&#10;                    &lt;label className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&gt;&#10;                      Certifications (comma-separated)&#10;                    &lt;/label&gt;&#10;                    &lt;input&#10;                      type=&quot;text&quot;&#10;                      value={profileData.farmInfo.certifications.join(&quot;, &quot;)}&#10;                      onChange={(e) =&gt;&#10;                        handleArrayChange(&quot;farmInfo&quot;, &quot;certifications&quot;, e.target.value)&#10;                      }&#10;                      className=&quot;w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:ring-primary-500 focus:border-primary-500 dark:bg-gray-700 dark:text-white&quot;&#10;                      placeholder=&quot;Organic Certified, Non-GMO, USDA Organic&quot;&#10;                    /&gt;&#10;                  &lt;/div&gt;&#10;&#10;                  &lt;div&gt;&#10;                    &lt;label className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&gt;&#10;                      Farming Methods (comma-separated)&#10;                    &lt;/label&gt;&#10;                    &lt;input&#10;                      type=&quot;text&quot;&#10;                      value={profileData.farmInfo.farmingMethods.join(&quot;, &quot;)}&#10;                      onChange={(e) =&gt;&#10;                        handleArrayChange(&quot;farmInfo&quot;, &quot;farmingMethods&quot;, e.target.value)&#10;                      }&#10;                      className=&quot;w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:ring-primary-500 focus:border-primary-500 dark:bg-gray-700 dark:text-white&quot;&#10;                      placeholder=&quot;Sustainable, Pesticide-free, Crop Rotation&quot;&#10;                    /&gt;&#10;                  &lt;/div&gt;&#10;                &lt;/div&gt;&#10;&#10;                &lt;button&#10;                  onClick={handlePersonalInfoUpdate}&#10;                  disabled={loading}&#10;                  className=&quot;bg-primary-600 text-white px-6 py-2 rounded-md hover:bg-primary-700 focus:ring-2 focus:ring-primary-500 disabled:opacity-50 disabled:cursor-not-allowed&quot;&#10;                &gt;&#10;                  {loading ? &quot;Saving...&quot; : &quot;Save Farm Information&quot;}&#10;                &lt;/button&gt;&#10;              &lt;/div&gt;&#10;            )}&#10;&#10;            {/* Business Information Tab */}&#10;            {activeTab === &quot;business&quot; &amp;&amp; (&#10;              &lt;div className=&quot;space-y-6&quot;&gt;&#10;                &lt;h3 className=&quot;text-lg font-medium text-gray-900 dark:text-white&quot;&gt;&#10;                  Business Information&#10;                &lt;/h3&gt;&#10;&#10;                &lt;div className=&quot;grid grid-cols-1 md:grid-cols-2 gap-6&quot;&gt;&#10;                  &lt;div&gt;&#10;                    &lt;label className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&gt;&#10;                      Business License&#10;                    &lt;/label&gt;&#10;                    &lt;input&#10;                      type=&quot;text&quot;&#10;                      value={profileData.businessInfo.businessLicense}&#10;                      onChange={(e) =&gt;&#10;                        handleNestedChange(&quot;businessInfo&quot;, &quot;&quot;, &quot;businessLicense&quot;, e.target.value)&#10;                      }&#10;                      className=&quot;w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:ring-primary-500 focus:border-primary-500 dark:bg-gray-700 dark:text-white&quot;&#10;                    /&gt;&#10;                  &lt;/div&gt;&#10;&#10;                  &lt;div&gt;&#10;                    &lt;label className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&gt;&#10;                      Tax ID&#10;                    &lt;/label&gt;&#10;                    &lt;input&#10;                      type=&quot;text&quot;&#10;                      value={profileData.businessInfo.taxId}&#10;                      onChange={(e) =&gt;&#10;                        handleNestedChange(&quot;businessInfo&quot;, &quot;&quot;, &quot;taxId&quot;, e.target.value)&#10;                      }&#10;                      className=&quot;w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:ring-primary-500 focus:border-primary-500 dark:bg-gray-700 dark:text-white&quot;&#10;                    /&gt;&#10;                  &lt;/div&gt;&#10;&#10;                  &lt;div&gt;&#10;                    &lt;label className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&gt;&#10;                      Delivery Radius (miles)&#10;                    &lt;/label&gt;&#10;                    &lt;input&#10;                      type=&quot;number&quot;&#10;                      value={profileData.businessInfo.deliveryRadius}&#10;                      onChange={(e) =&gt;&#10;                        handleNestedChange(&quot;businessInfo&quot;, &quot;&quot;, &quot;deliveryRadius&quot;, e.target.value)&#10;                      }&#10;                      className=&quot;w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:ring-primary-500 focus:border-primary-500 dark:bg-gray-700 dark:text-white&quot;&#10;                      placeholder=&quot;25&quot;&#10;                    /&gt;&#10;                  &lt;/div&gt;&#10;&#10;                  &lt;div&gt;&#10;                    &lt;label className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&gt;&#10;                      Minimum Order ($)&#10;                    &lt;/label&gt;&#10;                    &lt;input&#10;                      type=&quot;number&quot;&#10;                      value={profileData.businessInfo.minimumOrder}&#10;                      onChange={(e) =&gt;&#10;                        handleNestedChange(&quot;businessInfo&quot;, &quot;&quot;, &quot;minimumOrder&quot;, e.target.value)&#10;                      }&#10;                      className=&quot;w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:ring-primary-500 focus:border-primary-500 dark:bg-gray-700 dark:text-white&quot;&#10;                      placeholder=&quot;25&quot;&#10;                    /&gt;&#10;                  &lt;/div&gt;&#10;&#10;                  &lt;div&gt;&#10;                    &lt;label className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&gt;&#10;                      Website&#10;                    &lt;/label&gt;&#10;                    &lt;input&#10;                      type=&quot;url&quot;&#10;                      value={profileData.businessInfo.website}&#10;                      onChange={(e) =&gt;&#10;                        handleNestedChange(&quot;businessInfo&quot;, &quot;&quot;, &quot;website&quot;, e.target.value)&#10;                      }&#10;                      className=&quot;w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:ring-primary-500 focus:border-primary-500 dark:bg-gray-700 dark:text-white&quot;&#10;                      placeholder=&quot;https://yourfarm.com&quot;&#10;                    /&gt;&#10;                  &lt;/div&gt;&#10;&#10;                  {/* Social Media */}&#10;                  &lt;div&gt;&#10;                    &lt;label className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&gt;&#10;                      Facebook&#10;                    &lt;/label&gt;&#10;                    &lt;input&#10;                      type=&quot;url&quot;&#10;                      value={profileData.businessInfo.socialMedia.facebook}&#10;                      onChange={(e) =&gt;&#10;                        handleNestedChange(&quot;businessInfo&quot;, &quot;socialMedia&quot;, &quot;facebook&quot;, e.target.value)&#10;                      }&#10;                      className=&quot;w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:ring-primary-500 focus:border-primary-500 dark:bg-gray-700 dark:text-white&quot;&#10;                      placeholder=&quot;https://facebook.com/yourfarm&quot;&#10;                    /&gt;&#10;                  &lt;/div&gt;&#10;&#10;                  &lt;div&gt;&#10;                    &lt;label className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&gt;&#10;                      Instagram&#10;                    &lt;/label&gt;&#10;                    &lt;input&#10;                      type=&quot;url&quot;&#10;                      value={profileData.businessInfo.socialMedia.instagram}&#10;                      onChange={(e) =&gt;&#10;                        handleNestedChange(&quot;businessInfo&quot;, &quot;socialMedia&quot;, &quot;instagram&quot;, e.target.value)&#10;                      }&#10;                      className=&quot;w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:ring-primary-500 focus:border-primary-500 dark:bg-gray-700 dark:text-white&quot;&#10;                      placeholder=&quot;https://instagram.com/yourfarm&quot;&#10;                    /&gt;&#10;                  &lt;/div&gt;&#10;&#10;                  &lt;div&gt;&#10;                    &lt;label className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&gt;&#10;                      Twitter&#10;                    &lt;/label&gt;&#10;                    &lt;input&#10;                      type=&quot;url&quot;&#10;                      value={profileData.businessInfo.socialMedia.twitter}&#10;                      onChange={(e) =&gt;&#10;                        handleNestedChange(&quot;businessInfo&quot;, &quot;socialMedia&quot;, &quot;twitter&quot;, e.target.value)&#10;                      }&#10;                      className=&quot;w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:ring-primary-500 focus:border-primary-500 dark:bg-gray-700 dark:text-white&quot;&#10;                      placeholder=&quot;https://twitter.com/yourfarm&quot;&#10;                    /&gt;&#10;                  &lt;/div&gt;&#10;                &lt;/div&gt;&#10;&#10;                &lt;button&#10;                  onClick={handlePersonalInfoUpdate}&#10;                  disabled={loading}&#10;                  className=&quot;bg-primary-600 text-white px-6 py-2 rounded-md hover:bg-primary-700 focus:ring-2 focus:ring-primary-500 disabled:opacity-50 disabled:cursor-not-allowed&quot;&#10;                &gt;&#10;                  {loading ? &quot;Saving...&quot; : &quot;Save Business Information&quot;}&#10;                &lt;/button&gt;&#10;              &lt;/div&gt;&#10;            )}&#10;&#10;            {/* Address Tab */}&#10;            {activeTab === &quot;address&quot; &amp;&amp; (&#10;              &lt;div className=&quot;space-y-6&quot;&gt;&#10;                &lt;h3 className=&quot;text-lg font-medium text-gray-900 dark:text-white&quot;&gt;&#10;                  Farm Address&#10;                &lt;/h3&gt;&#10;&#10;                &lt;div className=&quot;grid grid-cols-1 md:grid-cols-2 gap-6&quot;&gt;&#10;                  &lt;div className=&quot;md:col-span-2&quot;&gt;&#10;                    &lt;label className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&gt;&#10;                      Street Address&#10;                    &lt;/label&gt;&#10;                    &lt;input&#10;                      type=&quot;text&quot;&#10;                      value={profileData.address.street}&#10;                      onChange={(e) =&gt;&#10;                        handleNestedChange(&quot;address&quot;, &quot;&quot;, &quot;street&quot;, e.target.value)&#10;                      }&#10;                      className=&quot;w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:ring-primary-500 focus:border-primary-500 dark:bg-gray-700 dark:text-white&quot;&#10;                    /&gt;&#10;                  &lt;/div&gt;&#10;&#10;                  &lt;div&gt;&#10;                    &lt;label className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&gt;&#10;                      City&#10;                    &lt;/label&gt;&#10;                    &lt;input&#10;                      type=&quot;text&quot;&#10;                      value={profileData.address.city}&#10;                      onChange={(e) =&gt;&#10;                        handleNestedChange(&quot;address&quot;, &quot;&quot;, &quot;city&quot;, e.target.value)&#10;                      }&#10;                      className=&quot;w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:ring-primary-500 focus:border-primary-500 dark:bg-gray-700 dark:text-white&quot;&#10;                    /&gt;&#10;                  &lt;/div&gt;&#10;&#10;                  &lt;div&gt;&#10;                    &lt;label className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&gt;&#10;                      State/Province&#10;                    &lt;/label&gt;&#10;                    &lt;input&#10;                      type=&quot;text&quot;&#10;                      value={profileData.address.state}&#10;                      onChange={(e) =&gt;&#10;                        handleNestedChange(&quot;address&quot;, &quot;&quot;, &quot;state&quot;, e.target.value)&#10;                      }&#10;                      className=&quot;w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:ring-primary-500 focus:border-primary-500 dark:bg-gray-700 dark:text-white&quot;&#10;                    /&gt;&#10;                  &lt;/div&gt;&#10;&#10;                  &lt;div&gt;&#10;                    &lt;label className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&gt;&#10;                      ZIP/Postal Code&#10;                    &lt;/label&gt;&#10;                    &lt;input&#10;                      type=&quot;text&quot;&#10;                      value={profileData.address.zipCode}&#10;                      onChange={(e) =&gt;&#10;                        handleNestedChange(&quot;address&quot;, &quot;&quot;, &quot;zipCode&quot;, e.target.value)&#10;                      }&#10;                      className=&quot;w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:ring-primary-500 focus:border-primary-500 dark:bg-gray-700 dark:text-white&quot;&#10;                    /&gt;&#10;                  &lt;/div&gt;&#10;&#10;                  &lt;div&gt;&#10;                    &lt;label className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&gt;&#10;                      Country&#10;                    &lt;/label&gt;&#10;                    &lt;select&#10;                      value={profileData.address.country}&#10;                      onChange={(e) =&gt;&#10;                        handleNestedChange(&quot;address&quot;, &quot;&quot;, &quot;country&quot;, e.target.value)&#10;                      }&#10;                      className=&quot;w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:ring-primary-500 focus:border-primary-500 dark:bg-gray-700 dark:text-white&quot;&#10;                    &gt;&#10;                      &lt;option value=&quot;&quot;&gt;Select Country&lt;/option&gt;&#10;                      &lt;option value=&quot;US&quot;&gt;United States&lt;/option&gt;&#10;                      &lt;option value=&quot;CA&quot;&gt;Canada&lt;/option&gt;&#10;                      &lt;option value=&quot;UK&quot;&gt;United Kingdom&lt;/option&gt;&#10;                      &lt;option value=&quot;AU&quot;&gt;Australia&lt;/option&gt;&#10;                      &lt;option value=&quot;DE&quot;&gt;Germany&lt;/option&gt;&#10;                      &lt;option value=&quot;FR&quot;&gt;France&lt;/option&gt;&#10;                    &lt;/select&gt;&#10;                  &lt;/div&gt;&#10;                &lt;/div&gt;&#10;&#10;                &lt;button&#10;                  onClick={handlePersonalInfoUpdate}&#10;                  disabled={loading}&#10;                  className=&quot;bg-primary-600 text-white px-6 py-2 rounded-md hover:bg-primary-700 focus:ring-2 focus:ring-primary-500 disabled:opacity-50 disabled:cursor-not-allowed&quot;&#10;                &gt;&#10;                  {loading ? &quot;Saving...&quot; : &quot;Save Address&quot;}&#10;                &lt;/button&gt;&#10;              &lt;/div&gt;&#10;            )}&#10;&#10;            {/* Preferences Tab */}&#10;            {activeTab === &quot;preferences&quot; &amp;&amp; (&#10;              &lt;div className=&quot;space-y-6&quot;&gt;&#10;                &lt;h3 className=&quot;text-lg font-medium text-gray-900 dark:text-white&quot;&gt;&#10;                  Preferences&#10;                &lt;/h3&gt;&#10;&#10;                &lt;div className=&quot;space-y-6&quot;&gt;&#10;                  &lt;div&gt;&#10;                    &lt;h4 className=&quot;text-md font-medium text-gray-900 dark:text-white mb-4&quot;&gt;&#10;                      Notification Preferences&#10;                    &lt;/h4&gt;&#10;                    &lt;div className=&quot;space-y-3&quot;&gt;&#10;                      &lt;label className=&quot;flex items-center&quot;&gt;&#10;                        &lt;input&#10;                          type=&quot;checkbox&quot;&#10;                          checked={profileData.preferences.notifications.email}&#10;                          onChange={(e) =&gt;&#10;                            handleNestedChange(&quot;preferences&quot;, &quot;notifications&quot;, &quot;email&quot;, e.target.checked)&#10;                          }&#10;                          className=&quot;rounded border-gray-300 text-primary-600 shadow-sm focus:border-primary-300 focus:ring focus:ring-primary-200 focus:ring-opacity-50&quot;&#10;                        /&gt;&#10;                        &lt;span className=&quot;ml-2 text-sm text-gray-700 dark:text-gray-300&quot;&gt;&#10;                          Email notifications&#10;                        &lt;/span&gt;&#10;                      &lt;/label&gt;&#10;&#10;                      &lt;label className=&quot;flex items-center&quot;&gt;&#10;                        &lt;input&#10;                          type=&quot;checkbox&quot;&#10;                          checked={profileData.preferences.notifications.sms}&#10;                          onChange={(e) =&gt;&#10;                            handleNestedChange(&quot;preferences&quot;, &quot;notifications&quot;, &quot;sms&quot;, e.target.checked)&#10;                          }&#10;                          className=&quot;rounded border-gray-300 text-primary-600 shadow-sm focus:border-primary-300 focus:ring focus:ring-primary-200 focus:ring-opacity-50&quot;&#10;                        /&gt;&#10;                        &lt;span className=&quot;ml-2 text-sm text-gray-700 dark:text-gray-300&quot;&gt;&#10;                          SMS notifications&#10;                        &lt;/span&gt;&#10;                      &lt;/label&gt;&#10;&#10;                      &lt;label className=&quot;flex items-center&quot;&gt;&#10;                        &lt;input&#10;                          type=&quot;checkbox&quot;&#10;                          checked={profileData.preferences.notifications.orderUpdates}&#10;                          onChange={(e) =&gt;&#10;                            handleNestedChange(&quot;preferences&quot;, &quot;notifications&quot;, &quot;orderUpdates&quot;, e.target.checked)&#10;                          }&#10;                          className=&quot;rounded border-gray-300 text-primary-600 shadow-sm focus:border-primary-300 focus:ring focus:ring-primary-200 focus:ring-opacity-50&quot;&#10;                        /&gt;&#10;                        &lt;span className=&quot;ml-2 text-sm text-gray-700 dark:text-gray-300&quot;&gt;&#10;                          Order status updates&#10;                        &lt;/span&gt;&#10;                      &lt;/label&gt;&#10;&#10;                      &lt;label className=&quot;flex items-center&quot;&gt;&#10;                        &lt;input&#10;                          type=&quot;checkbox&quot;&#10;                          checked={profileData.preferences.notifications.lowStockAlerts}&#10;                          onChange={(e) =&gt;&#10;                            handleNestedChange(&quot;preferences&quot;, &quot;notifications&quot;, &quot;lowStockAlerts&quot;, e.target.checked)&#10;                          }&#10;                          className=&quot;rounded border-gray-300 text-primary-600 shadow-sm focus:border-primary-300 focus:ring focus:ring-primary-200 focus:ring-opacity-50&quot;&#10;                        /&gt;&#10;                        &lt;span className=&quot;ml-2 text-sm text-gray-700 dark:text-gray-300&quot;&gt;&#10;                          Low stock alerts&#10;                        &lt;/span&gt;&#10;                      &lt;/label&gt;&#10;&#10;                      &lt;label className=&quot;flex items-center&quot;&gt;&#10;                        &lt;input&#10;                          type=&quot;checkbox&quot;&#10;                          checked={profileData.preferences.notifications.customerMessages}&#10;                          onChange={(e) =&gt;&#10;                            handleNestedChange(&quot;preferences&quot;, &quot;notifications&quot;, &quot;customerMessages&quot;, e.target.checked)&#10;                          }&#10;                          className=&quot;rounded border-gray-300 text-primary-600 shadow-sm focus:border-primary-300 focus:ring focus:ring-primary-200 focus:ring-opacity-50&quot;&#10;                        /&gt;&#10;                        &lt;span className=&quot;ml-2 text-sm text-gray-700 dark:text-gray-300&quot;&gt;&#10;                          Customer messages&#10;                        &lt;/span&gt;&#10;                      &lt;/label&gt;&#10;&#10;                      &lt;label className=&quot;flex items-center&quot;&gt;&#10;                        &lt;input&#10;                          type=&quot;checkbox&quot;&#10;                          checked={profileData.preferences.notifications.marketingUpdates}&#10;                          onChange={(e) =&gt;&#10;                            handleNestedChange(&quot;preferences&quot;, &quot;notifications&quot;, &quot;marketingUpdates&quot;, e.target.checked)&#10;                          }&#10;                          className=&quot;rounded border-gray-300 text-primary-600 shadow-sm focus:border-primary-300 focus:ring focus:ring-primary-200 focus:ring-opacity-50&quot;&#10;                        /&gt;&#10;                        &lt;span className=&quot;ml-2 text-sm text-gray-700 dark:text-gray-300&quot;&gt;&#10;                          Marketing updates&#10;                        &lt;/span&gt;&#10;                      &lt;/label&gt;&#10;                    &lt;/div&gt;&#10;                  &lt;/div&gt;&#10;&#10;                  &lt;div&gt;&#10;                    &lt;h4 className=&quot;text-md font-medium text-gray-900 dark:text-white mb-4&quot;&gt;&#10;                      Business Preferences&#10;                    &lt;/h4&gt;&#10;                    &lt;div className=&quot;space-y-3&quot;&gt;&#10;                      &lt;label className=&quot;flex items-center&quot;&gt;&#10;                        &lt;input&#10;                          type=&quot;checkbox&quot;&#10;                          checked={profileData.preferences.autoAcceptOrders}&#10;                          onChange={(e) =&gt;&#10;                            handleNestedChange(&quot;preferences&quot;, &quot;&quot;, &quot;autoAcceptOrders&quot;, e.target.checked)&#10;                          }&#10;                          className=&quot;rounded border-gray-300 text-primary-600 shadow-sm focus:border-primary-300 focus:ring focus:ring-primary-200 focus:ring-opacity-50&quot;&#10;                        /&gt;&#10;                        &lt;span className=&quot;ml-2 text-sm text-gray-700 dark:text-gray-300&quot;&gt;&#10;                          Auto-accept orders&#10;                        &lt;/span&gt;&#10;                      &lt;/label&gt;&#10;&#10;                      &lt;label className=&quot;flex items-center&quot;&gt;&#10;                        &lt;input&#10;                          type=&quot;checkbox&quot;&#10;                          checked={profileData.preferences.showFarmLocation}&#10;                          onChange={(e) =&gt;&#10;                            handleNestedChange(&quot;preferences&quot;, &quot;&quot;, &quot;showFarmLocation&quot;, e.target.checked)&#10;                          }&#10;                          className=&quot;rounded border-gray-300 text-primary-600 shadow-sm focus:border-primary-300 focus:ring focus:ring-primary-200 focus:ring-opacity-50&quot;&#10;                        /&gt;&#10;                        &lt;span className=&quot;ml-2 text-sm text-gray-700 dark:text-gray-300&quot;&gt;&#10;                          Show farm location to customers&#10;                        &lt;/span&gt;&#10;                      &lt;/label&gt;&#10;                    &lt;/div&gt;&#10;                  &lt;/div&gt;&#10;&#10;                  &lt;div className=&quot;grid grid-cols-1 md:grid-cols-2 gap-6&quot;&gt;&#10;                    &lt;div&gt;&#10;                      &lt;label className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&gt;&#10;                        Language&#10;                      &lt;/label&gt;&#10;                      &lt;select&#10;                        value={profileData.preferences.language}&#10;                        onChange={(e) =&gt;&#10;                          handleNestedChange(&quot;preferences&quot;, &quot;&quot;, &quot;language&quot;, e.target.value)&#10;                        }&#10;                        className=&quot;w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:ring-primary-500 focus:border-primary-500 dark:bg-gray-700 dark:text-white&quot;&#10;                      &gt;&#10;                        &lt;option value=&quot;en&quot;&gt;English&lt;/option&gt;&#10;                        &lt;option value=&quot;es&quot;&gt;Spanish&lt;/option&gt;&#10;                        &lt;option value=&quot;fr&quot;&gt;French&lt;/option&gt;&#10;                        &lt;option value=&quot;de&quot;&gt;German&lt;/option&gt;&#10;                      &lt;/select&gt;&#10;                    &lt;/div&gt;&#10;&#10;                    &lt;div&gt;&#10;                      &lt;label className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&gt;&#10;                        Currency&#10;                      &lt;/label&gt;&#10;                      &lt;select&#10;                        value={profileData.preferences.currency}&#10;                        onChange={(e) =&gt;&#10;                          handleNestedChange(&quot;preferences&quot;, &quot;&quot;, &quot;currency&quot;, e.target.value)&#10;                        }&#10;                        className=&quot;w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:ring-primary-500 focus:border-primary-500 dark:bg-gray-700 dark:text-white&quot;&#10;                      &gt;&#10;                        &lt;option value=&quot;USD&quot;&gt;USD ($)&lt;/option&gt;&#10;                        &lt;option value=&quot;EUR&quot;&gt;EUR (€)&lt;/option&gt;&#10;                        &lt;option value=&quot;GBP&quot;&gt;GBP (£)&lt;/option&gt;&#10;                        &lt;option value=&quot;CAD&quot;&gt;CAD ($)&lt;/option&gt;&#10;                      &lt;/select&gt;&#10;                    &lt;/div&gt;&#10;                  &lt;/div&gt;&#10;                &lt;/div&gt;&#10;&#10;                &lt;button&#10;                  onClick={handlePersonalInfoUpdate}&#10;                  disabled={loading}&#10;                  className=&quot;bg-primary-600 text-white px-6 py-2 rounded-md hover:bg-primary-700 focus:ring-2 focus:ring-primary-500 disabled:opacity-50 disabled:cursor-not-allowed&quot;&#10;                &gt;&#10;                  {loading ? &quot;Saving...&quot; : &quot;Save Preferences&quot;}&#10;                &lt;/button&gt;&#10;              &lt;/div&gt;&#10;            )}&#10;&#10;            {/* Security Tab */}&#10;            {activeTab === &quot;security&quot; &amp;&amp; (&#10;              &lt;div className=&quot;space-y-6&quot;&gt;&#10;                &lt;h3 className=&quot;text-lg font-medium text-gray-900 dark:text-white&quot;&gt;&#10;                  Security Settings&#10;                &lt;/h3&gt;&#10;&#10;                &lt;div className=&quot;max-w-md space-y-6&quot;&gt;&#10;                  &lt;div&gt;&#10;                    &lt;label className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&gt;&#10;                      Current Password&#10;                    &lt;/label&gt;&#10;                    &lt;input&#10;                      type=&quot;password&quot;&#10;                      value={profileData.security.currentPassword}&#10;                      onChange={(e) =&gt;&#10;                        handleNestedChange(&quot;security&quot;, &quot;&quot;, &quot;currentPassword&quot;, e.target.value)&#10;                      }&#10;                      className=&quot;w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:ring-primary-500 focus:border-primary-500 dark:bg-gray-700 dark:text-white&quot;&#10;                    /&gt;&#10;                  &lt;/div&gt;&#10;&#10;                  &lt;div&gt;&#10;                    &lt;label className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&gt;&#10;                      New Password&#10;                    &lt;/label&gt;&#10;                    &lt;input&#10;                      type=&quot;password&quot;&#10;                      value={profileData.security.newPassword}&#10;                      onChange={(e) =&gt;&#10;                        handleNestedChange(&quot;security&quot;, &quot;&quot;, &quot;newPassword&quot;, e.target.value)&#10;                      }&#10;                      className=&quot;w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:ring-primary-500 focus:border-primary-500 dark:bg-gray-700 dark:text-white&quot;&#10;                    /&gt;&#10;                  &lt;/div&gt;&#10;&#10;                  &lt;div&gt;&#10;                    &lt;label className=&quot;block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2&quot;&gt;&#10;                      Confirm New Password&#10;                    &lt;/label&gt;&#10;                    &lt;input&#10;                      type=&quot;password&quot;&#10;                      value={profileData.security.confirmPassword}&#10;                      onChange={(e) =&gt;&#10;                        handleNestedChange(&quot;security&quot;, &quot;&quot;, &quot;confirmPassword&quot;, e.target.value)&#10;                      }&#10;                      className=&quot;w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:ring-primary-500 focus:border-primary-500 dark:bg-gray-700 dark:text-white&quot;&#10;                    /&gt;&#10;                  &lt;/div&gt;&#10;&#10;                  &lt;button&#10;                    onClick={handlePasswordChange}&#10;                    disabled={loading}&#10;                    className=&quot;bg-primary-600 text-white px-6 py-2 rounded-md hover:bg-primary-700 focus:ring-2 focus:ring-primary-500 disabled:opacity-50 disabled:cursor-not-allowed&quot;&#10;                  &gt;&#10;                    {loading ? &quot;Updating...&quot; : &quot;Update Password&quot;}&#10;                  &lt;/button&gt;&#10;                &lt;/div&gt;&#10;              &lt;/div&gt;&#10;            )}&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/check-mismatch.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/check-mismatch.js" />
              <option name="updatedContent" value="// Simple script to check the review-product mismatch&#10;const { MongoClient } = require('mongodb');&#10;&#10;async function checkMismatch() {&#10;  const client = new MongoClient('mongodb://localhost:27017');&#10;  await client.connect();&#10;  const db = client.db('farmfresh');&#10;  &#10;  console.log(' Checking product-review mismatch...\n');&#10;  &#10;  // Get all products&#10;  const products = await db.collection('products').find({}).toArray();&#10;  console.log(` Total products: ${products.length}`);&#10;  console.log('Product IDs:', products.slice(0, 5).map(p =&gt; p._id.toString()));&#10;  &#10;  // Get all reviews  &#10;  const reviews = await db.collection('reviews').find({}).toArray();&#10;  console.log(`\n Total reviews: ${reviews.length}`);&#10;  console.log('Review product IDs:', reviews.map(r =&gt; r.productId));&#10;  &#10;  // Check for matches&#10;  const productIds = products.map(p =&gt; p._id.toString());&#10;  const reviewProductIds = reviews.map(r =&gt; r.productId);&#10;  &#10;  const matches = productIds.filter(pid =&gt; reviewProductIds.includes(pid));&#10;  console.log(`\n✅ Matching product-review pairs: ${matches.length}`);&#10;  &#10;  if (matches.length &gt; 0) {&#10;    console.log('Matched IDs:', matches);&#10;    &#10;    // Show which products have reviews&#10;    for (const matchId of matches) {&#10;      const product = products.find(p =&gt; p._id.toString() === matchId);&#10;      const productReviews = reviews.filter(r =&gt; r.productId === matchId);&#10;      console.log(`- ${product.name}: ${productReviews.length} reviews`);&#10;    }&#10;  } else {&#10;    console.log('\n❌ No matches found!');&#10;    console.log('This means the existing reviews belong to products that no longer exist');&#10;    console.log('or have different IDs than the current products in the database');&#10;  }&#10;  &#10;  await client.close();&#10;}&#10;&#10;checkMismatch().catch(console.error);" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/components/Navigation.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/components/Navigation.js" />
              <option name="originalContent" value="&quot;use client&quot;;&#10;&#10;import Link from &quot;next/link&quot;;&#10;import { useAuth } from &quot;@/contexts/AuthContext&quot;;&#10;import { useTheme } from &quot;@/contexts/ThemeContext&quot;;&#10;import { useFavorites } from &quot;@/contexts/FavoritesContext&quot;;&#10;import { useCart } from &quot;@/contexts/CartContext&quot;;&#10;" />
              <option name="updatedContent" value="&quot;use client&quot;;&#10;&#10;import Link from &quot;next/link&quot;;&#10;import { useAuth } from &quot;@/contexts/AuthContext&quot;;&#10;import { useTheme } from &quot;@/contexts/ThemeContext&quot;;&#10;import { useFavorites } from &quot;@/contexts/FavoritesContext&quot;;&#10;import { useCart } from &quot;@/contexts/CartContext&quot;;&#10;import { useMessaging } from &quot;@/contexts/MessagingContext&quot;;&#10;import { signOut } from &quot;next-auth/react&quot;;&#10;import { useState, useEffect } from &quot;react&quot;;&#10;import { usePathname, useRouter } from &quot;next/navigation&quot;;&#10;&#10;export default function Navigation() {&#10;  const { user, isAuthenticated, logout, updateUser } = useAuth();&#10;  const { isDarkMode, toggleDarkMode } = useTheme();&#10;  const { favorites } = useFavorites();&#10;  const { cartItems, cartCount } = useCart();&#10;  const { totalUnreadCount } = useMessaging();&#10;  const [showUserMenu, setShowUserMenu] = useState(false);&#10;  const [updatedUserName, setUpdatedUserName] = useState(user?.name || &quot;&quot;);&#10;  const pathname = usePathname();&#10;  const router = useRouter();&#10;&#10;  // Fetch updated name from the database for farmers&#10;  useEffect(() =&gt; {&#10;    async function fetchUpdatedUserName() {&#10;      if (!user?.email || user?.userType !== &quot;farmer&quot;) return;&#10;&#10;      try {&#10;        console.log(&quot;Navigation: Fetching updated name for:&quot;, user.email);&#10;&#10;        // Fetch the latest farmer data with cache busting&#10;        const response = await fetch(&#10;          `/api/farmers?email=${encodeURIComponent(user.email)}&amp;exactMatch=true&amp;_t=${Date.now()}`,&#10;          {&#10;            headers: {&#10;              &quot;Cache-Control&quot;: &quot;no-cache, no-store, must-revalidate&quot;,&#10;              Pragma: &quot;no-cache&quot;,&#10;            },&#10;            cache: &quot;no-store&quot;,&#10;          },&#10;        );&#10;&#10;        if (response.ok) {&#10;          const data = await response.json();&#10;&#10;          if (data &amp;&amp; data.farmers &amp;&amp; data.farmers.length &gt; 0) {&#10;            // Find the farmer with the matching email&#10;            const farmer = data.farmers.find((f) =&gt; f.email === user.email);&#10;            if (farmer &amp;&amp; farmer.name !== user.name) {&#10;              console.log(&#10;                &quot;Navigation: Updating user name from&quot;,&#10;                user.name,&#10;                &quot;to&quot;,&#10;                farmer.name,&#10;              );&#10;              setUpdatedUserName(farmer.name);&#10;&#10;              // Also update the Auth context&#10;              updateUser({&#10;                ...user,&#10;                name: farmer.name,&#10;              });&#10;            }&#10;          }&#10;        }&#10;      } catch (error) {&#10;        console.error(&quot;Navigation: Error fetching updated name:&quot;, error);&#10;      }&#10;    }&#10;&#10;    fetchUpdatedUserName();&#10;  }, [user?.email, user?.userType]);&#10;&#10;  // Pages that should have simplified navigation (no search/cart)&#10;  const simplifiedPages = [&#10;    &quot;/login&quot;,&#10;    &quot;/register&quot;,&#10;    &quot;/forgot-password&quot;,&#10;    &quot;/reset-password&quot;,&#10;    &quot;/cart&quot;,&#10;    &quot;/create&quot;,&#10;    &quot;/manage&quot;,&#10;    &quot;/payment&quot;,&#10;    &quot;/bookings&quot;,&#10;    &quot;/farmer-orders&quot;,&#10;    &quot;/review&quot;,&#10;  ];&#10;&#10;  // Details page gets minimal navigation (only logo + dark mode)&#10;  const isDetailsPage = pathname === &quot;/details&quot;;&#10;  const isFarmersPage = pathname === &quot;/farmers&quot;;&#10;  const shouldShowSearchAndCart =&#10;    !simplifiedPages.includes(pathname) &amp;&amp; !isDetailsPage;&#10;  const shouldShowNavLinks = !isDetailsPage;&#10;  const shouldShowUserAuth = !isDetailsPage;&#10;&#10;  // Different search placeholders based on page&#10;  const getSearchPlaceholder = () =&gt; {&#10;    if (isFarmersPage) {&#10;      return &quot;Search farmers...&quot;;&#10;    }&#10;    return &quot;Search products...&quot;;&#10;  };&#10;&#10;  const handleLogout = async () =&gt; {&#10;    try {&#10;      // Close the user menu first&#10;      setShowUserMenu(false);&#10;&#10;      // Clear any existing modals or intercepted routes by going to home first&#10;      router.replace(&quot;/&quot;);&#10;&#10;      // Small delay to ensure navigation completes before sign out&#10;      await new Promise((resolve) =&gt; setTimeout(resolve, 100));&#10;&#10;      // Sign out from NextAuth and clear context&#10;      await signOut({ redirect: false });&#10;      logout();&#10;&#10;      // Ensure we stay on home page and refresh&#10;      router.replace(&quot;/&quot;);&#10;&#10;      // Force a hard refresh to clear any modal states&#10;      window.location.href = &quot;/&quot;;&#10;    } catch (error) {&#10;      console.error(&quot;Logout error:&quot;, error);&#10;      // Even if there's an error, still redirect to home&#10;      window.location.href = &quot;/&quot;;&#10;    }&#10;  };&#10;&#10;  return (&#10;    &lt;nav className=&quot;bg-white dark:bg-gray-800 shadow-lg sticky top-0 z-50&quot;&gt;&#10;      &lt;div className=&quot;max-w-7xl mx-auto px-4 sm:px-6 lg:px-8&quot;&gt;&#10;        &lt;div className=&quot;flex justify-between items-center h-16&quot;&gt;&#10;          {/* Logo */}&#10;          &lt;Link href=&quot;/&quot; className=&quot;flex items-center space-x-3&quot;&gt;&#10;            &lt;div className=&quot;bg-primary-500 p-2 rounded-lg&quot;&gt;&#10;              &lt;i className=&quot;fas fa-seedling text-white text-xl&quot;&gt;&lt;/i&gt;&#10;            &lt;/div&gt;&#10;            &lt;div&gt;&#10;              &lt;h1 className=&quot;text-xl font-bold text-gray-900 dark:text-white&quot;&gt;&#10;                FarmFresh&#10;              &lt;/h1&gt;&#10;              &lt;p className=&quot;text-xs text-gray-600 dark:text-gray-400&quot;&gt;&#10;                Local Farmer Booking&#10;              &lt;/p&gt;&#10;            &lt;/div&gt;&#10;          &lt;/Link&gt;&#10;&#10;          {/* Search Bar (conditional) */}&#10;          {shouldShowSearchAndCart &amp;&amp; (&#10;            &lt;div className=&quot;hidden md:flex flex-1 max-w-lg mx-8&quot;&gt;&#10;              &lt;div className=&quot;relative w-full&quot;&gt;&#10;                &lt;input&#10;                  type=&quot;text&quot;&#10;                  placeholder={getSearchPlaceholder()}&#10;                  className=&quot;w-full pl-10 pr-4 py-2 border border-gray-300 dark:border-gray-600 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-transparent dark:bg-gray-700 dark:text-white&quot;&#10;                /&gt;&#10;                &lt;div className=&quot;absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none&quot;&gt;&#10;                  &lt;i className=&quot;fas fa-search text-gray-400&quot;&gt;&lt;/i&gt;&#10;                &lt;/div&gt;&#10;              &lt;/div&gt;&#10;            &lt;/div&gt;&#10;          )}&#10;&#10;          {/* Navigation Links (conditional) */}&#10;          {shouldShowNavLinks &amp;&amp; (&#10;            &lt;div className=&quot;hidden lg:flex items-center space-x-8&quot;&gt;&#10;              &lt;Link&#10;                href=&quot;/&quot;&#10;                className={`text-gray-700 dark:text-gray-300 hover:text-primary-600 dark:hover:text-primary-400 transition ${&#10;                  pathname === &quot;/&quot;&#10;                    ? &quot;text-primary-600 dark:text-primary-400&quot;&#10;                    : &quot;&quot;&#10;                }`}&#10;              &gt;&#10;                Home&#10;              &lt;/Link&gt;&#10;              &lt;Link&#10;                href=&quot;/products&quot;&#10;                className={`text-gray-700 dark:text-gray-300 hover:text-primary-600 dark:hover:text-primary-400 transition ${&#10;                  pathname === &quot;/products&quot;&#10;                    ? &quot;text-primary-600 dark:text-primary-400&quot;&#10;                    : &quot;&quot;&#10;                }`}&#10;              &gt;&#10;                Products&#10;              &lt;/Link&gt;&#10;              &lt;Link&#10;                href=&quot;/farmers&quot;&#10;                className={`text-gray-700 dark:text-gray-300 hover:text-primary-600 dark:hover:text-primary-400 transition ${&#10;                  pathname === &quot;/farmers&quot;&#10;                    ? &quot;text-primary-600 dark:text-primary-400&quot;&#10;                    : &quot;&quot;&#10;                }`}&#10;              &gt;&#10;                Farmers&#10;              &lt;/Link&gt;&#10;&#10;              {/* Show different menu items based on user type */}&#10;              {isAuthenticated &amp;&amp; user?.userType === &quot;farmer&quot; &amp;&amp; (&#10;                &lt;&gt;&#10;                  &lt;Link&#10;                    href=&quot;/create&quot;&#10;                    className={`text-gray-700 dark:text-gray-300 hover:text-primary-600 dark:hover:text-primary-400 transition ${&#10;                      pathname === &quot;/create&quot;&#10;                        ? &quot;text-primary-600 dark:text-primary-400&quot;&#10;                        : &quot;&quot;&#10;                    }`}&#10;                  &gt;&#10;                    Add Product&#10;                  &lt;/Link&gt;&#10;                  &lt;Link&#10;                    href=&quot;/manage&quot;&#10;                    className={`text-gray-700 dark:text-gray-300 hover:text-primary-600 dark:hover:text-primary-400 transition ${&#10;                      pathname === &quot;/manage&quot;&#10;                        ? &quot;text-primary-600 dark:text-primary-400&quot;&#10;                        : &quot;&quot;&#10;                    }`}&#10;                  &gt;&#10;                    Manage Products&#10;                  &lt;/Link&gt;&#10;                &lt;/&gt;&#10;              )}&#10;&#10;              {/* Show My Orders for regular users */}&#10;              {isAuthenticated &amp;&amp; user?.userType !== &quot;farmer&quot; &amp;&amp; (&#10;                &lt;Link&#10;                  href=&quot;/bookings&quot;&#10;                  className={`text-gray-700 dark:text-gray-300 hover:text-primary-600 dark:hover:text-primary-400 transition ${&#10;                    pathname === &quot;/bookings&quot;&#10;                      ? &quot;text-primary-600 dark:text-primary-400&quot;&#10;                      : &quot;&quot;&#10;                  }`}&#10;                &gt;&#10;                  My Orders&#10;                &lt;/Link&gt;&#10;              )}&#10;&#10;              &lt;Link&#10;                href=&quot;/about&quot;&#10;                className={`text-gray-700 dark:text-gray-300 hover:text-primary-600 dark:hover:text-primary-400 transition ${&#10;                  pathname === &quot;/about&quot;&#10;                    ? &quot;text-primary-600 dark:text-primary-400&quot;&#10;                    : &quot;&quot;&#10;                }`}&#10;              &gt;&#10;                About&#10;              &lt;/Link&gt;&#10;            &lt;/div&gt;&#10;          )}&#10;&#10;          {/* Right side icons and user menu */}&#10;          &lt;div className=&quot;flex items-center space-x-4&quot;&gt;&#10;            {/* Cart and Favorites (only for authenticated users and not on simplified pages) */}&#10;            {shouldShowSearchAndCart &amp;&amp; isAuthenticated &amp;&amp; (&#10;              &lt;&gt;&#10;                {/* Messages */}&#10;                &lt;Link&#10;                  href=&quot;/messages&quot;&#10;                  className=&quot;text-gray-700 dark:text-gray-300 hover:text-primary-600 dark:hover:text-primary-400 transition relative&quot;&#10;                  title=&quot;Messages&quot;&#10;                &gt;&#10;                  &lt;i className=&quot;far fa-envelope text-xl&quot;&gt;&lt;/i&gt;&#10;                  {totalUnreadCount &gt; 0 &amp;&amp; (&#10;                    &lt;span className=&quot;absolute -top-2 -right-2 bg-red-500 text-white text-xs rounded-full h-5 w-5 flex items-center justify-center&quot;&gt;&#10;                      {totalUnreadCount &gt; 9 ? &quot;9+&quot; : totalUnreadCount}&#10;                    &lt;/span&gt;&#10;                  )}&#10;                &lt;/Link&gt;&#10;                &#10;                &lt;Link&#10;                  href=&quot;/favorites&quot;&#10;                  className=&quot;text-gray-700 dark:text-gray-300 hover:text-primary-600 dark:hover:text-primary-400 transition relative&quot;&#10;                &gt;&#10;                  &lt;i className=&quot;far fa-heart text-xl&quot;&gt;&lt;/i&gt;&#10;                  {favorites.length &gt; 0 &amp;&amp; (&#10;                    &lt;span className=&quot;absolute -top-2 -right-2 bg-primary-600 text-white text-xs rounded-full h-5 w-5 flex items-center justify-center&quot;&gt;&#10;                      {favorites.length}&#10;                    &lt;/span&gt;&#10;                  )}&#10;                &lt;/Link&gt;&#10;                &lt;Link&#10;                  href=&quot;/cart&quot;&#10;                  className=&quot;text-gray-700 dark:text-gray-300 hover:text-primary-600 dark:hover:text-primary-400 transition relative&quot;&#10;                &gt;&#10;                  &lt;i className=&quot;fas fa-shopping-cart text-xl&quot;&gt;&lt;/i&gt;&#10;                  {cartCount &gt; 0 &amp;&amp; (&#10;                    &lt;span className=&quot;absolute -top-2 -right-2 bg-primary-600 text-white text-xs rounded-full h-5 w-5 flex items-center justify-center&quot;&gt;&#10;                      {cartCount}&#10;                    &lt;/span&gt;&#10;                  )}&#10;                &lt;/Link&gt;&#10;              &lt;/&gt;&#10;            )}&#10;&#10;            {/* Dark mode toggle */}&#10;            &lt;button&#10;              onClick={toggleDarkMode}&#10;              className=&quot;text-gray-700 dark:text-gray-300 hover:text-primary-600 dark:hover:text-primary-400 transition&quot;&#10;              title={&#10;                isDarkMode ? &quot;Switch to light mode&quot; : &quot;Switch to dark mode&quot;&#10;              }&#10;            &gt;&#10;              {isDarkMode ? (&#10;                &lt;i className=&quot;fas fa-sun text-xl&quot;&gt;&lt;/i&gt;&#10;              ) : (&#10;                &lt;i className=&quot;fas fa-moon text-xl&quot;&gt;&lt;/i&gt;&#10;              )}&#10;            &lt;/button&gt;&#10;&#10;            {/* User Authentication (conditional) */}&#10;            {shouldShowUserAuth &amp;&amp; (&#10;              &lt;&gt;&#10;                {isAuthenticated ? (&#10;                  &lt;div className=&quot;relative&quot;&gt;&#10;                    &lt;button&#10;                      onClick={() =&gt; setShowUserMenu(!showUserMenu)}&#10;                      className=&quot;flex items-center space-x-2 text-gray-700 dark:text-gray-300 hover:text-primary-600 dark:hover:text-primary-400 transition&quot;&#10;                    &gt;&#10;                      &lt;div className=&quot;w-8 h-8 bg-primary-500 rounded-full flex items-center justify-center&quot;&gt;&#10;                        &lt;span className=&quot;text-white text-sm font-medium&quot;&gt;&#10;                          {user?.name?.charAt(0)?.toUpperCase() || &quot;U&quot;}&#10;                        &lt;/span&gt;&#10;                      &lt;/div&gt;&#10;                      &lt;span className=&quot;hidden md:block&quot;&gt;{user?.name}&lt;/span&gt;&#10;                      &lt;i className=&quot;fas fa-chevron-down text-sm&quot;&gt;&lt;/i&gt;&#10;                    &lt;/button&gt;&#10;&#10;                    {/* User Dropdown Menu */}&#10;                    {showUserMenu &amp;&amp; (&#10;                      &lt;div className=&quot;absolute right-0 mt-2 w-48 bg-white dark:bg-gray-800 rounded-lg shadow-lg border border-gray-200 dark:border-gray-700 py-2&quot;&gt;&#10;                        &lt;div className=&quot;px-4 py-2 border-b border-gray-200 dark:border-gray-700&quot;&gt;&#10;                          &lt;p className=&quot;text-sm font-medium text-gray-900 dark:text-white&quot;&gt;&#10;                            {user?.name}&#10;                          &lt;/p&gt;&#10;                          &lt;p className=&quot;text-xs text-gray-600 dark:text-gray-400&quot;&gt;&#10;                            {user?.email}&#10;                          &lt;/p&gt;&#10;                          &lt;p className=&quot;text-xs text-primary-600 dark:text-primary-400 capitalize&quot;&gt;&#10;                            {user?.userType || &quot;User&quot;}&#10;                          &lt;/p&gt;&#10;                        &lt;/div&gt;&#10;&#10;                        {/* Farmer-specific menu items */}&#10;                        {user?.userType === &quot;farmer&quot; &amp;&amp; (&#10;                          &lt;&gt;&#10;                            &lt;Link&#10;                              href=&quot;/farmer-orders&quot;&#10;                              className=&quot;block px-4 py-2 text-sm text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700&quot;&#10;                              onClick={() =&gt; setShowUserMenu(false)}&#10;                            &gt;&#10;                              &lt;i className=&quot;fas fa-clipboard-list mr-2&quot;&gt;&lt;/i&gt;&#10;                              Order Management&#10;                            &lt;/Link&gt;&#10;                            &lt;Link&#10;                              href=&quot;/create&quot;&#10;                              className=&quot;block px-4 py-2 text-sm text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700&quot;&#10;                              onClick={() =&gt; setShowUserMenu(false)}&#10;                            &gt;&#10;                              &lt;i className=&quot;fas fa-plus mr-2&quot;&gt;&lt;/i&gt;&#10;                              Add Product&#10;                            &lt;/Link&gt;&#10;                            &lt;Link&#10;                              href=&quot;/manage&quot;&#10;                              className=&quot;block px-4 py-2 text-sm text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700&quot;&#10;                              onClick={() =&gt; setShowUserMenu(false)}&#10;                            &gt;&#10;                              &lt;i className=&quot;fas fa-cog mr-2&quot;&gt;&lt;/i&gt;&#10;                              Manage Products&#10;                            &lt;/Link&gt;&#10;                          &lt;/&gt;&#10;                        )}&#10;&#10;                        {/* Regular user menu items */}&#10;                        {user?.userType !== &quot;farmer&quot; &amp;&amp; (&#10;                          &lt;&gt;&#10;                            &lt;Link&#10;                              href=&quot;/bookings&quot;&#10;                              className=&quot;block px-4 py-2 text-sm text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700&quot;&#10;                              onClick={() =&gt; setShowUserMenu(false)}&#10;                            &gt;&#10;                              &lt;i className=&quot;fas fa-list mr-2&quot;&gt;&lt;/i&gt;&#10;                              My Orders&#10;                            &lt;/Link&gt;&#10;                            &lt;Link&#10;                              href=&quot;/favorites&quot;&#10;                              className=&quot;block px-4 py-2 text-sm text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700&quot;&#10;                              onClick={() =&gt; setShowUserMenu(false)}&#10;                            &gt;&#10;                              &lt;i className=&quot;fas fa-heart mr-2&quot;&gt;&lt;/i&gt;&#10;                              Favorites&#10;                            &lt;/Link&gt;&#10;                            &lt;Link&#10;                              href=&quot;/cart&quot;&#10;                              className=&quot;block px-4 py-2 text-sm text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700&quot;&#10;                              onClick={() =&gt; setShowUserMenu(false)}&#10;                            &gt;&#10;                              &lt;i className=&quot;fas fa-shopping-cart mr-2&quot;&gt;&lt;/i&gt;&#10;                              Cart&#10;                            &lt;/Link&gt;&#10;                          &lt;/&gt;&#10;                        )}&#10;&#10;                        {/* Common menu items */}&#10;                        &lt;div className=&quot;border-t border-gray-200 dark:border-gray-700 mt-2 pt-2&quot;&gt;&#10;                          &lt;Link&#10;                            href=&quot;/messages&quot;&#10;                            className=&quot;block px-4 py-2 text-sm text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700&quot;&#10;                            onClick={() =&gt; setShowUserMenu(false)}&#10;                          &gt;&#10;                            &lt;i className=&quot;fas fa-envelope mr-2&quot;&gt;&lt;/i&gt;&#10;                            Messages&#10;                            {totalUnreadCount &gt; 0 &amp;&amp; (&#10;                              &lt;span className=&quot;ml-2 bg-red-500 text-white text-xs rounded-full h-5 w-5 flex items-center justify-center inline-flex&quot;&gt;&#10;                                {totalUnreadCount &gt; 9 ? &quot;9+&quot; : totalUnreadCount}&#10;                              &lt;/span&gt;&#10;                            )}&#10;                          &lt;/Link&gt;&#10;                          &lt;Link&#10;                            href=&quot;/profile&quot;&#10;                            className=&quot;block px-4 py-2 text-sm text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700&quot;&#10;                            onClick={() =&gt; setShowUserMenu(false)}&#10;                          &gt;&#10;                            &lt;i className=&quot;fas fa-user mr-2&quot;&gt;&lt;/i&gt;&#10;                            Profile Settings&#10;                          &lt;/Link&gt;&#10;                          &lt;button&#10;                            onClick={handleLogout}&#10;                            className=&quot;w-full text-left px-4 py-2 text-sm text-red-600 dark:text-red-400 hover:bg-gray-100 dark:hover:bg-gray-700&quot;&#10;                          &gt;&#10;                            &lt;i className=&quot;fas fa-sign-out-alt mr-2&quot;&gt;&lt;/i&gt;&#10;                            Logout&#10;                          &lt;/button&gt;&#10;                        &lt;/div&gt;&#10;                      &lt;/div&gt;&#10;                    )}&#10;                  &lt;/div&gt;&#10;                ) : (&#10;                  &lt;div className=&quot;flex items-center space-x-3&quot;&gt;&#10;                    &lt;Link&#10;                      href=&quot;/login&quot;&#10;                      className=&quot;text-gray-700 dark:text-gray-300 hover:text-primary-600 dark:hover:text-primary-400 transition&quot;&#10;                    &gt;&#10;                      Login&#10;                    &lt;/Link&gt;&#10;                    &lt;Link&#10;                      href=&quot;/register&quot;&#10;                      className=&quot;bg-primary-600 hover:bg-primary-700 text-white px-4 py-2 rounded-lg transition&quot;&#10;                    &gt;&#10;                      Sign Up&#10;                    &lt;/Link&gt;&#10;                  &lt;/div&gt;&#10;                )}&#10;              &lt;/&gt;&#10;            )}&#10;&#10;            {/* Mobile menu button */}&#10;            &lt;button className=&quot;lg:hidden text-gray-700 dark:text-gray-300&quot;&gt;&#10;              &lt;i className=&quot;fas fa-bars text-xl&quot;&gt;&lt;/i&gt;&#10;            &lt;/button&gt;&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;    &lt;/nav&gt;&#10;  );&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/components/dashboard/tabs/AnalyticsTab.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/components/dashboard/tabs/AnalyticsTab.js" />
              <option name="originalContent" value="// components/dashboard/tabs/AnalyticsTab.js&#10;import { useMemo, useRef, useEffect } from &quot;react&quot;;&#10;import {&#10;  Chart as ChartJS,&#10;  CategoryScale,&#10;  LinearScale,&#10;  PointElement,&#10;  LineElement,&#10;  BarElement,&#10;  RadialLinearScale,&#10;  ArcElement,&#10;  Title,&#10;  Tooltip,&#10;  Legend,&#10;  Filler,&#10;} from &quot;chart.js&quot;;&#10;import { Line, Bar, Radar, PolarArea, Bubble, Chart } from &quot;react-chartjs-2&quot;;&#10;&#10;// Register Chart.js components&#10;ChartJS.register(&#10;  CategoryScale,&#10;  LinearScale,&#10;  PointElement,&#10;  LineElement,&#10;  BarElement,&#10;  RadialLinearScale,&#10;  ArcElement,&#10;  Title,&#10;  Tooltip,&#10;  Legend,&#10;  Filler,&#10;);&#10;&#10;export default function AnalyticsTab({&#10;  analytics,&#10;  orders,&#10;  products,&#10;  formatPrice,&#10;  formatDate,&#10;}) {&#10;  // Calculate category statistics&#10;  const categoryStats = useMemo(() =&gt; {&#10;    // Only use DELIVERED orders for revenue calculations&#10;    const deliveredOrders = orders.filter(&#10;      (order) =&gt; order.status === &quot;delivered&quot;,&#10;    );&#10;&#10;    // First, collect ALL unique products from both products array AND order items&#10;    const allProducts = new Map();&#10;&#10;    // Add products from the products array&#10;    products.forEach((product) =&gt; {&#10;      allProducts.set(product._id, {&#10;        ...product,&#10;        source: &quot;products_array&quot;,&#10;      });&#10;    });&#10;&#10;    // Add missing products from order items&#10;    deliveredOrders.forEach((order) =&gt; {&#10;      order.items?.forEach((item) =&gt; {&#10;        const productId = item.product?._id || item.productId;&#10;        const productName = item.product?.name || item.name || &quot;no-name&quot;;&#10;&#10;        if (productId &amp;&amp; !allProducts.has(productId)) {&#10;          // Create a dummy product for missing products&#10;          allProducts.set(productId, {&#10;            _id: productId,&#10;            name: productName,&#10;            price: parseFloat(item.price) || 0,&#10;            category: &quot;Other&quot;, // Assign missing products to &quot;Other&quot;&#10;            stock: 0,&#10;            status: &quot;unknown&quot;,&#10;            source: &quot;order_items&quot;,&#10;          });&#10;        }&#10;      });&#10;    });&#10;&#10;    const allProductsArray = Array.from(allProducts.values());&#10;&#10;    console.log(` TOTAL PRODUCTS FOUND: ${allProductsArray.length}`);&#10;    console.log(&quot;  From products array:&quot;, products.length);&#10;    console.log(&#10;      &quot;  From order items (missing):&quot;,&#10;      allProductsArray.length - products.length,&#10;    );&#10;&#10;    // Group all products by category&#10;    const categorizedProducts = allProductsArray.reduce((acc, product) =&gt; {&#10;      const category =&#10;        product.category &amp;&amp; product.category.trim()&#10;          ? product.category.trim()&#10;          : &quot;Other&quot;;&#10;      if (!acc[category]) {&#10;        acc[category] = [];&#10;      }&#10;      acc[category].push(product);&#10;      return acc;&#10;    }, {});&#10;&#10;    console.log(&#10;      `Category Analysis for farmer - Products with categories:`,&#10;      Object.fromEntries(&#10;        Object.entries(categorizedProducts).map(([cat, prods]) =&gt; [&#10;          cat,&#10;          prods.length,&#10;        ]),&#10;      ),&#10;    );&#10;&#10;    // DEBUG: Log all products and their categories&#10;    console.log(&quot; ALL PRODUCTS AND CATEGORIES:&quot;);&#10;    allProductsArray.forEach((product) =&gt; {&#10;      const category =&#10;        product.category &amp;&amp; product.category.trim()&#10;          ? product.category.trim()&#10;          : &quot;Other&quot;;&#10;      console.log(&#10;        `  Product: ${product.name} (${product._id}) -&gt; Category: &quot;${product.category}&quot; -&gt; Assigned: &quot;${category}&quot; [${product.source}]`,&#10;      );&#10;    });&#10;&#10;    // Store allProductsArray for use in other charts&#10;    this.allProductsArray = allProductsArray;&#10;&#10;    // Calculate stats for each category&#10;    return Object.entries(categorizedProducts).reduce(&#10;      (acc, [category, categoryProducts]) =&gt; {&#10;        // Calculate basic product stats&#10;        const count = categoryProducts.length;&#10;        const active = categoryProducts.filter(&#10;          (p) =&gt; p.status !== &quot;inactive&quot; &amp;&amp; p.stock &gt; 0,&#10;        ).length;&#10;        const totalStock = categoryProducts.reduce(&#10;          (sum, p) =&gt; sum + (p.stock || 0),&#10;          0,&#10;        );&#10;&#10;        // Calculate simple average price to match Top Categories display&#10;        const avgPrice =&#10;          count &gt; 0&#10;            ? categoryProducts.reduce(&#10;                (sum, p) =&gt; sum + (parseFloat(p.price) || 0),&#10;                0,&#10;              ) / count&#10;            : 0;&#10;&#10;        // FIX: Calculate revenue for this category directly from item values, not proportional&#10;        const categoryRevenue = deliveredOrders.reduce((sum, order) =&gt; {&#10;          if (!order.items) return sum;&#10;&#10;          console.log(&#10;            `Category ${category} - Checking order ${order._id} with ${order.items?.length} items`,&#10;          );&#10;&#10;          // Find items in this order that belong to this category&#10;          const categoryItems = order.items.filter((item) =&gt; {&#10;            const hasMatch = categoryProducts.some((product) =&gt; {&#10;              const matches =&#10;                item.product?._id === product._id ||&#10;                item.productId === product._id ||&#10;                item.product?.id === product._id ||&#10;                item.productId === product.id;&#10;&#10;              if (matches) {&#10;                console.log(&#10;                  `  ✅ MATCH found: Order item ${item.product?._id || item.productId} matches product ${product._id} (${product.name})`,&#10;                );&#10;              }&#10;              return matches;&#10;            });&#10;&#10;            if (!hasMatch) {&#10;              console.log(&#10;                `  ❌ NO MATCH: Order item ${item.product?._id || item.productId || &quot;no-id&quot;} (${item.product?.name || item.name || &quot;no-name&quot;}) not found in ${category} products`,&#10;              );&#10;            }&#10;&#10;            return hasMatch;&#10;          });&#10;&#10;          // Calculate revenue directly from category items, not proportional&#10;          if (categoryItems.length &gt; 0) {&#10;            const categoryItemsRevenue = categoryItems.reduce(&#10;              (itemSum, item) =&gt;&#10;                itemSum +&#10;                (parseFloat(item.price) || 0) * (parseInt(item.quantity) || 0),&#10;              0,&#10;            );&#10;&#10;            console.log(&#10;              `   Order ${order._id} contains ${category} products - direct revenue: ${categoryItemsRevenue}`,&#10;            );&#10;&#10;            return sum + categoryItemsRevenue;&#10;          }&#10;&#10;          return sum;&#10;        }, 0);&#10;&#10;        console.log(&#10;          ` Category ${category} final revenue: ${categoryRevenue}`,&#10;        );&#10;&#10;        acc[category] = {&#10;          count,&#10;          active,&#10;          revenue: categoryRevenue,&#10;          avgPrice,&#10;          totalStock,&#10;        };&#10;&#10;        return acc;&#10;      },&#10;      {},&#10;    );&#10;  }, [products, orders]);&#10;&#10;  // Create allProductsArray for use in other charts&#10;  const allProductsArray = useMemo(() =&gt; {&#10;    const deliveredOrders = orders.filter(&#10;      (order) =&gt; order.status === &quot;delivered&quot;,&#10;    );&#10;&#10;    const allProducts = new Map();&#10;&#10;    // Add products from the products array&#10;    products.forEach((product) =&gt; {&#10;      allProducts.set(product._id, {&#10;        ...product,&#10;        source: &quot;products_array&quot;,&#10;      });&#10;    });&#10;&#10;    // Add missing products from order items&#10;    deliveredOrders.forEach((order) =&gt; {&#10;      order.items?.forEach((item) =&gt; {&#10;        const productId = item.product?._id || item.productId;&#10;        const productName = item.product?.name || item.name || &quot;no-name&quot;;&#10;&#10;        if (productId &amp;&amp; !allProducts.has(productId)) {&#10;          allProducts.set(productId, {&#10;            _id: productId,&#10;            name: productName,&#10;            price: parseFloat(item.price) || 0,&#10;            category: &quot;Other&quot;,&#10;            stock: 0,&#10;            status: &quot;unknown&quot;,&#10;            source: &quot;order_items&quot;,&#10;          });&#10;        }&#10;      });&#10;    });&#10;&#10;    return Array.from(allProducts.values());&#10;  }, [products, orders]);&#10;&#10;  // Calculate last 30 days performance with more data points&#10;  const last30Days = useMemo(() =&gt; {&#10;    return Array.from({ length: 30 }, (_, i) =&gt; {&#10;      const date = new Date();&#10;      date.setDate(date.getDate() - (29 - i));&#10;&#10;      // Only count DELIVERED orders for daily revenue&#10;      const dayOrders = orders.filter((order) =&gt; {&#10;        const orderDate = new Date(order.createdAt).toISOString().split(&quot;T&quot;)[0];&#10;        const isToday = orderDate === date.toISOString().split(&quot;T&quot;)[0];&#10;        const isDelivered = order.status === &quot;delivered&quot;;&#10;        return isToday &amp;&amp; isDelivered;&#10;      });&#10;&#10;      // FIX: Ensure revenue values are properly converted to numbers&#10;      const dayRevenue = dayOrders.reduce((sum, order) =&gt; {&#10;        const revenue = parseFloat(order.farmerSubtotal || order.total || 0);&#10;        console.log(&#10;          `Day ${date.toISOString().split(&quot;T&quot;)[0]}: Order ${order._id} revenue: ${revenue}`,&#10;        );&#10;        return sum + revenue;&#10;      }, 0);&#10;&#10;      return {&#10;        date: date.toISOString().split(&quot;T&quot;)[0],&#10;        day: date.getDate(),&#10;        orders: dayOrders.length,&#10;        revenue: dayRevenue, // This is now guaranteed to be a number&#10;        customers: new Set(dayOrders.map((order) =&gt; order.userId)).size,&#10;      };&#10;    });&#10;  }, [orders]);&#10;&#10;  // Product performance bubble chart data&#10;  const productBubbleData = useMemo(() =&gt; {&#10;    // Only use DELIVERED orders for product performance metrics&#10;    const deliveredOrders = orders.filter(&#10;      (order) =&gt; order.status === &quot;delivered&quot;,&#10;    );&#10;&#10;    // Use allProductsArray instead of just products to include deleted products&#10;    const productData = allProductsArray.slice(0, 20).map((product) =&gt; {&#10;      const productOrders = deliveredOrders.filter((order) =&gt;&#10;        order.items?.some(&#10;          (item) =&gt;&#10;            item.product?._id === product._id || item.productId === product._id,&#10;        ),&#10;      );&#10;&#10;      const totalQuantitySold = productOrders.reduce((sum, order) =&gt; {&#10;        const matchingItems =&#10;          order.items?.filter(&#10;            (item) =&gt;&#10;              item.product?._id === product._id ||&#10;              item.productId === product._id,&#10;          ) || [];&#10;        return (&#10;          sum +&#10;          matchingItems.reduce(&#10;            (itemSum, item) =&gt; itemSum + (parseInt(item.quantity) || 0),&#10;            0,&#10;          )&#10;        );&#10;      }, 0);&#10;&#10;      // Calculate product revenue directly from item values for accuracy&#10;      const totalRevenue = productOrders.reduce((sum, order) =&gt; {&#10;        const matchingItems =&#10;          order.items?.filter(&#10;            (item) =&gt;&#10;              item.product?._id === product._id ||&#10;              item.productId === product._id,&#10;          ) || [];&#10;&#10;        if (matchingItems.length === 0) return sum;&#10;&#10;        // Calculate direct revenue from matching items&#10;        const itemRevenue = matchingItems.reduce(&#10;          (itemSum, item) =&gt;&#10;            itemSum +&#10;            (parseFloat(item.price) || 0) * (parseInt(item.quantity) || 0),&#10;          0,&#10;        );&#10;&#10;        return sum + itemRevenue;&#10;      }, 0);&#10;&#10;      return {&#10;        x: parseFloat(product.price) || 0, // Price&#10;        y: totalQuantitySold, // Quantity sold&#10;        r: Math.max(Math.sqrt(totalRevenue / 10), 5), // Revenue (bubble size)&#10;        label: product.name,&#10;        revenue: totalRevenue,&#10;      };&#10;    });&#10;&#10;    return {&#10;      datasets: [&#10;        {&#10;          label: &quot;Product Performance&quot;,&#10;          data: productData,&#10;          backgroundColor: &quot;rgba(75, 192, 192, 0.6)&quot;,&#10;          borderColor: &quot;rgba(75, 192, 192, 1)&quot;,&#10;          borderWidth: 2,&#10;        },&#10;      ],&#10;    };&#10;  }, [allProductsArray, orders]);&#10;&#10;  // Radar chart data for category performance&#10;  const categoryRadarData = useMemo(() =&gt; {&#10;    const categories = Object.keys(categoryStats);&#10;&#10;    // If no categories, return empty chart&#10;    if (categories.length === 0) {&#10;      return {&#10;        labels: [&#10;          &quot;Product Count&quot;,&#10;          &quot;Revenue ($)&quot;,&#10;          &quot;Active Products&quot;,&#10;          &quot;Avg Price ($)&quot;,&#10;          &quot;Total Stock&quot;,&#10;        ],&#10;        datasets: [],&#10;      };&#10;    }&#10;&#10;    // Calculate actual maximums for scaling (use actual values, not normalized)&#10;    const allStats = Object.values(categoryStats);&#10;&#10;    // Find reasonable scale maximums based on actual data&#10;    const maxValues = {&#10;      count: Math.max(...allStats.map((s) =&gt; s.count), 1),&#10;      revenue: Math.max(...allStats.map((s) =&gt; s.revenue), 1),&#10;      active: Math.max(...allStats.map((s) =&gt; s.active), 1),&#10;      avgPrice: Math.max(...allStats.map((s) =&gt; s.avgPrice), 1),&#10;      totalStock: Math.max(...allStats.map((s) =&gt; s.totalStock), 1),&#10;    };&#10;&#10;    // Use a scale that makes sense for comparison&#10;    const getScaledValue = (value, maxValue, targetMax = 100) =&gt; {&#10;      if (maxValue === 0) return 0;&#10;      return Math.min((value / maxValue) * targetMax, targetMax);&#10;    };&#10;&#10;    return {&#10;      labels: [&#10;        &quot;Product Count&quot;,&#10;        &quot;Revenue ($)&quot;,&#10;        &quot;Active Products&quot;,&#10;        &quot;Avg Price ($)&quot;,&#10;        &quot;Total Stock&quot;,&#10;      ],&#10;      datasets: categories.slice(0, 5).map((category, index) =&gt; {&#10;        const stats = categoryStats[category];&#10;        const colors = [&#10;          &quot;rgba(255, 99, 132, 0.2)&quot;,&#10;          &quot;rgba(54, 162, 235, 0.2)&quot;,&#10;          &quot;rgba(255, 205, 86, 0.2)&quot;,&#10;          &quot;rgba(75, 192, 192, 0.2)&quot;,&#10;          &quot;rgba(153, 102, 255, 0.2)&quot;,&#10;        ];&#10;        const borderColors = [&#10;          &quot;rgba(255, 99, 132, 1)&quot;,&#10;          &quot;rgba(54, 162, 235, 1)&quot;,&#10;          &quot;rgba(255, 205, 86, 1)&quot;,&#10;          &quot;rgba(75, 192, 192, 1)&quot;,&#10;          &quot;rgba(153, 102, 255, 1)&quot;,&#10;        ];&#10;&#10;        // Use actual values scaled proportionally&#10;        const scaledData = [&#10;          getScaledValue(stats.count, maxValues.count),&#10;          getScaledValue(stats.revenue, maxValues.revenue),&#10;          getScaledValue(stats.active, maxValues.active),&#10;          getScaledValue(stats.avgPrice, maxValues.avgPrice),&#10;          getScaledValue(stats.totalStock, maxValues.totalStock),&#10;        ];&#10;&#10;        // Create accurate label with actual values&#10;        const labelText = `${category} (${stats.count} products, $${stats.revenue.toFixed(2)} revenue, ${stats.totalStock} stock)`;&#10;&#10;        return {&#10;          label: labelText,&#10;          data: scaledData,&#10;          backgroundColor: colors[index % colors.length],&#10;          borderColor: borderColors[index % borderColors.length],&#10;          borderWidth: 2,&#10;          pointBackgroundColor: borderColors[index % borderColors.length],&#10;          pointBorderColor: &quot;#fff&quot;,&#10;          pointHoverBackgroundColor: &quot;#fff&quot;,&#10;          pointHoverBorderColor: borderColors[index % borderColors.length],&#10;        };&#10;      }),&#10;    };&#10;  }, [categoryStats]);&#10;&#10;  // Mixed chart data (revenue and orders)&#10;  const mixedChartData = useMemo(() =&gt; {&#10;    const recentData = last30Days.slice(-14); // Last 14 days&#10;&#10;    return {&#10;      labels: recentData.map((d) =&gt; `${d.day}`),&#10;      datasets: [&#10;        {&#10;          type: &quot;line&quot;,&#10;          label: &quot;Revenue&quot;,&#10;          data: recentData.map((d) =&gt; d.revenue),&#10;          borderColor: &quot;rgba(75, 192, 192, 1)&quot;,&#10;          backgroundColor: &quot;rgba(75, 192, 192, 0.1)&quot;,&#10;          borderWidth: 3,&#10;          fill: true,&#10;          tension: 0.4,&#10;          yAxisID: &quot;y&quot;,&#10;        },&#10;        {&#10;          type: &quot;bar&quot;,&#10;          label: &quot;Orders&quot;,&#10;          data: recentData.map((d) =&gt; d.orders),&#10;          backgroundColor: &quot;rgba(255, 99, 132, 0.8)&quot;,&#10;          borderColor: &quot;rgba(255, 99, 132, 1)&quot;,&#10;          borderWidth: 1,&#10;          yAxisID: &quot;y1&quot;,&#10;        },&#10;        {&#10;          type: &quot;line&quot;,&#10;          label: &quot;Customers&quot;,&#10;          data: recentData.map((d) =&gt; d.customers),&#10;          borderColor: &quot;rgba(153, 102, 255, 1)&quot;,&#10;          backgroundColor: &quot;rgba(153, 102, 255, 0.1)&quot;,&#10;          borderWidth: 2,&#10;          borderDash: [5, 5],&#10;          yAxisID: &quot;y1&quot;,&#10;        },&#10;      ],&#10;    };&#10;  }, [last30Days]);&#10;&#10;  // Polar area chart for order status distribution&#10;  const orderStatusData = useMemo(() =&gt; {&#10;    const statusCounts = orders.reduce((acc, order) =&gt; {&#10;      const status = order.status || &quot;unknown&quot;;&#10;      acc[status] = (acc[status] || 0) + 1;&#10;      return acc;&#10;    }, {});&#10;&#10;    return {&#10;      labels: Object.keys(statusCounts),&#10;      datasets: [&#10;        {&#10;          data: Object.values(statusCounts),&#10;          backgroundColor: [&#10;            &quot;rgba(255, 99, 132, 0.8)&quot;,&#10;            &quot;rgba(54, 162, 235, 0.8)&quot;,&#10;            &quot;rgba(255, 205, 86, 0.8)&quot;,&#10;            &quot;rgba(75, 192, 192, 0.8)&quot;,&#10;            &quot;rgba(153, 102, 255, 0.8)&quot;,&#10;            &quot;rgba(255, 159, 64, 0.8)&quot;,&#10;          ],&#10;          borderWidth: 2,&#10;          borderColor: &quot;#fff&quot;,&#10;        },&#10;      ],&#10;    };&#10;  }, [orders]);&#10;&#10;  const chartOptions = {&#10;    responsive: true,&#10;    maintainAspectRatio: false,&#10;    plugins: {&#10;      legend: {&#10;        position: &quot;top&quot;,&#10;        labels: {&#10;          color: &quot;rgb(156, 163, 175)&quot;,&#10;          font: {&#10;            size: 12,&#10;          },&#10;        },&#10;      },&#10;      title: {&#10;        display: false,&#10;      },&#10;      tooltip: {&#10;        backgroundColor: &quot;rgba(0, 0, 0, 0.8)&quot;,&#10;        titleColor: &quot;#fff&quot;,&#10;        bodyColor: &quot;#fff&quot;,&#10;        borderColor: &quot;rgba(255, 255, 255, 0.1)&quot;,&#10;        borderWidth: 1,&#10;      },&#10;    },&#10;    scales: {&#10;      x: {&#10;        grid: {&#10;          color: &quot;rgba(156, 163, 175, 0.1)&quot;,&#10;        },&#10;        ticks: {&#10;          color: &quot;rgb(156, 163, 175)&quot;,&#10;        },&#10;      },&#10;      y: {&#10;        grid: {&#10;          color: &quot;rgba(156, 163, 175, 0.1)&quot;,&#10;        },&#10;        ticks: {&#10;          color: &quot;rgb(156, 163, 175)&quot;,&#10;        },&#10;      },&#10;    },&#10;  };&#10;&#10;  const mixedChartOptions = {&#10;    ...chartOptions,&#10;    scales: {&#10;      x: {&#10;        grid: {&#10;          color: &quot;rgba(156, 163, 175, 0.1)&quot;,&#10;        },&#10;        ticks: {&#10;          color: &quot;rgb(156, 163, 175)&quot;,&#10;        },&#10;      },&#10;      y: {&#10;        type: &quot;linear&quot;,&#10;        display: true,&#10;        position: &quot;left&quot;,&#10;        grid: {&#10;          color: &quot;rgba(156, 163, 175, 0.1)&quot;,&#10;        },&#10;        ticks: {&#10;          color: &quot;rgb(156, 163, 175)&quot;,&#10;          callback: function (value) {&#10;            return formatPrice(value);&#10;          },&#10;        },&#10;      },&#10;      y1: {&#10;        type: &quot;linear&quot;,&#10;        display: true,&#10;        position: &quot;right&quot;,&#10;        grid: {&#10;          drawOnChartArea: false,&#10;        },&#10;        ticks: {&#10;          color: &quot;rgb(156, 163, 175)&quot;,&#10;        },&#10;      },&#10;    },&#10;  };&#10;&#10;  const bubbleChartOptions = {&#10;    ...chartOptions,&#10;    scales: {&#10;      x: {&#10;        title: {&#10;          display: true,&#10;          text: &quot;Product Price&quot;,&#10;          color: &quot;rgb(156, 163, 175)&quot;,&#10;        },&#10;        grid: {&#10;          color: &quot;rgba(156, 163, 175, 0.1)&quot;,&#10;        },&#10;        ticks: {&#10;          color: &quot;rgb(156, 163, 175)&quot;,&#10;          callback: function (value) {&#10;            return formatPrice(value);&#10;          },&#10;        },&#10;      },&#10;      y: {&#10;        title: {&#10;          display: true,&#10;          text: &quot;Quantity Sold&quot;,&#10;          color: &quot;rgb(156, 163, 175)&quot;,&#10;        },&#10;        grid: {&#10;          color: &quot;rgba(156, 163, 175, 0.1)&quot;,&#10;        },&#10;        ticks: {&#10;          color: &quot;rgb(156, 163, 175)&quot;,&#10;        },&#10;      },&#10;    },&#10;    plugins: {&#10;      ...chartOptions.plugins,&#10;      tooltip: {&#10;        ...chartOptions.plugins.tooltip,&#10;        callbacks: {&#10;          label: function (context) {&#10;            const point = context.raw;&#10;            return `${point.label}: Price ${formatPrice(point.x)}, Sold ${point.y}, Revenue ${formatPrice(point.revenue)}`;&#10;          },&#10;        },&#10;      },&#10;    },&#10;  };&#10;&#10;  const radarOptions = {&#10;    responsive: true,&#10;    maintainAspectRatio: false,&#10;    plugins: {&#10;      legend: {&#10;        position: &quot;top&quot;,&#10;        labels: {&#10;          color: &quot;rgb(156, 163, 175)&quot;,&#10;          font: {&#10;            size: 12,&#10;          },&#10;        },&#10;      },&#10;      tooltip: {&#10;        backgroundColor: &quot;rgba(0, 0, 0, 0.8)&quot;,&#10;        titleColor: &quot;#fff&quot;,&#10;        bodyColor: &quot;#fff&quot;,&#10;        borderColor: &quot;rgba(255, 255, 255, 0.1)&quot;,&#10;        borderWidth: 1,&#10;        callbacks: {&#10;          label: function (context) {&#10;            const datasetLabel = context.dataset.label;&#10;            const categoryName = datasetLabel.split(&quot; (&quot;)[0];&#10;            const stats = categoryStats[categoryName];&#10;            const pointIndex = context.dataIndex;&#10;&#10;            if (!stats) return context.formattedValue;&#10;&#10;            const labels = [&#10;              `Products: ${stats.count}`,&#10;              `Revenue: ${formatPrice(stats.revenue)}`,&#10;              `Active: ${stats.active}`,&#10;              `Avg Price: ${formatPrice(stats.avgPrice)}`,&#10;              `Stock: ${stats.totalStock}`,&#10;            ];&#10;&#10;            return labels[pointIndex] || context.formattedValue;&#10;          },&#10;        },&#10;      },&#10;    },&#10;    scales: {&#10;      r: {&#10;        angleLines: {&#10;          color: &quot;rgba(156, 163, 175, 0.2)&quot;,&#10;        },&#10;        grid: {&#10;          color: &quot;rgba(156, 163, 175, 0.2)&quot;,&#10;        },&#10;        pointLabels: {&#10;          color: &quot;rgb(156, 163, 175)&quot;,&#10;          font: {&#10;            size: 11,&#10;          },&#10;        },&#10;        ticks: {&#10;          color: &quot;rgba(156, 163, 175, 0.8)&quot;,&#10;          backdropColor: &quot;transparent&quot;,&#10;          stepSize: 20,&#10;          min: 0,&#10;          max: 100,&#10;        },&#10;      },&#10;    },&#10;  };&#10;&#10;  const polarOptions = {&#10;    responsive: true,&#10;    maintainAspectRatio: false,&#10;    plugins: {&#10;      legend: {&#10;        position: &quot;right&quot;,&#10;        labels: {&#10;          color: &quot;rgb(156, 163, 175)&quot;,&#10;          font: {&#10;            size: 12,&#10;          },&#10;        },&#10;      },&#10;    },&#10;    scales: {&#10;      r: {&#10;        grid: {&#10;          color: &quot;rgba(156, 163, 175, 0.2)&quot;,&#10;        },&#10;        ticks: {&#10;          color: &quot;rgba(156, 163, 175, 0.8)&quot;,&#10;          backdropColor: &quot;transparent&quot;,&#10;        },&#10;      },&#10;    },&#10;  };&#10;&#10;  // Calculate actual performance metrics&#10;  const performanceMetrics = useMemo(() =&gt; {&#10;    const validOrders = orders.filter(&#10;      (order) =&gt; order.status !== &quot;cancelled&quot; &amp;&amp; order.status !== &quot;returned&quot;,&#10;    );&#10;&#10;    // Calculate conversion rate (delivered orders / total orders)&#10;    const conversionRate =&#10;      orders.length &gt; 0&#10;        ? (&#10;            (orders.filter((o) =&gt; o.status === &quot;delivered&quot;).length /&#10;              orders.length) *&#10;            100&#10;          ).toFixed(1)&#10;        : 0;&#10;&#10;    // Calculate revenue growth (compare last 30 days with previous 30 days)&#10;    const today = new Date();&#10;    const thirtyDaysAgo = new Date(today.getTime() - 30 * 24 * 60 * 60 * 1000);&#10;    const sixtyDaysAgo = new Date(today.getTime() - 60 * 24 * 60 * 60 * 1000);&#10;&#10;    const recentRevenue = validOrders&#10;      .filter((order) =&gt; new Date(order.createdAt) &gt;= thirtyDaysAgo)&#10;      .reduce(&#10;        (sum, order) =&gt; sum + (order.farmerSubtotal || order.total || 0),&#10;        0,&#10;      );&#10;&#10;    const previousRevenue = validOrders&#10;      .filter((order) =&gt; {&#10;        const orderDate = new Date(order.createdAt);&#10;        return orderDate &gt;= sixtyDaysAgo &amp;&amp; orderDate &lt; thirtyDaysAgo;&#10;      })&#10;      .reduce(&#10;        (sum, order) =&gt; sum + (order.farmerSubtotal || order.total || 0),&#10;        0,&#10;      );&#10;&#10;    let revenueGrowth = 0;&#10;    if (previousRevenue &gt; 0 &amp;&amp; recentRevenue &gt; 0) {&#10;      revenueGrowth = (&#10;        ((recentRevenue - previousRevenue) / previousRevenue) *&#10;        100&#10;      ).toFixed(1);&#10;    } else if (recentRevenue &gt; 0 &amp;&amp; previousRevenue === 0) {&#10;      revenueGrowth = 100; // 100% growth when starting from 0&#10;    }&#10;&#10;    // Calculate customer retention (customers who made repeat orders)&#10;    const uniqueCustomers = [&#10;      ...new Set(validOrders.map((order) =&gt; order.userId)),&#10;    ];&#10;    const repeatCustomers = uniqueCustomers.filter((customerId) =&gt; {&#10;      const customerOrders = validOrders.filter(&#10;        (order) =&gt; order.userId === customerId,&#10;      );&#10;      return customerOrders.length &gt; 1;&#10;    });&#10;&#10;    const customerRetention =&#10;      uniqueCustomers.length &gt; 0&#10;        ? ((repeatCustomers.length / uniqueCustomers.length) * 100).toFixed(1)&#10;        : 0;&#10;&#10;    return {&#10;      conversionRate,&#10;      revenueGrowth,&#10;      customerRetention,&#10;      hasActivity: validOrders.length &gt; 0 || products.length &gt; 0,&#10;    };&#10;  }, [orders, products]);&#10;&#10;  return (&#10;    &lt;div className=&quot;space-y-8&quot;&gt;&#10;      {/* Header Stats */}&#10;      &lt;div className=&quot;grid grid-cols-1 md:grid-cols-4 gap-6&quot;&gt;&#10;        &lt;div className=&quot;bg-gradient-to-br from-blue-500 to-blue-600 rounded-xl shadow-lg p-6 text-white&quot;&gt;&#10;          &lt;div className=&quot;flex items-center justify-between&quot;&gt;&#10;            &lt;div&gt;&#10;              &lt;p className=&quot;text-blue-100 text-sm font-medium&quot;&gt;Total Revenue&lt;/p&gt;&#10;              &lt;p className=&quot;text-3xl font-bold&quot;&gt;&#10;                {formatPrice(analytics.totalRevenue || 0)}&#10;              &lt;/p&gt;&#10;            &lt;/div&gt;&#10;            &lt;div className=&quot;p-3 bg-white bg-opacity-20 rounded-lg&quot;&gt;&#10;              &lt;i className=&quot;fas fa-dollar-sign text-2xl&quot;&gt;&lt;/i&gt;&#10;            &lt;/div&gt;&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;&#10;        &lt;div className=&quot;bg-gradient-to-br from-green-500 to-green-600 rounded-xl shadow-lg p-6 text-white&quot;&gt;&#10;          &lt;div className=&quot;flex items-center justify-between&quot;&gt;&#10;            &lt;div&gt;&#10;              &lt;p className=&quot;text-green-100 text-sm font-medium&quot;&gt;Total Orders&lt;/p&gt;&#10;              &lt;p className=&quot;text-3xl font-bold&quot;&gt;{analytics.totalOrders || 0}&lt;/p&gt;&#10;            &lt;/div&gt;&#10;            &lt;div className=&quot;p-3 bg-white bg-opacity-20 rounded-lg&quot;&gt;&#10;              &lt;i className=&quot;fas fa-shopping-cart text-2xl&quot;&gt;&lt;/i&gt;&#10;            &lt;/div&gt;&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;&#10;        &lt;div className=&quot;bg-gradient-to-br from-purple-500 to-purple-600 rounded-xl shadow-lg p-6 text-white&quot;&gt;&#10;          &lt;div className=&quot;flex items-center justify-between&quot;&gt;&#10;            &lt;div&gt;&#10;              &lt;p className=&quot;text-purple-100 text-sm font-medium&quot;&gt;&#10;                Active Products&#10;              &lt;/p&gt;&#10;              &lt;p className=&quot;text-3xl font-bold&quot;&gt;&#10;                {analytics.activeProducts || 0}&#10;              &lt;/p&gt;&#10;            &lt;/div&gt;&#10;            &lt;div className=&quot;p-3 bg-white bg-opacity-20 rounded-lg&quot;&gt;&#10;              &lt;i className=&quot;fas fa-box text-2xl&quot;&gt;&lt;/i&gt;&#10;            &lt;/div&gt;&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;&#10;        &lt;div className=&quot;bg-gradient-to-br from-orange-500 to-orange-600 rounded-xl shadow-lg p-6 text-white&quot;&gt;&#10;          &lt;div className=&quot;flex items-center justify-between&quot;&gt;&#10;            &lt;div&gt;&#10;              &lt;p className=&quot;text-orange-100 text-sm font-medium&quot;&gt;&#10;                Avg Order Value&#10;              &lt;/p&gt;&#10;              &lt;p className=&quot;text-3xl font-bold&quot;&gt;&#10;                {formatPrice(analytics.averageOrderValue || 0)}&#10;              &lt;/p&gt;&#10;            &lt;/div&gt;&#10;            &lt;div className=&quot;p-3 bg-white bg-opacity-20 rounded-lg&quot;&gt;&#10;              &lt;i className=&quot;fas fa-chart-line text-2xl&quot;&gt;&lt;/i&gt;&#10;            &lt;/div&gt;&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;&#10;      {/* Advanced Charts Row 1 */}&#10;      &lt;div className=&quot;grid grid-cols-1 lg:grid-cols-2 gap-8&quot;&gt;&#10;        {/* Mixed Chart */}&#10;        &lt;div className=&quot;bg-white dark:bg-gray-800 rounded-xl shadow-lg p-6&quot;&gt;&#10;          &lt;h3 className=&quot;text-xl font-bold text-gray-900 dark:text-white mb-6 flex items-center&quot;&gt;&#10;            &lt;i className=&quot;fas fa-chart-area mr-3 text-blue-500&quot;&gt;&lt;/i&gt;&#10;            Revenue &amp; Orders Trend (14 Days)&#10;          &lt;/h3&gt;&#10;          &lt;div className=&quot;h-80&quot;&gt;&#10;            &lt;Chart&#10;              type=&quot;bar&quot;&#10;              data={mixedChartData}&#10;              options={mixedChartOptions}&#10;            /&gt;&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;&#10;        {/* Bubble Chart */}&#10;        &lt;div className=&quot;bg-white dark:bg-gray-800 rounded-xl shadow-lg p-6&quot;&gt;&#10;          &lt;h3 className=&quot;text-xl font-bold text-gray-900 dark:text-white mb-6 flex items-center&quot;&gt;&#10;            &lt;i className=&quot;fas fa-circle-notch mr-3 text-green-500&quot;&gt;&lt;/i&gt;&#10;            Product Performance Matrix&#10;          &lt;/h3&gt;&#10;          &lt;div className=&quot;h-80&quot;&gt;&#10;            &lt;Bubble data={productBubbleData} options={bubbleChartOptions} /&gt;&#10;          &lt;/div&gt;&#10;          &lt;p className=&quot;text-xs text-gray-500 dark:text-gray-400 mt-2&quot;&gt;&#10;            X: Price, Y: Quantity Sold, Bubble Size: Revenue&#10;          &lt;/p&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;&#10;      {/* Advanced Charts Row 2 */}&#10;      &lt;div className=&quot;grid grid-cols-1 lg:grid-cols-2 gap-8&quot;&gt;&#10;        {/* Radar Chart */}&#10;        &lt;div className=&quot;bg-white dark:bg-gray-800 rounded-xl shadow-lg p-6&quot;&gt;&#10;          &lt;h3 className=&quot;text-xl font-bold text-gray-900 dark:text-white mb-6 flex items-center&quot;&gt;&#10;            &lt;i className=&quot;fas fa-spider mr-3 text-purple-500&quot;&gt;&lt;/i&gt;&#10;            Category Performance Analysis&#10;          &lt;/h3&gt;&#10;          &lt;div className=&quot;h-80&quot;&gt;&#10;            &lt;Radar data={categoryRadarData} options={radarOptions} /&gt;&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;&#10;        {/* Polar Area Chart */}&#10;        &lt;div className=&quot;bg-white dark:bg-gray-800 rounded-xl shadow-lg p-6&quot;&gt;&#10;          &lt;h3 className=&quot;text-xl font-bold text-gray-900 dark:text-white mb-6 flex items-center&quot;&gt;&#10;            &lt;i className=&quot;fas fa-chart-pie mr-3 text-pink-500&quot;&gt;&lt;/i&gt;&#10;            Order Status Distribution&#10;          &lt;/h3&gt;&#10;          &lt;div className=&quot;h-80&quot;&gt;&#10;            &lt;PolarArea data={orderStatusData} options={polarOptions} /&gt;&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;&#10;      {/* Detailed Analytics Grid */}&#10;      &lt;div className=&quot;grid grid-cols-1 lg:grid-cols-3 gap-8&quot;&gt;&#10;        {/* Top Categories */}&#10;        &lt;div className=&quot;bg-white dark:bg-gray-800 rounded-xl shadow-lg p-6&quot;&gt;&#10;          &lt;h3 className=&quot;text-lg font-semibold text-gray-900 dark:text-white mb-6 flex items-center&quot;&gt;&#10;            &lt;i className=&quot;fas fa-tags mr-3 text-indigo-500&quot;&gt;&lt;/i&gt;&#10;            Top Categories&#10;          &lt;/h3&gt;&#10;          &lt;div className=&quot;space-y-4&quot;&gt;&#10;            {Object.entries(categoryStats)&#10;              .sort(([, a], [, b]) =&gt; b.revenue - a.revenue)&#10;              .slice(0, 5)&#10;              .map(([category, stats]) =&gt; (&#10;                &lt;div&#10;                  key={category}&#10;                  className=&quot;flex items-center justify-between p-3 bg-gray-50 dark:bg-gray-700 rounded-lg&quot;&#10;                &gt;&#10;                  &lt;div&gt;&#10;                    &lt;p className=&quot;font-medium text-gray-900 dark:text-white&quot;&gt;&#10;                      {category}&#10;                    &lt;/p&gt;&#10;                    &lt;p className=&quot;text-sm text-gray-500 dark:text-gray-400&quot;&gt;&#10;                      {stats.count} products&#10;                    &lt;/p&gt;&#10;                  &lt;/div&gt;&#10;                  &lt;div className=&quot;text-right&quot;&gt;&#10;                    &lt;p className=&quot;font-semibold text-gray-900 dark:text-white&quot;&gt;&#10;                      {formatPrice(stats.revenue)}&#10;                    &lt;/p&gt;&#10;                    &lt;p className=&quot;text-sm text-green-600 dark:text-green-400&quot;&gt;&#10;                      {formatPrice(stats.avgPrice)} avg&#10;                    &lt;/p&gt;&#10;                  &lt;/div&gt;&#10;                &lt;/div&gt;&#10;              ))}&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;&#10;        {/* Performance Metrics */}&#10;        &lt;div className=&quot;bg-white dark:bg-gray-800 rounded-xl shadow-lg p-6&quot;&gt;&#10;          &lt;h3 className=&quot;text-lg font-semibold text-gray-900 dark:text-white mb-6 flex items-center&quot;&gt;&#10;            &lt;i className=&quot;fas fa-tachometer-alt mr-3 text-yellow-500&quot;&gt;&lt;/i&gt;&#10;            Performance Metrics&#10;          &lt;/h3&gt;&#10;          &lt;div className=&quot;space-y-4&quot;&gt;&#10;            &lt;div className=&quot;p-4 bg-gradient-to-r from-blue-50 to-blue-100 dark:from-blue-900 dark:to-blue-800 rounded-lg&quot;&gt;&#10;              &lt;p className=&quot;text-sm font-medium text-blue-800 dark:text-blue-200&quot;&gt;&#10;                Conversion Rate&#10;              &lt;/p&gt;&#10;              &lt;p className=&quot;text-2xl font-bold text-blue-900 dark:text-blue-100&quot;&gt;&#10;                {performanceMetrics.conversionRate}%&#10;              &lt;/p&gt;&#10;            &lt;/div&gt;&#10;            &lt;div className=&quot;p-4 bg-gradient-to-r from-green-50 to-green-100 dark:from-green-900 dark:to-green-800 rounded-lg&quot;&gt;&#10;              &lt;p className=&quot;text-sm font-medium text-green-800 dark:text-green-200&quot;&gt;&#10;                Revenue Growth&#10;              &lt;/p&gt;&#10;              &lt;p className=&quot;text-2xl font-bold text-green-900 dark:text-green-100&quot;&gt;&#10;                +{performanceMetrics.revenueGrowth}%&#10;              &lt;/p&gt;&#10;            &lt;/div&gt;&#10;            &lt;div className=&quot;p-4 bg-gradient-to-r from-purple-50 to-purple-100 dark:from-purple-900 dark:to-purple-800 rounded-lg&quot;&gt;&#10;              &lt;p className=&quot;text-sm font-medium text-purple-800 dark:text-purple-200&quot;&gt;&#10;                Customer Retention&#10;              &lt;/p&gt;&#10;              &lt;p className=&quot;text-2xl font-bold text-purple-900 dark:text-purple-100&quot;&gt;&#10;                {performanceMetrics.customerRetention}%&#10;              &lt;/p&gt;&#10;            &lt;/div&gt;&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;&#10;        {/* Recent Activity */}&#10;        &lt;div className=&quot;bg-white dark:bg-gray-800 rounded-xl shadow-lg p-6&quot;&gt;&#10;          &lt;h3 className=&quot;text-lg font-semibold text-gray-900 dark:text-white mb-6 flex items-center&quot;&gt;&#10;            &lt;i className=&quot;fas fa-clock mr-3 text-red-500&quot;&gt;&lt;/i&gt;&#10;            Recent Activity&#10;          &lt;/h3&gt;&#10;          &lt;div className=&quot;space-y-3&quot;&gt;&#10;            {last30Days&#10;              .slice(-7)&#10;              .reverse()&#10;              .map((day, index) =&gt; (&#10;                &lt;div&#10;                  key={index}&#10;                  className=&quot;flex items-center justify-between p-2 hover:bg-gray-50 dark:hover:bg-gray-700 rounded&quot;&#10;                &gt;&#10;                  &lt;div className=&quot;flex items-center&quot;&gt;&#10;                    &lt;div&#10;                      className={`w-3 h-3 rounded-full mr-3 ${day.orders &gt; 0 ? &quot;bg-green-500&quot; : &quot;bg-gray-300&quot;}`}&#10;                    &gt;&lt;/div&gt;&#10;                    &lt;div&gt;&#10;                      &lt;p className=&quot;text-sm font-medium text-gray-900 dark:text-white&quot;&gt;&#10;                        Day {day.day}&#10;                      &lt;/p&gt;&#10;                      &lt;p className=&quot;text-xs text-gray-500 dark:text-gray-400&quot;&gt;&#10;                        {day.orders} orders&#10;                      &lt;/p&gt;&#10;                    &lt;/div&gt;&#10;                  &lt;/div&gt;&#10;                  &lt;p className=&quot;text-sm font-semibold text-gray-900 dark:text-white&quot;&gt;&#10;                    {formatPrice(day.revenue)}&#10;                  &lt;/p&gt;&#10;                &lt;/div&gt;&#10;              ))}&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}&#10;" />
              <option name="updatedContent" value="// components/dashboard/tabs/AnalyticsTab.js&#10;import { useMemo, useRef, useEffect } from &quot;react&quot;;&#10;import {&#10;  Chart as ChartJS,&#10;  CategoryScale,&#10;  LinearScale,&#10;  PointElement,&#10;  LineElement,&#10;  BarElement,&#10;  RadialLinearScale,&#10;  ArcElement,&#10;  Title,&#10;  Tooltip,&#10;  Legend,&#10;  Filler,&#10;} from &quot;chart.js&quot;;&#10;import { Line, Bar, Radar, PolarArea, Bubble, Chart } from &quot;react-chartjs-2&quot;;&#10;&#10;// Register Chart.js components&#10;ChartJS.register(&#10;  CategoryScale,&#10;  LinearScale,&#10;  PointElement,&#10;  LineElement,&#10;  BarElement,&#10;  RadialLinearScale,&#10;  ArcElement,&#10;  Title,&#10;  Tooltip,&#10;  Legend,&#10;  Filler,&#10;);&#10;&#10;export default function AnalyticsTab({&#10;  analytics,&#10;  orders,&#10;  products,&#10;  formatPrice,&#10;  formatDate,&#10;}) {&#10;  // Calculate category statistics&#10;  const categoryStats = useMemo(() =&gt; {&#10;    // Only use DELIVERED orders for revenue calculations&#10;    const deliveredOrders = orders.filter(&#10;      (order) =&gt; order.status === &quot;delivered&quot;,&#10;    );&#10;&#10;    // First, collect ALL unique products from both products array AND order items&#10;    const allProducts = new Map();&#10;&#10;    // Add products from the products array&#10;    products.forEach((product) =&gt; {&#10;      allProducts.set(product._id, {&#10;        ...product,&#10;        source: &quot;products_array&quot;,&#10;      });&#10;    });&#10;&#10;    // Add missing products from order items&#10;    deliveredOrders.forEach((order) =&gt; {&#10;      order.items?.forEach((item) =&gt; {&#10;        const productId = item.product?._id || item.productId;&#10;        const productName = item.product?.name || item.name || &quot;no-name&quot;;&#10;&#10;        if (productId &amp;&amp; !allProducts.has(productId)) {&#10;          // Create a dummy product for missing products&#10;          allProducts.set(productId, {&#10;            _id: productId,&#10;            name: productName,&#10;            price: parseFloat(item.price) || 0,&#10;            category: &quot;Other&quot;, // Assign missing products to &quot;Other&quot;&#10;            stock: 0,&#10;            status: &quot;unknown&quot;,&#10;            source: &quot;order_items&quot;,&#10;          });&#10;        }&#10;      });&#10;    });&#10;&#10;    const allProductsArray = Array.from(allProducts.values());&#10;&#10;    console.log(` TOTAL PRODUCTS FOUND: ${allProductsArray.length}`);&#10;    console.log(&quot;  From products array:&quot;, products.length);&#10;    console.log(&#10;      &quot;  From order items (missing):&quot;,&#10;      allProductsArray.length - products.length,&#10;    );&#10;&#10;    // Group all products by category&#10;    const categorizedProducts = allProductsArray.reduce((acc, product) =&gt; {&#10;      const category =&#10;        product.category &amp;&amp; product.category.trim()&#10;          ? product.category.trim()&#10;          : &quot;Other&quot;;&#10;      if (!acc[category]) {&#10;        acc[category] = [];&#10;      }&#10;      acc[category].push(product);&#10;      return acc;&#10;    }, {});&#10;&#10;    console.log(&#10;      `Category Analysis for farmer - Products with categories:`,&#10;      Object.fromEntries(&#10;        Object.entries(categorizedProducts).map(([cat, prods]) =&gt; [&#10;          cat,&#10;          prods.length,&#10;        ]),&#10;      ),&#10;    );&#10;&#10;    // DEBUG: Log all products and their categories&#10;    console.log(&quot; ALL PRODUCTS AND CATEGORIES:&quot;);&#10;    allProductsArray.forEach((product) =&gt; {&#10;      const category =&#10;        product.category &amp;&amp; product.category.trim()&#10;          ? product.category.trim()&#10;          : &quot;Other&quot;;&#10;      console.log(&#10;        `  Product: ${product.name} (${product._id}) -&gt; Category: &quot;${product.category}&quot; -&gt; Assigned: &quot;${category}&quot; [${product.source}]`,&#10;      );&#10;    });&#10;&#10;    // Calculate stats for each category&#10;    return Object.entries(categorizedProducts).reduce(&#10;      (acc, [category, categoryProducts]) =&gt; {&#10;        // Calculate basic product stats&#10;        const count = categoryProducts.length;&#10;        const active = categoryProducts.filter(&#10;          (p) =&gt; p.status !== &quot;inactive&quot; &amp;&amp; p.stock &gt; 0,&#10;        ).length;&#10;        const totalStock = categoryProducts.reduce(&#10;          (sum, p) =&gt; sum + (p.stock || 0),&#10;          0,&#10;        );&#10;&#10;        // Calculate simple average price to match Top Categories display&#10;        const avgPrice =&#10;          count &gt; 0&#10;            ? categoryProducts.reduce(&#10;                (sum, p) =&gt; sum + (parseFloat(p.price) || 0),&#10;                0,&#10;              ) / count&#10;            : 0;&#10;&#10;        // FIX: Calculate revenue for this category directly from item values, not proportional&#10;        const categoryRevenue = deliveredOrders.reduce((sum, order) =&gt; {&#10;          if (!order.items) return sum;&#10;&#10;          console.log(&#10;            `Category ${category} - Checking order ${order._id} with ${order.items?.length} items`,&#10;          );&#10;&#10;          // Find items in this order that belong to this category&#10;          const categoryItems = order.items.filter((item) =&gt; {&#10;            const hasMatch = categoryProducts.some((product) =&gt; {&#10;              const matches =&#10;                item.product?._id === product._id ||&#10;                item.productId === product._id ||&#10;                item.product?.id === product._id ||&#10;                item.productId === product.id;&#10;&#10;              if (matches) {&#10;                console.log(&#10;                  `  ✅ MATCH found: Order item ${item.product?._id || item.productId} matches product ${product._id} (${product.name})`,&#10;                );&#10;              }&#10;              return matches;&#10;            });&#10;&#10;            if (!hasMatch) {&#10;              console.log(&#10;                `  ❌ NO MATCH: Order item ${item.product?._id || item.productId || &quot;no-id&quot;} (${item.product?.name || item.name || &quot;no-name&quot;}) not found in ${category} products`,&#10;              );&#10;            }&#10;&#10;            return hasMatch;&#10;          });&#10;&#10;          // Calculate revenue directly from category items, not proportional&#10;          if (categoryItems.length &gt; 0) {&#10;            const categoryItemsRevenue = categoryItems.reduce(&#10;              (itemSum, item) =&gt;&#10;                itemSum +&#10;                (parseFloat(item.price) || 0) * (parseInt(item.quantity) || 0),&#10;              0,&#10;            );&#10;&#10;            console.log(&#10;              `   Order ${order._id} contains ${category} products - direct revenue: ${categoryItemsRevenue}`,&#10;            );&#10;&#10;            return sum + categoryItemsRevenue;&#10;          }&#10;&#10;          return sum;&#10;        }, 0);&#10;&#10;        console.log(&#10;          ` Category ${category} final revenue: ${categoryRevenue}`,&#10;        );&#10;&#10;        acc[category] = {&#10;          count,&#10;          active,&#10;          revenue: categoryRevenue,&#10;          avgPrice,&#10;          totalStock,&#10;        };&#10;&#10;        return acc;&#10;      },&#10;      {},&#10;    );&#10;  }, [products, orders]);&#10;&#10;  // Create allProductsArray for use in other charts&#10;  const allProductsArray = useMemo(() =&gt; {&#10;    const deliveredOrders = orders.filter(&#10;      (order) =&gt; order.status === &quot;delivered&quot;,&#10;    );&#10;&#10;    const allProducts = new Map();&#10;&#10;    // Add products from the products array&#10;    products.forEach((product) =&gt; {&#10;      allProducts.set(product._id, {&#10;        ...product,&#10;        source: &quot;products_array&quot;,&#10;      });&#10;    });&#10;&#10;    // Add missing products from order items&#10;    deliveredOrders.forEach((order) =&gt; {&#10;      order.items?.forEach((item) =&gt; {&#10;        const productId = item.product?._id || item.productId;&#10;        const productName = item.product?.name || item.name || &quot;no-name&quot;;&#10;&#10;        if (productId &amp;&amp; !allProducts.has(productId)) {&#10;          allProducts.set(productId, {&#10;            _id: productId,&#10;            name: productName,&#10;            price: parseFloat(item.price) || 0,&#10;            category: &quot;Other&quot;,&#10;            stock: 0,&#10;            status: &quot;unknown&quot;,&#10;            source: &quot;order_items&quot;,&#10;          });&#10;        }&#10;      });&#10;    });&#10;&#10;    return Array.from(allProducts.values());&#10;  }, [products, orders]);&#10;&#10;  // Calculate last 30 days performance with more data points&#10;  const last30Days = useMemo(() =&gt; {&#10;    return Array.from({ length: 30 }, (_, i) =&gt; {&#10;      const date = new Date();&#10;      date.setDate(date.getDate() - (29 - i));&#10;&#10;      // Only count DELIVERED orders for daily revenue&#10;      const dayOrders = orders.filter((order) =&gt; {&#10;        const orderDate = new Date(order.createdAt).toISOString().split(&quot;T&quot;)[0];&#10;        const isToday = orderDate === date.toISOString().split(&quot;T&quot;)[0];&#10;        const isDelivered = order.status === &quot;delivered&quot;;&#10;        return isToday &amp;&amp; isDelivered;&#10;      });&#10;&#10;      // FIX: Ensure revenue values are properly converted to numbers&#10;      const dayRevenue = dayOrders.reduce((sum, order) =&gt; {&#10;        const revenue = parseFloat(order.farmerSubtotal || order.total || 0);&#10;        console.log(&#10;          `Day ${date.toISOString().split(&quot;T&quot;)[0]}: Order ${order._id} revenue: ${revenue}`,&#10;        );&#10;        return sum + revenue;&#10;      }, 0);&#10;&#10;      return {&#10;        date: date.toISOString().split(&quot;T&quot;)[0],&#10;        day: date.getDate(),&#10;        orders: dayOrders.length,&#10;        revenue: dayRevenue, // This is now guaranteed to be a number&#10;        customers: new Set(dayOrders.map((order) =&gt; order.userId)).size,&#10;      };&#10;    });&#10;  }, [orders]);&#10;&#10;  // Product performance bubble chart data&#10;  const productBubbleData = useMemo(() =&gt; {&#10;    // Only use DELIVERED orders for product performance metrics&#10;    const deliveredOrders = orders.filter(&#10;      (order) =&gt; order.status === &quot;delivered&quot;,&#10;    );&#10;&#10;    // Use allProductsArray instead of just products to include deleted products&#10;    const productData = allProductsArray.slice(0, 20).map((product) =&gt; {&#10;      const productOrders = deliveredOrders.filter((order) =&gt;&#10;        order.items?.some(&#10;          (item) =&gt;&#10;            item.product?._id === product._id || item.productId === product._id,&#10;        ),&#10;      );&#10;&#10;      const totalQuantitySold = productOrders.reduce((sum, order) =&gt; {&#10;        const matchingItems =&#10;          order.items?.filter(&#10;            (item) =&gt;&#10;              item.product?._id === product._id ||&#10;              item.productId === product._id,&#10;          ) || [];&#10;        return (&#10;          sum +&#10;          matchingItems.reduce(&#10;            (itemSum, item) =&gt; itemSum + (parseInt(item.quantity) || 0),&#10;            0,&#10;          )&#10;        );&#10;      }, 0);&#10;&#10;      // Calculate product revenue directly from item values for accuracy&#10;      const totalRevenue = productOrders.reduce((sum, order) =&gt; {&#10;        const matchingItems =&#10;          order.items?.filter(&#10;            (item) =&gt;&#10;              item.product?._id === product._id ||&#10;              item.productId === product._id,&#10;          ) || [];&#10;&#10;        if (matchingItems.length === 0) return sum;&#10;&#10;        // Calculate direct revenue from matching items&#10;        const itemRevenue = matchingItems.reduce(&#10;          (itemSum, item) =&gt;&#10;            itemSum +&#10;            (parseFloat(item.price) || 0) * (parseInt(item.quantity) || 0),&#10;          0,&#10;        );&#10;&#10;        return sum + itemRevenue;&#10;      }, 0);&#10;&#10;      return {&#10;        x: parseFloat(product.price) || 0, // Price&#10;        y: totalQuantitySold, // Quantity sold&#10;        r: Math.max(Math.sqrt(totalRevenue / 10), 5), // Revenue (bubble size)&#10;        label: product.name,&#10;        revenue: totalRevenue,&#10;      };&#10;    });&#10;&#10;    return {&#10;      datasets: [&#10;        {&#10;          label: &quot;Product Performance&quot;,&#10;          data: productData,&#10;          backgroundColor: &quot;rgba(75, 192, 192, 0.6)&quot;,&#10;          borderColor: &quot;rgba(75, 192, 192, 1)&quot;,&#10;          borderWidth: 2,&#10;        },&#10;      ],&#10;    };&#10;  }, [allProductsArray, orders]);&#10;&#10;  // Radar chart data for category performance&#10;  const categoryRadarData = useMemo(() =&gt; {&#10;    const categories = Object.keys(categoryStats);&#10;&#10;    // If no categories, return empty chart&#10;    if (categories.length === 0) {&#10;      return {&#10;        labels: [&#10;          &quot;Product Count&quot;,&#10;          &quot;Revenue ($)&quot;,&#10;          &quot;Active Products&quot;,&#10;          &quot;Avg Price ($)&quot;,&#10;          &quot;Total Stock&quot;,&#10;        ],&#10;        datasets: [],&#10;      };&#10;    }&#10;&#10;    // Calculate actual maximums for scaling (use actual values, not normalized)&#10;    const allStats = Object.values(categoryStats);&#10;&#10;    // Find reasonable scale maximums based on actual data&#10;    const maxValues = {&#10;      count: Math.max(...allStats.map((s) =&gt; s.count), 1),&#10;      revenue: Math.max(...allStats.map((s) =&gt; s.revenue), 1),&#10;      active: Math.max(...allStats.map((s) =&gt; s.active), 1),&#10;      avgPrice: Math.max(...allStats.map((s) =&gt; s.avgPrice), 1),&#10;      totalStock: Math.max(...allStats.map((s) =&gt; s.totalStock), 1),&#10;    };&#10;&#10;    // Use a scale that makes sense for comparison&#10;    const getScaledValue = (value, maxValue, targetMax = 100) =&gt; {&#10;      if (maxValue === 0) return 0;&#10;      return Math.min((value / maxValue) * targetMax, targetMax);&#10;    };&#10;&#10;    return {&#10;      labels: [&#10;        &quot;Product Count&quot;,&#10;        &quot;Revenue ($)&quot;,&#10;        &quot;Active Products&quot;,&#10;        &quot;Avg Price ($)&quot;,&#10;        &quot;Total Stock&quot;,&#10;      ],&#10;      datasets: categories.slice(0, 5).map((category, index) =&gt; {&#10;        const stats = categoryStats[category];&#10;        const colors = [&#10;          &quot;rgba(255, 99, 132, 0.2)&quot;,&#10;          &quot;rgba(54, 162, 235, 0.2)&quot;,&#10;          &quot;rgba(255, 205, 86, 0.2)&quot;,&#10;          &quot;rgba(75, 192, 192, 0.2)&quot;,&#10;          &quot;rgba(153, 102, 255, 0.2)&quot;,&#10;        ];&#10;        const borderColors = [&#10;          &quot;rgba(255, 99, 132, 1)&quot;,&#10;          &quot;rgba(54, 162, 235, 1)&quot;,&#10;          &quot;rgba(255, 205, 86, 1)&quot;,&#10;          &quot;rgba(75, 192, 192, 1)&quot;,&#10;          &quot;rgba(153, 102, 255, 1)&quot;,&#10;        ];&#10;&#10;        // Use actual values scaled proportionally&#10;        const scaledData = [&#10;          getScaledValue(stats.count, maxValues.count),&#10;          getScaledValue(stats.revenue, maxValues.revenue),&#10;          getScaledValue(stats.active, maxValues.active),&#10;          getScaledValue(stats.avgPrice, maxValues.avgPrice),&#10;          getScaledValue(stats.totalStock, maxValues.totalStock),&#10;        ];&#10;&#10;        // Create accurate label with actual values&#10;        const labelText = `${category} (${stats.count} products, $${stats.revenue.toFixed(2)} revenue, ${stats.totalStock} stock)`;&#10;&#10;        return {&#10;          label: labelText,&#10;          data: scaledData,&#10;          backgroundColor: colors[index % colors.length],&#10;          borderColor: borderColors[index % borderColors.length],&#10;          borderWidth: 2,&#10;          pointBackgroundColor: borderColors[index % borderColors.length],&#10;          pointBorderColor: &quot;#fff&quot;,&#10;          pointHoverBackgroundColor: &quot;#fff&quot;,&#10;          pointHoverBorderColor: borderColors[index % borderColors.length],&#10;        };&#10;      }),&#10;    };&#10;  }, [categoryStats]);&#10;&#10;  // Mixed chart data (revenue and orders)&#10;  const mixedChartData = useMemo(() =&gt; {&#10;    const recentData = last30Days.slice(-14); // Last 14 days&#10;&#10;    return {&#10;      labels: recentData.map((d) =&gt; `${d.day}`),&#10;      datasets: [&#10;        {&#10;          type: &quot;line&quot;,&#10;          label: &quot;Revenue&quot;,&#10;          data: recentData.map((d) =&gt; d.revenue),&#10;          borderColor: &quot;rgba(75, 192, 192, 1)&quot;,&#10;          backgroundColor: &quot;rgba(75, 192, 192, 0.1)&quot;,&#10;          borderWidth: 3,&#10;          fill: true,&#10;          tension: 0.4,&#10;          yAxisID: &quot;y&quot;,&#10;        },&#10;        {&#10;          type: &quot;bar&quot;,&#10;          label: &quot;Orders&quot;,&#10;          data: recentData.map((d) =&gt; d.orders),&#10;          backgroundColor: &quot;rgba(255, 99, 132, 0.8)&quot;,&#10;          borderColor: &quot;rgba(255, 99, 132, 1)&quot;,&#10;          borderWidth: 1,&#10;          yAxisID: &quot;y1&quot;,&#10;        },&#10;        {&#10;          type: &quot;line&quot;,&#10;          label: &quot;Customers&quot;,&#10;          data: recentData.map((d) =&gt; d.customers),&#10;          borderColor: &quot;rgba(153, 102, 255, 1)&quot;,&#10;          backgroundColor: &quot;rgba(153, 102, 255, 0.1)&quot;,&#10;          borderWidth: 2,&#10;          borderDash: [5, 5],&#10;          yAxisID: &quot;y1&quot;,&#10;        },&#10;      ],&#10;    };&#10;  }, [last30Days]);&#10;&#10;  // Polar area chart for order status distribution&#10;  const orderStatusData = useMemo(() =&gt; {&#10;    const statusCounts = orders.reduce((acc, order) =&gt; {&#10;      const status = order.status || &quot;unknown&quot;;&#10;      acc[status] = (acc[status] || 0) + 1;&#10;      return acc;&#10;    }, {});&#10;&#10;    return {&#10;      labels: Object.keys(statusCounts),&#10;      datasets: [&#10;        {&#10;          data: Object.values(statusCounts),&#10;          backgroundColor: [&#10;            &quot;rgba(255, 99, 132, 0.8)&quot;,&#10;            &quot;rgba(54, 162, 235, 0.8)&quot;,&#10;            &quot;rgba(255, 205, 86, 0.8)&quot;,&#10;            &quot;rgba(75, 192, 192, 0.8)&quot;,&#10;            &quot;rgba(153, 102, 255, 0.8)&quot;,&#10;            &quot;rgba(255, 159, 64, 0.8)&quot;,&#10;          ],&#10;          borderWidth: 2,&#10;          borderColor: &quot;#fff&quot;,&#10;        },&#10;      ],&#10;    };&#10;  }, [orders]);&#10;&#10;  const chartOptions = {&#10;    responsive: true,&#10;    maintainAspectRatio: false,&#10;    plugins: {&#10;      legend: {&#10;        position: &quot;top&quot;,&#10;        labels: {&#10;          color: &quot;rgb(156, 163, 175)&quot;,&#10;          font: {&#10;            size: 12,&#10;          },&#10;        },&#10;      },&#10;      title: {&#10;        display: false,&#10;      },&#10;      tooltip: {&#10;        backgroundColor: &quot;rgba(0, 0, 0, 0.8)&quot;,&#10;        titleColor: &quot;#fff&quot;,&#10;        bodyColor: &quot;#fff&quot;,&#10;        borderColor: &quot;rgba(255, 255, 255, 0.1)&quot;,&#10;        borderWidth: 1,&#10;      },&#10;    },&#10;    scales: {&#10;      x: {&#10;        grid: {&#10;          color: &quot;rgba(156, 163, 175, 0.1)&quot;,&#10;        },&#10;        ticks: {&#10;          color: &quot;rgb(156, 163, 175)&quot;,&#10;        },&#10;      },&#10;      y: {&#10;        grid: {&#10;          color: &quot;rgba(156, 163, 175, 0.1)&quot;,&#10;        },&#10;        ticks: {&#10;          color: &quot;rgb(156, 163, 175)&quot;,&#10;        },&#10;      },&#10;    },&#10;  };&#10;&#10;  const mixedChartOptions = {&#10;    ...chartOptions,&#10;    scales: {&#10;      x: {&#10;        grid: {&#10;          color: &quot;rgba(156, 163, 175, 0.1)&quot;,&#10;        },&#10;        ticks: {&#10;          color: &quot;rgb(156, 163, 175)&quot;,&#10;        },&#10;      },&#10;      y: {&#10;        type: &quot;linear&quot;,&#10;        display: true,&#10;        position: &quot;left&quot;,&#10;        grid: {&#10;          color: &quot;rgba(156, 163, 175, 0.1)&quot;,&#10;        },&#10;        ticks: {&#10;          color: &quot;rgb(156, 163, 175)&quot;,&#10;          callback: function (value) {&#10;            return formatPrice(value);&#10;          },&#10;        },&#10;      },&#10;      y1: {&#10;        type: &quot;linear&quot;,&#10;        display: true,&#10;        position: &quot;right&quot;,&#10;        grid: {&#10;          drawOnChartArea: false,&#10;        },&#10;        ticks: {&#10;          color: &quot;rgb(156, 163, 175)&quot;,&#10;        },&#10;      },&#10;    },&#10;  };&#10;&#10;  const bubbleChartOptions = {&#10;    ...chartOptions,&#10;    scales: {&#10;      x: {&#10;        title: {&#10;          display: true,&#10;          text: &quot;Product Price&quot;,&#10;          color: &quot;rgb(156, 163, 175)&quot;,&#10;        },&#10;        grid: {&#10;          color: &quot;rgba(156, 163, 175, 0.1)&quot;,&#10;        },&#10;        ticks: {&#10;          color: &quot;rgb(156, 163, 175)&quot;,&#10;          callback: function (value) {&#10;            return formatPrice(value);&#10;          },&#10;        },&#10;      },&#10;      y: {&#10;        title: {&#10;          display: true,&#10;          text: &quot;Quantity Sold&quot;,&#10;          color: &quot;rgb(156, 163, 175)&quot;,&#10;        },&#10;        grid: {&#10;          color: &quot;rgba(156, 163, 175, 0.1)&quot;,&#10;        },&#10;        ticks: {&#10;          color: &quot;rgb(156, 163, 175)&quot;,&#10;        },&#10;      },&#10;    },&#10;    plugins: {&#10;      ...chartOptions.plugins,&#10;      tooltip: {&#10;        ...chartOptions.plugins.tooltip,&#10;        callbacks: {&#10;          label: function (context) {&#10;            const point = context.raw;&#10;            return `${point.label}: Price ${formatPrice(point.x)}, Sold ${point.y}, Revenue ${formatPrice(point.revenue)}`;&#10;          },&#10;        },&#10;      },&#10;    },&#10;  };&#10;&#10;  const radarOptions = {&#10;    responsive: true,&#10;    maintainAspectRatio: false,&#10;    plugins: {&#10;      legend: {&#10;        position: &quot;top&quot;,&#10;        labels: {&#10;          color: &quot;rgb(156, 163, 175)&quot;,&#10;          font: {&#10;            size: 12,&#10;          },&#10;        },&#10;      },&#10;      tooltip: {&#10;        backgroundColor: &quot;rgba(0, 0, 0, 0.8)&quot;,&#10;        titleColor: &quot;#fff&quot;,&#10;        bodyColor: &quot;#fff&quot;,&#10;        borderColor: &quot;rgba(255, 255, 255, 0.1)&quot;,&#10;        borderWidth: 1,&#10;        callbacks: {&#10;          label: function (context) {&#10;            const datasetLabel = context.dataset.label;&#10;            const categoryName = datasetLabel.split(&quot; (&quot;)[0];&#10;            const stats = categoryStats[categoryName];&#10;            const pointIndex = context.dataIndex;&#10;&#10;            if (!stats) return context.formattedValue;&#10;&#10;            const labels = [&#10;              `Products: ${stats.count}`,&#10;              `Revenue: ${formatPrice(stats.revenue)}`,&#10;              `Active: ${stats.active}`,&#10;              `Avg Price: ${formatPrice(stats.avgPrice)}`,&#10;              `Stock: ${stats.totalStock}`,&#10;            ];&#10;&#10;            return labels[pointIndex] || context.formattedValue;&#10;          },&#10;        },&#10;      },&#10;    },&#10;    scales: {&#10;      r: {&#10;        angleLines: {&#10;          color: &quot;rgba(156, 163, 175, 0.2)&quot;,&#10;        },&#10;        grid: {&#10;          color: &quot;rgba(156, 163, 175, 0.2)&quot;,&#10;        },&#10;        pointLabels: {&#10;          color: &quot;rgb(156, 163, 175)&quot;,&#10;          font: {&#10;            size: 11,&#10;          },&#10;        },&#10;        ticks: {&#10;          color: &quot;rgba(156, 163, 175, 0.8)&quot;,&#10;          backdropColor: &quot;transparent&quot;,&#10;          stepSize: 20,&#10;          min: 0,&#10;          max: 100,&#10;        },&#10;      },&#10;    },&#10;  };&#10;&#10;  const polarOptions = {&#10;    responsive: true,&#10;    maintainAspectRatio: false,&#10;    plugins: {&#10;      legend: {&#10;        position: &quot;right&quot;,&#10;        labels: {&#10;          color: &quot;rgb(156, 163, 175)&quot;,&#10;          font: {&#10;            size: 12,&#10;          },&#10;        },&#10;      },&#10;    },&#10;    scales: {&#10;      r: {&#10;        grid: {&#10;          color: &quot;rgba(156, 163, 175, 0.2)&quot;,&#10;        },&#10;        ticks: {&#10;          color: &quot;rgba(156, 163, 175, 0.8)&quot;,&#10;          backdropColor: &quot;transparent&quot;,&#10;        },&#10;      },&#10;    },&#10;  };&#10;&#10;  // Calculate actual performance metrics&#10;  const performanceMetrics = useMemo(() =&gt; {&#10;    const validOrders = orders.filter(&#10;      (order) =&gt; order.status !== &quot;cancelled&quot; &amp;&amp; order.status !== &quot;returned&quot;,&#10;    );&#10;&#10;    // Calculate conversion rate (delivered orders / total orders)&#10;    const conversionRate =&#10;      orders.length &gt; 0&#10;        ? (&#10;            (orders.filter((o) =&gt; o.status === &quot;delivered&quot;).length /&#10;              orders.length) *&#10;            100&#10;          ).toFixed(1)&#10;        : 0;&#10;&#10;    // Calculate revenue growth (compare last 30 days with previous 30 days)&#10;    const today = new Date();&#10;    const thirtyDaysAgo = new Date(today.getTime() - 30 * 24 * 60 * 60 * 1000);&#10;    const sixtyDaysAgo = new Date(today.getTime() - 60 * 24 * 60 * 60 * 1000);&#10;&#10;    const recentRevenue = validOrders&#10;      .filter((order) =&gt; new Date(order.createdAt) &gt;= thirtyDaysAgo)&#10;      .reduce(&#10;        (sum, order) =&gt; sum + (order.farmerSubtotal || order.total || 0),&#10;        0,&#10;      );&#10;&#10;    const previousRevenue = validOrders&#10;      .filter((order) =&gt; {&#10;        const orderDate = new Date(order.createdAt);&#10;        return orderDate &gt;= sixtyDaysAgo &amp;&amp; orderDate &lt; thirtyDaysAgo;&#10;      })&#10;      .reduce(&#10;        (sum, order) =&gt; sum + (order.farmerSubtotal || order.total || 0),&#10;        0,&#10;      );&#10;&#10;    let revenueGrowth = 0;&#10;    if (previousRevenue &gt; 0 &amp;&amp; recentRevenue &gt; 0) {&#10;      revenueGrowth = (&#10;        ((recentRevenue - previousRevenue) / previousRevenue) *&#10;        100&#10;      ).toFixed(1);&#10;    } else if (recentRevenue &gt; 0 &amp;&amp; previousRevenue === 0) {&#10;      revenueGrowth = 100; // 100% growth when starting from 0&#10;    }&#10;&#10;    // Calculate customer retention (customers who made repeat orders)&#10;    const uniqueCustomers = [&#10;      ...new Set(validOrders.map((order) =&gt; order.userId)),&#10;    ];&#10;    const repeatCustomers = uniqueCustomers.filter((customerId) =&gt; {&#10;      const customerOrders = validOrders.filter(&#10;        (order) =&gt; order.userId === customerId,&#10;      );&#10;      return customerOrders.length &gt; 1;&#10;    });&#10;&#10;    const customerRetention =&#10;      uniqueCustomers.length &gt; 0&#10;        ? ((repeatCustomers.length / uniqueCustomers.length) * 100).toFixed(1)&#10;        : 0;&#10;&#10;    return {&#10;      conversionRate,&#10;      revenueGrowth,&#10;      customerRetention,&#10;      hasActivity: validOrders.length &gt; 0 || products.length &gt; 0,&#10;    };&#10;  }, [orders, products]);&#10;&#10;  return (&#10;    &lt;div className=&quot;space-y-8&quot;&gt;&#10;      {/* Header Stats */}&#10;      &lt;div className=&quot;grid grid-cols-1 md:grid-cols-4 gap-6&quot;&gt;&#10;        &lt;div className=&quot;bg-gradient-to-br from-blue-500 to-blue-600 rounded-xl shadow-lg p-6 text-white&quot;&gt;&#10;          &lt;div className=&quot;flex items-center justify-between&quot;&gt;&#10;            &lt;div&gt;&#10;              &lt;p className=&quot;text-blue-100 text-sm font-medium&quot;&gt;Total Revenue&lt;/p&gt;&#10;              &lt;p className=&quot;text-3xl font-bold&quot;&gt;&#10;                {formatPrice(analytics.totalRevenue || 0)}&#10;              &lt;/p&gt;&#10;            &lt;/div&gt;&#10;            &lt;div className=&quot;p-3 bg-white bg-opacity-20 rounded-lg&quot;&gt;&#10;              &lt;i className=&quot;fas fa-dollar-sign text-2xl&quot;&gt;&lt;/i&gt;&#10;            &lt;/div&gt;&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;&#10;        &lt;div className=&quot;bg-gradient-to-br from-green-500 to-green-600 rounded-xl shadow-lg p-6 text-white&quot;&gt;&#10;          &lt;div className=&quot;flex items-center justify-between&quot;&gt;&#10;            &lt;div&gt;&#10;              &lt;p className=&quot;text-green-100 text-sm font-medium&quot;&gt;Total Orders&lt;/p&gt;&#10;              &lt;p className=&quot;text-3xl font-bold&quot;&gt;{analytics.totalOrders || 0}&lt;/p&gt;&#10;            &lt;/div&gt;&#10;            &lt;div className=&quot;p-3 bg-white bg-opacity-20 rounded-lg&quot;&gt;&#10;              &lt;i className=&quot;fas fa-shopping-cart text-2xl&quot;&gt;&lt;/i&gt;&#10;            &lt;/div&gt;&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;&#10;        &lt;div className=&quot;bg-gradient-to-br from-purple-500 to-purple-600 rounded-xl shadow-lg p-6 text-white&quot;&gt;&#10;          &lt;div className=&quot;flex items-center justify-between&quot;&gt;&#10;            &lt;div&gt;&#10;              &lt;p className=&quot;text-purple-100 text-sm font-medium&quot;&gt;&#10;                Active Products&#10;              &lt;/p&gt;&#10;              &lt;p className=&quot;text-3xl font-bold&quot;&gt;&#10;                {analytics.activeProducts || 0}&#10;              &lt;/p&gt;&#10;            &lt;/div&gt;&#10;            &lt;div className=&quot;p-3 bg-white bg-opacity-20 rounded-lg&quot;&gt;&#10;              &lt;i className=&quot;fas fa-box text-2xl&quot;&gt;&lt;/i&gt;&#10;            &lt;/div&gt;&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;&#10;        &lt;div className=&quot;bg-gradient-to-br from-orange-500 to-orange-600 rounded-xl shadow-lg p-6 text-white&quot;&gt;&#10;          &lt;div className=&quot;flex items-center justify-between&quot;&gt;&#10;            &lt;div&gt;&#10;              &lt;p className=&quot;text-orange-100 text-sm font-medium&quot;&gt;&#10;                Avg Order Value&#10;              &lt;/p&gt;&#10;              &lt;p className=&quot;text-3xl font-bold&quot;&gt;&#10;                {formatPrice(analytics.averageOrderValue || 0)}&#10;              &lt;/p&gt;&#10;            &lt;/div&gt;&#10;            &lt;div className=&quot;p-3 bg-white bg-opacity-20 rounded-lg&quot;&gt;&#10;              &lt;i className=&quot;fas fa-chart-line text-2xl&quot;&gt;&lt;/i&gt;&#10;            &lt;/div&gt;&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;&#10;      {/* Advanced Charts Row 1 */}&#10;      &lt;div className=&quot;grid grid-cols-1 lg:grid-cols-2 gap-8&quot;&gt;&#10;        {/* Mixed Chart */}&#10;        &lt;div className=&quot;bg-white dark:bg-gray-800 rounded-xl shadow-lg p-6&quot;&gt;&#10;          &lt;h3 className=&quot;text-xl font-bold text-gray-900 dark:text-white mb-6 flex items-center&quot;&gt;&#10;            &lt;i className=&quot;fas fa-chart-area mr-3 text-blue-500&quot;&gt;&lt;/i&gt;&#10;            Revenue &amp; Orders Trend (14 Days)&#10;          &lt;/h3&gt;&#10;          &lt;div className=&quot;h-80&quot;&gt;&#10;            &lt;Chart&#10;              type=&quot;bar&quot;&#10;              data={mixedChartData}&#10;              options={mixedChartOptions}&#10;            /&gt;&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;&#10;        {/* Bubble Chart */}&#10;        &lt;div className=&quot;bg-white dark:bg-gray-800 rounded-xl shadow-lg p-6&quot;&gt;&#10;          &lt;h3 className=&quot;text-xl font-bold text-gray-900 dark:text-white mb-6 flex items-center&quot;&gt;&#10;            &lt;i className=&quot;fas fa-circle-notch mr-3 text-green-500&quot;&gt;&lt;/i&gt;&#10;            Product Performance Matrix&#10;          &lt;/h3&gt;&#10;          &lt;div className=&quot;h-80&quot;&gt;&#10;            &lt;Bubble data={productBubbleData} options={bubbleChartOptions} /&gt;&#10;          &lt;/div&gt;&#10;          &lt;p className=&quot;text-xs text-gray-500 dark:text-gray-400 mt-2&quot;&gt;&#10;            X: Price, Y: Quantity Sold, Bubble Size: Revenue&#10;          &lt;/p&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;&#10;      {/* Advanced Charts Row 2 */}&#10;      &lt;div className=&quot;grid grid-cols-1 lg:grid-cols-2 gap-8&quot;&gt;&#10;        {/* Radar Chart */}&#10;        &lt;div className=&quot;bg-white dark:bg-gray-800 rounded-xl shadow-lg p-6&quot;&gt;&#10;          &lt;h3 className=&quot;text-xl font-bold text-gray-900 dark:text-white mb-6 flex items-center&quot;&gt;&#10;            &lt;i className=&quot;fas fa-spider mr-3 text-purple-500&quot;&gt;&lt;/i&gt;&#10;            Category Performance Analysis&#10;          &lt;/h3&gt;&#10;          &lt;div className=&quot;h-80&quot;&gt;&#10;            &lt;Radar data={categoryRadarData} options={radarOptions} /&gt;&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;&#10;        {/* Polar Area Chart */}&#10;        &lt;div className=&quot;bg-white dark:bg-gray-800 rounded-xl shadow-lg p-6&quot;&gt;&#10;          &lt;h3 className=&quot;text-xl font-bold text-gray-900 dark:text-white mb-6 flex items-center&quot;&gt;&#10;            &lt;i className=&quot;fas fa-chart-pie mr-3 text-pink-500&quot;&gt;&lt;/i&gt;&#10;            Order Status Distribution&#10;          &lt;/h3&gt;&#10;          &lt;div className=&quot;h-80&quot;&gt;&#10;            &lt;PolarArea data={orderStatusData} options={polarOptions} /&gt;&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;&#10;      {/* Detailed Analytics Grid */}&#10;      &lt;div className=&quot;grid grid-cols-1 lg:grid-cols-3 gap-8&quot;&gt;&#10;        {/* Top Categories */}&#10;        &lt;div className=&quot;bg-white dark:bg-gray-800 rounded-xl shadow-lg p-6&quot;&gt;&#10;          &lt;h3 className=&quot;text-lg font-semibold text-gray-900 dark:text-white mb-6 flex items-center&quot;&gt;&#10;            &lt;i className=&quot;fas fa-tags mr-3 text-indigo-500&quot;&gt;&lt;/i&gt;&#10;            Top Categories&#10;          &lt;/h3&gt;&#10;          &lt;div className=&quot;space-y-4&quot;&gt;&#10;            {Object.entries(categoryStats)&#10;              .sort(([, a], [, b]) =&gt; b.revenue - a.revenue)&#10;              .slice(0, 5)&#10;              .map(([category, stats]) =&gt; (&#10;                &lt;div&#10;                  key={category}&#10;                  className=&quot;flex items-center justify-between p-3 bg-gray-50 dark:bg-gray-700 rounded-lg&quot;&#10;                &gt;&#10;                  &lt;div&gt;&#10;                    &lt;p className=&quot;font-medium text-gray-900 dark:text-white&quot;&gt;&#10;                      {category}&#10;                    &lt;/p&gt;&#10;                    &lt;p className=&quot;text-sm text-gray-500 dark:text-gray-400&quot;&gt;&#10;                      {stats.count} products&#10;                    &lt;/p&gt;&#10;                  &lt;/div&gt;&#10;                  &lt;div className=&quot;text-right&quot;&gt;&#10;                    &lt;p className=&quot;font-semibold text-gray-900 dark:text-white&quot;&gt;&#10;                      {formatPrice(stats.revenue)}&#10;                    &lt;/p&gt;&#10;                    &lt;p className=&quot;text-sm text-green-600 dark:text-green-400&quot;&gt;&#10;                      {formatPrice(stats.avgPrice)} avg&#10;                    &lt;/p&gt;&#10;                  &lt;/div&gt;&#10;                &lt;/div&gt;&#10;              ))}&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;&#10;        {/* Performance Metrics */}&#10;        &lt;div className=&quot;bg-white dark:bg-gray-800 rounded-xl shadow-lg p-6&quot;&gt;&#10;          &lt;h3 className=&quot;text-lg font-semibold text-gray-900 dark:text-white mb-6 flex items-center&quot;&gt;&#10;            &lt;i className=&quot;fas fa-tachometer-alt mr-3 text-yellow-500&quot;&gt;&lt;/i&gt;&#10;            Performance Metrics&#10;          &lt;/h3&gt;&#10;          &lt;div className=&quot;space-y-4&quot;&gt;&#10;            &lt;div className=&quot;p-4 bg-gradient-to-r from-blue-50 to-blue-100 dark:from-blue-900 dark:to-blue-800 rounded-lg&quot;&gt;&#10;              &lt;p className=&quot;text-sm font-medium text-blue-800 dark:text-blue-200&quot;&gt;&#10;                Conversion Rate&#10;              &lt;/p&gt;&#10;              &lt;p className=&quot;text-2xl font-bold text-blue-900 dark:text-blue-100&quot;&gt;&#10;                {performanceMetrics.conversionRate}%&#10;              &lt;/p&gt;&#10;            &lt;/div&gt;&#10;            &lt;div className=&quot;p-4 bg-gradient-to-r from-green-50 to-green-100 dark:from-green-900 dark:to-green-800 rounded-lg&quot;&gt;&#10;              &lt;p className=&quot;text-sm font-medium text-green-800 dark:text-green-200&quot;&gt;&#10;                Revenue Growth&#10;              &lt;/p&gt;&#10;              &lt;p className=&quot;text-2xl font-bold text-green-900 dark:text-green-100&quot;&gt;&#10;                +{performanceMetrics.revenueGrowth}%&#10;              &lt;/p&gt;&#10;            &lt;/div&gt;&#10;            &lt;div className=&quot;p-4 bg-gradient-to-r from-purple-50 to-purple-100 dark:from-purple-900 dark:to-purple-800 rounded-lg&quot;&gt;&#10;              &lt;p className=&quot;text-sm font-medium text-purple-800 dark:text-purple-200&quot;&gt;&#10;                Customer Retention&#10;              &lt;/p&gt;&#10;              &lt;p className=&quot;text-2xl font-bold text-purple-900 dark:text-purple-100&quot;&gt;&#10;                {performanceMetrics.customerRetention}%&#10;              &lt;/p&gt;&#10;            &lt;/div&gt;&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;&#10;        {/* Recent Activity */}&#10;        &lt;div className=&quot;bg-white dark:bg-gray-800 rounded-xl shadow-lg p-6&quot;&gt;&#10;          &lt;h3 className=&quot;text-lg font-semibold text-gray-900 dark:text-white mb-6 flex items-center&quot;&gt;&#10;            &lt;i className=&quot;fas fa-clock mr-3 text-red-500&quot;&gt;&lt;/i&gt;&#10;            Recent Activity&#10;          &lt;/h3&gt;&#10;          &lt;div className=&quot;space-y-3&quot;&gt;&#10;            {last30Days&#10;              .slice(-7)&#10;              .reverse()&#10;              .map((day, index) =&gt; (&#10;                &lt;div&#10;                  key={index}&#10;                  className=&quot;flex items-center justify-between p-2 hover:bg-gray-50 dark:hover:bg-gray-700 rounded&quot;&#10;                &gt;&#10;                  &lt;div className=&quot;flex items-center&quot;&gt;&#10;                    &lt;div&#10;                      className={`w-3 h-3 rounded-full mr-3 ${day.orders &gt; 0 ? &quot;bg-green-500&quot; : &quot;bg-gray-300&quot;}`}&#10;                    &gt;&lt;/div&gt;&#10;                    &lt;div&gt;&#10;                      &lt;p className=&quot;text-sm font-medium text-gray-900 dark:text-white&quot;&gt;&#10;                        Day {day.day}&#10;                      &lt;/p&gt;&#10;                      &lt;p className=&quot;text-xs text-gray-500 dark:text-gray-400&quot;&gt;&#10;                        {day.orders} orders&#10;                      &lt;/p&gt;&#10;                    &lt;/div&gt;&#10;                  &lt;/div&gt;&#10;                  &lt;p className=&quot;text-sm font-semibold text-gray-900 dark:text-white&quot;&gt;&#10;                    {formatPrice(day.revenue)}&#10;                  &lt;/p&gt;&#10;                &lt;/div&gt;&#10;              ))}&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  );&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/debug-old-reviews.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/debug-old-reviews.js" />
              <option name="updatedContent" value="// Debug why old products with reviews aren't showing ratings on products page&#10;const { MongoClient, ObjectId } = require('mongodb');&#10;&#10;async function debugOldProductReviews() {&#10;  const client = new MongoClient('mongodb://localhost:27017');&#10;  await client.connect();&#10;  const db = client.db('farmfresh');&#10;  &#10;  console.log(' Debugging old product reviews...\n');&#10;  &#10;  // Get all reviews&#10;  const allReviews = await db.collection('reviews').find({}).toArray();&#10;  console.log(` Total reviews in database: ${allReviews.length}`);&#10;  &#10;  // Get sample of old products (first 5)&#10;  const oldProducts = await db.collection('products').find({}).limit(5).toArray();&#10;  console.log(` Checking first 5 products:\n`);&#10;  &#10;  for (const product of oldProducts) {&#10;    const productId = product._id.toString();&#10;    const productReviews = allReviews.filter(review =&gt; review.productId === productId);&#10;    &#10;    console.log(`Product: ${product.name} (ID: ${productId})`);&#10;    console.log(`  Reviews found: ${productReviews.length}`);&#10;    if (productReviews.length &gt; 0) {&#10;      console.log(`  Sample review: ${productReviews[0].comment?.substring(0, 50)}...`);&#10;      console.log(`  Review rating: ${productReviews[0].rating}`);&#10;    }&#10;    console.log('');&#10;  }&#10;  &#10;  // Check the structure of all reviews&#10;  console.log(' All review product IDs:');&#10;  const reviewProductIds = [...new Set(allReviews.map(r =&gt; r.productId))];&#10;  reviewProductIds.forEach(id =&gt; {&#10;    const count = allReviews.filter(r =&gt; r.productId === id).length;&#10;    console.log(`  ${id}: ${count} reviews`);&#10;  });&#10;  &#10;  await client.close();&#10;}&#10;&#10;debugOldProductReviews().catch(console.error);" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/debug-reviews.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/debug-reviews.js" />
              <option name="updatedContent" value="// Quick debug script to check reviews and products&#10;const { MongoClient } = require('mongodb');&#10;&#10;async function debugReviews() {&#10;  const client = new MongoClient('mongodb://localhost:27017');&#10;  await client.connect();&#10;  const db = client.db('farmfresh');&#10;  &#10;  // Get sample products&#10;  const products = await db.collection('products').find({}).limit(3).toArray();&#10;  console.log('Sample products:');&#10;  products.forEach(p =&gt; console.log(`- ${p.name} (ID: ${p._id})`));&#10;  &#10;  console.log('\n');&#10;  &#10;  // Get sample reviews&#10;  const reviews = await db.collection('reviews').find({}).limit(5).toArray();&#10;  console.log('Sample reviews:');&#10;  reviews.forEach(r =&gt; console.log(`- Product ID: ${r.productId}, Rating: ${r.rating}, Comment: ${r.comment?.substring(0, 30)}...`));&#10;  &#10;  console.log('\n');&#10;  &#10;  // Check for ID matches&#10;  const productIds = products.map(p =&gt; p._id.toString());&#10;  const reviewProductIds = reviews.map(r =&gt; r.productId);&#10;  console.log('Product IDs:', productIds);&#10;  console.log('Review Product IDs:', reviewProductIds);&#10;  &#10;  const matches = productIds.filter(pid =&gt; reviewProductIds.includes(pid));&#10;  console.log('Matching IDs:', matches);&#10;  &#10;  await client.close();&#10;}&#10;&#10;debugReviews().catch(console.error);" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/fix-reviews.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/fix-reviews.js" />
              <option name="originalContent" value="  const client = new MongoClient(&quot;mongodb://localhost:27017&quot;);&#10;  });&#10;&#10;  console.log(`✅ Removed ${result.deletedCount} recent reviews`);&#10;  await client.close();&#10;}&#10;&#10;async function showReviewTimeline() {&#10;  const client = new MongoClient(&quot;mongodb://localhost:27017&quot;);&#10;  await client.connect();&#10;  const db = client.db(&quot;farmfresh&quot;);&#10;&#10;  const reviews = await db&#10;    .collection(&quot;reviews&quot;)&#10;    .find({})&#10;    .sort({ createdAt: 1 })&#10;    .toArray();&#10;&#10;  console.log(&quot;\n Review timeline (oldest to newest):&quot;);&#10;  reviews.forEach((review, index) =&gt; {&#10;    console.log(&#10;      `${index + 1}. ${review.createdAt.toISOString()} - ${review.reviewer} - ${review.comment?.substring(0, 50)}...`,&#10;    );&#10;  });&#10;&#10;  await client.close();&#10;}&#10;" />
              <option name="updatedContent" value="// Check and fix review mess - remove duplicate reviews added by mistake&#10;const { MongoClient, ObjectId } = require(&quot;mongodb&quot;);&#10;&#10;async function fixReviewMess() {&#10;  const client = new MongoClient(&quot;mongodb://localhost:27017&quot;);&#10;  await client.connect();&#10;  const db = client.db(&quot;farmfresh&quot;);&#10;&#10;  console.log(&quot; Analyzing review situation...&quot;);&#10;&#10;  // Get all reviews&#10;  const allReviews = await db.collection(&quot;reviews&quot;).find({}).toArray();&#10;  console.log(`Total reviews in database: ${allReviews.length}`);&#10;&#10;  // Group reviews by product ID&#10;  const reviewsByProduct = {};&#10;  allReviews.forEach((review) =&gt; {&#10;    if (!reviewsByProduct[review.productId]) {&#10;      reviewsByProduct[review.productId] = [];&#10;    }&#10;    reviewsByProduct[review.productId].push(review);&#10;  });&#10;&#10;  console.log(&quot;\n Reviews per product:&quot;);&#10;  Object.entries(reviewsByProduct).forEach(([productId, reviews]) =&gt; {&#10;    const product = reviews[0]; // Just to get some context&#10;    console.log(`Product ID ${productId}: ${reviews.length} reviews`);&#10;&#10;    // Show reviewers to identify duplicates&#10;    const reviewers = reviews.map((r) =&gt; r.reviewer).join(&quot;, &quot;);&#10;    console.log(`  Reviewers: ${reviewers}`);&#10;&#10;    // Check for suspicious patterns (our sample review names)&#10;    const sampleReviewers = [&#10;      &quot;John Doe&quot;,&#10;      &quot;Jane Smith&quot;,&#10;      &quot;Mike Johnson&quot;,&#10;      &quot;Sarah Wilson&quot;,&#10;      &quot;David Brown&quot;,&#10;    ];&#10;    const hasSampleReviews = reviews.some((r) =&gt;&#10;      sampleReviewers.includes(r.reviewer),&#10;    );&#10;    if (hasSampleReviews) {&#10;      console.log(&#10;        `  ⚠️ This product has sample reviews that might need removal`,&#10;      );&#10;    }&#10;    console.log(&quot;&quot;);&#10;  });&#10;&#10;  // Ask what to do&#10;  console.log(&quot;\n What would you like to do?&quot;);&#10;  console.log(&#10;    &quot;1. Remove all reviews with sample reviewer names (John Doe, Jane Smith, etc.)&quot;,&#10;  );&#10;  console.log(&quot;2. Remove reviews created in the last hour (recent additions)&quot;);&#10;  console.log(&#10;    &quot;3. Show me the oldest vs newest reviews to identify which are original&quot;,&#10;  );&#10;  console.log(&quot;\nRun with parameter: node fix-reviews.js [1|2|3]&quot;);&#10;&#10;  await client.close();&#10;}&#10;&#10;// Handle command line arguments&#10;const action = process.argv[2];&#10;&#10;if (action === &quot;1&quot;) {&#10;  removeSampleReviews();&#10;} else if (action === &quot;2&quot;) {&#10;  removeRecentReviews();&#10;} else if (action === &quot;3&quot;) {&#10;  showReviewTimeline();&#10;} else {&#10;  fixReviewMess().catch(console.error);&#10;}&#10;&#10;async function removeSampleReviews() {&#10;  const client = new MongoClient(&quot;mongodb://localhost:27017&quot;);&#10;  await client.connect();&#10;  const db = client.db(&quot;farmfresh&quot;);&#10;&#10;  const sampleReviewers = [&#10;    &quot;John Doe&quot;,&#10;    &quot;Jane Smith&quot;,&#10;    &quot;Mike Johnson&quot;,&#10;    &quot;Sarah Wilson&quot;,&#10;    &quot;David Brown&quot;,&#10;  ];&#10;&#10;  console.log(&quot;️ Removing sample reviews...&quot;);&#10;  const result = await db.collection(&quot;reviews&quot;).deleteMany({&#10;    reviewer: { $in: sampleReviewers },&#10;  });&#10;&#10;  console.log(`✅ Removed ${result.deletedCount} sample reviews`);&#10;&#10;  // Check what's left&#10;  const remainingReviews = await db.collection(&quot;reviews&quot;).find({}).toArray();&#10;  console.log(` Remaining reviews: ${remainingReviews.length}`);&#10;  console.log(&quot;Your original reviews:&quot;);&#10;  remainingReviews.forEach((r) =&gt;&#10;    console.log(`- ${r.reviewer || &quot;Anonymous&quot;}: ${r.comment?.substring(0, 50)}...`),&#10;  );&#10;&#10;  await client.close();&#10;}&#10;&#10;async function removeRecentReviews() {&#10;  const client = new MongoClient(&quot;mongodb://localhost:27017&quot;);&#10;  await client.connect();&#10;  const db = client.db(&quot;farmfresh&quot;);&#10;&#10;  const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);&#10;&#10;  console.log(&quot;️ Removing reviews created in the last hour...&quot;);&#10;  const result = await db.collection(&quot;reviews&quot;).deleteMany({&#10;    createdAt: { $gte: oneHourAgo },&#10;  });&#10;&#10;  console.log(`✅ Removed ${result.deletedCount} recent reviews`);&#10;  await client.close();&#10;}&#10;&#10;async function showReviewTimeline() {&#10;  const client = new MongoClient(&quot;mongodb://localhost:27017&quot;);&#10;  await client.connect();&#10;  const db = client.db(&quot;farmfresh&quot;);&#10;&#10;  const reviews = await db&#10;    .collection(&quot;reviews&quot;)&#10;    .find({})&#10;    .sort({ createdAt: 1 })&#10;    .toArray();&#10;&#10;  console.log(&quot;\n Review timeline (oldest to newest):&quot;);&#10;  reviews.forEach((review, index) =&gt; {&#10;    console.log(&#10;      `${index + 1}. ${review.createdAt.toISOString()} - ${review.reviewer} - ${review.comment?.substring(0, 50)}...`,&#10;    );&#10;  });&#10;&#10;  await client.close();&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/hooks/useDashboardData.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/hooks/useDashboardData.js" />
              <option name="originalContent" value="&quot;use client&quot;;&#10;&#10;import { useQuery, useQueryClient } from &quot;@tanstack/react-query&quot;;&#10;import { useSession } from &quot;next-auth/react&quot;;&#10;import { apiService } from &quot;@/lib/api-service&quot;;&#10;&#10;export function useDashboardData() {&#10;  const { data: session } = useSession();&#10;  const queryClient = useQueryClient();&#10;&#10;  const getUserIdentifiers = () =&gt; {&#10;    if (!session?.user) return null;&#10;    const user = session.user;&#10;    return {&#10;      userId: user.userId || user.id || user._id,&#10;      userEmail: user.email,&#10;    };&#10;  };&#10;&#10;  const userIds = getUserIdentifiers();&#10;&#10;  const { data, isLoading, error, refetch, isRefetching } = useQuery({&#10;    queryKey: [&quot;dashboard&quot;, userIds?.userId, userIds?.userEmail],&#10;    queryFn: async () =&gt; {&#10;      // FIX: Pass more specific farmer filtering parameters to get only THIS farmer's products AND orders&#10;      const productsParams = {&#10;        includeInactive: true,&#10;        // Pass BOTH farmerId and farmerEmail for precise filtering&#10;        farmerId: userIds?.userId, // This will be null/undefined for hardcoded farmers&#10;        farmerEmail: userIds?.userEmail, // This is the email from session&#10;        // Remove limit to get all farmer's products (not just 12)&#10;        limit: 1000, // High limit to get all farmer's products&#10;      };&#10;&#10;      // FIX: Also filter orders by farmer to get only THIS farmer's orders&#10;      const ordersParams = {&#10;        farmerId: userIds?.userId, // Pass farmerId for orders too&#10;        farmerEmail: userIds?.userEmail,&#10;        limit: 1000, // High limit to get all farmer's orders&#10;      };&#10;&#10;      const [productsData, ordersData] = await Promise.all([&#10;        apiService.getProducts(productsParams),&#10;        apiService.getOrders(ordersParams), // Add farmer filtering to orders too&#10;      ]);&#10;&#10;      const dashboardData = {&#10;        products: productsData?.products || [],&#10;        orders: ordersData?.orders || [],&#10;        analytics: ordersData?.analytics || {},&#10;        meta: productsData?.meta || {},&#10;      };&#10;&#10;      return {&#10;        products: dashboardData.products || [],&#10;        orders: dashboardData.orders || [],&#10;        analytics: dashboardData.analytics || {},&#10;        meta: dashboardData.meta || {},&#10;      };&#10;    },&#10;    staleTime: 30 * 1000, // Keep data fresh for 30 seconds to allow optimistic updates&#10;    gcTime: 5 * 60 * 1000, // Cache for 5 minutes&#10;    refetchOnMount: false, // Don't refetch when component mounts - use cache&#10;    refetchOnWindowFocus: false, // Don't refetch when window gets focus - use cache&#10;    retry: 3,&#10;    retryDelay: 1000,&#10;  });&#10;&#10;  // Function to invalidate and refetch dashboard data&#10;  const refreshDashboard = () =&gt; {&#10;    return queryClient.invalidateQueries({&#10;      queryKey: [&quot;dashboard&quot;, userIds?.userId, userIds?.userEmail],&#10;    });&#10;  };&#10;&#10;  // Function to manually refetch&#10;  const refetchDashboard = () =&gt; {&#10;    return refetch();&#10;  };&#10;&#10;  // Function to update specific order in cache without full refetch&#10;  const updateOrderInCache = (orderId, newStatus, updatedOrder) =&gt; {&#10;    queryClient.setQueryData(&#10;      [&quot;dashboard&quot;, userIds?.userId, userIds?.userEmail],&#10;      (oldData) =&gt; {&#10;        if (!oldData) return oldData;&#10;&#10;        const updatedOrders = oldData.orders.map((order) =&gt;&#10;          order._id === orderId || order.id === orderId&#10;            ? { ...order, status: newStatus, ...updatedOrder }&#10;            : order,&#10;        );&#10;&#10;        return {&#10;          ...oldData,&#10;          orders: updatedOrders,&#10;        };&#10;      },&#10;    );&#10;  };&#10;&#10;  // Function to update specific product in cache without full refetch&#10;  const updateProductInCache = (productId, updatedProduct) =&gt; {&#10;    // Update dashboard cache&#10;    queryClient.setQueryData(&#10;      [&quot;dashboard&quot;, userIds?.userId, userIds?.userEmail],&#10;      (oldData) =&gt; {&#10;        if (!oldData) return oldData;&#10;&#10;        const updatedProducts = oldData.products.map((product) =&gt;&#10;          product._id === productId || product.id === productId&#10;            ? { ...product, ...updatedProduct }&#10;            : product,&#10;        );&#10;&#10;        return {&#10;          ...oldData,&#10;          products: updatedProducts,&#10;        };&#10;      },&#10;    );&#10;&#10;    // CRITICAL FIX: Update ALL products queries with different filter combinations&#10;    const allProductsQueries = queryClient.getQueryCache().findAll({&#10;      queryKey: [&quot;products&quot;],&#10;    });&#10;&#10;    allProductsQueries.forEach((query) =&gt; {&#10;      queryClient.setQueryData(query.queryKey, (oldData) =&gt; {&#10;        if (!oldData?.products) return oldData;&#10;&#10;        const updatedProducts = oldData.products.map((product) =&gt;&#10;          product._id === productId || product.id === productId&#10;            ? { ...product, ...updatedProduct }&#10;            : product,&#10;        );&#10;&#10;        return {&#10;          ...oldData,&#10;          products: updatedProducts,&#10;        };&#10;      });&#10;    });&#10;&#10;    // AGGRESSIVE FIX: Force immediate refetch with multiple strategies&#10;    setTimeout(() =&gt; {&#10;      // Strategy 1: Force refetch all products queries&#10;      allProductsQueries.forEach((query) =&gt; {&#10;        queryClient.refetchQueries({&#10;          queryKey: query.queryKey,&#10;          type: &quot;active&quot;,&#10;        });&#10;      });&#10;&#10;      // Strategy 2: Clear and invalidate&#10;      queryClient.removeQueries({&#10;        queryKey: [&quot;products&quot;],&#10;        exact: false,&#10;      });&#10;&#10;      queryClient.invalidateQueries({&#10;        queryKey: [&quot;products&quot;],&#10;        exact: false,&#10;        refetchType: &quot;active&quot;,&#10;      });&#10;    }, 100); // Small delay to ensure cache updates are complete&#10;  };&#10;&#10;  // Function to update multiple products in cache (bulk update)&#10;  const updateBulkProductsInCache = (productIds, updateData) =&gt; {&#10;    queryClient.setQueryData(&#10;      [&quot;dashboard&quot;, userIds?.userId, userIds?.userEmail],&#10;      (oldData) =&gt; {&#10;        if (!oldData) return oldData;&#10;&#10;        const updatedProducts = oldData.products.map((product) =&gt;&#10;          productIds.includes(product._id || product.id)&#10;            ? { ...product, ...updateData }&#10;            : product,&#10;        );&#10;&#10;        return {&#10;          ...oldData,&#10;          products: updatedProducts,&#10;        };&#10;      },&#10;    );&#10;  };&#10;&#10;  // Simple bulk update function - Fixed to maintain optimistic updates properly&#10;  const bulkUpdateProducts = async (productIds, updateData) =&gt; {&#10;    try {&#10;      // OPTIMISTIC UPDATE: Update the cache immediately to prevent UI flickering&#10;      queryClient.setQueryData(&#10;        [&quot;dashboard&quot;, userIds?.userId, userIds?.userEmail],&#10;        (oldData) =&gt; {&#10;          if (!oldData) return oldData;&#10;&#10;          const updatedProducts = oldData.products&#10;            .map((product) =&gt; {&#10;              const shouldUpdate = productIds.includes(&#10;                product._id || product.id,&#10;              );&#10;              if (!shouldUpdate) return product;&#10;&#10;              const updatedProduct = { ...product, ...updateData };&#10;&#10;              // If product is being deactivated, it should be removed from public products page&#10;              if (updateData.status === &quot;inactive&quot;) {&#10;                return null; // Mark for removal&#10;              }&#10;&#10;              return updatedProduct;&#10;            })&#10;            .filter(Boolean); // Remove null entries (deactivated products)&#10;&#10;          // If a product was activated, we need to check if it should be added&#10;          // This handles the case where an inactive product becomes active&#10;          const shouldAddActivatedProducts = updateData.status === &quot;active&quot;;&#10;&#10;          if (shouldAddActivatedProducts) {&#10;          }&#10;&#10;          return {&#10;            ...oldData,&#10;            products: updatedProducts,&#10;          };&#10;        },&#10;      );&#10;&#10;      // SYNC WITH PRODUCTS PAGE: Update products page cache too - ENHANCED to handle all cases&#10;      const productsQueryKeys = queryClient.getQueryCache().findAll({&#10;        queryKey: [&quot;products&quot;],&#10;      });&#10;&#10;      productsQueryKeys.forEach((query) =&gt; {&#10;        queryClient.setQueryData(query.queryKey, (oldData) =&gt; {&#10;          if (!oldData?.products) return oldData;&#10;&#10;          const updatedProducts = oldData.products&#10;            .map((product) =&gt; {&#10;              const shouldUpdate = productIds.includes(&#10;                product._id || product.id,&#10;              );&#10;              if (!shouldUpdate) return product;&#10;&#10;              const updatedProduct = { ...product, ...updateData };&#10;&#10;              // If product is being deactivated, remove from public products page&#10;              if (updateData.status === &quot;inactive&quot;) {&#10;                return null; // Mark for removal&#10;              }&#10;&#10;              return updatedProduct;&#10;            })&#10;            .filter(Boolean); // Remove null entries (deactivated products)&#10;&#10;          return {&#10;            ...oldData,&#10;            products: updatedProducts,&#10;            pagination: oldData.pagination&#10;              ? {&#10;                  ...oldData.pagination,&#10;                  // Update total count if products were removed&#10;                  total:&#10;                    oldData.pagination.total -&#10;                    (oldData.products.length - updatedProducts.length),&#10;                }&#10;              : undefined,&#10;          };&#10;        });&#10;      });&#10;&#10;      if (updateData.status === &quot;active&quot;) {&#10;        productsQueryKeys.forEach((query) =&gt; {&#10;          queryClient.setQueryData(query.queryKey, (oldData) =&gt; {&#10;            if (!oldData?.products) return oldData;&#10;&#10;            // Get the activated products from dashboard cache&#10;            const dashboardData = queryClient.getQueryData([&#10;              &quot;dashboard&quot;,&#10;              userIds?.userId,&#10;              userIds?.userEmail,&#10;            ]);&#10;&#10;            if (dashboardData?.products) {&#10;              const activatedProducts = dashboardData.products.filter(&#10;                (p) =&gt;&#10;                  productIds.includes(p._id || p.id) &amp;&amp; p.status === &quot;active&quot;,&#10;              );&#10;&#10;              // Add activated products to products page cache if they don't exist&#10;              const existingIds = oldData.products.map((p) =&gt; p._id || p.id);&#10;              const newProducts = activatedProducts.filter(&#10;                (p) =&gt; !existingIds.includes(p._id || p.id),&#10;              );&#10;&#10;              if (newProducts.length &gt; 0) {&#10;                const combinedProducts = [...newProducts, ...oldData.products];&#10;&#10;                return {&#10;                  ...oldData,&#10;                  products: combinedProducts,&#10;                  pagination: oldData.pagination&#10;                    ? {&#10;                        ...oldData.pagination,&#10;                        total:&#10;                          (oldData.pagination.total || 0) + newProducts.length,&#10;                      }&#10;                    : undefined,&#10;                };&#10;              }&#10;            }&#10;&#10;            return oldData;&#10;          });&#10;        });&#10;      }&#10;&#10;      // Call the API&#10;      const result = await apiService.bulkUpdateProducts(&#10;        productIds,&#10;        updateData,&#10;      );&#10;&#10;      // Clear API service caches but keep React Query optimistic updates&#10;      if (apiService.clearProductsCache) {&#10;        apiService.clearProductsCache();&#10;      }&#10;&#10;      // Set a delayed background refresh to sync with server data without disrupting UI&#10;      setTimeout(async () =&gt; {&#10;        // Only invalidate with refetchType: &quot;none&quot; to mark as stale but keep current data&#10;        queryClient.invalidateQueries({&#10;          queryKey: [&quot;dashboard&quot;, userIds?.userId, userIds?.userEmail],&#10;          exact: true,&#10;          refetchType: &quot;none&quot;, // Don't refetch immediately - keep optimistic updates&#10;        });&#10;&#10;        // Invalidate other product queries for consistency across the app&#10;        queryClient.invalidateQueries({&#10;          queryKey: [&quot;products&quot;],&#10;          exact: false,&#10;          refetchType: &quot;none&quot;, // Don't refetch immediately&#10;        });&#10;      }, 5000); // Wait 5 seconds before background sync&#10;      return result;&#10;    } catch (error) {&#10;      console.error(&quot;❌ [Dashboard] Bulk product update failed:&quot;, error);&#10;&#10;      // If API call failed, revert the optimistic update&#10;      await queryClient.invalidateQueries({&#10;        queryKey: [&quot;dashboard&quot;, userIds?.userId, userIds?.userEmail],&#10;        exact: true,&#10;        refetchType: &quot;active&quot;, // Force refetch to get correct data on error&#10;      });&#10;&#10;      // Also revert products page cache&#10;      await queryClient.invalidateQueries({&#10;        queryKey: [&quot;products&quot;],&#10;        exact: false,&#10;        refetchType: &quot;active&quot;,&#10;      });&#10;&#10;      throw error;&#10;    }&#10;  };&#10;&#10;  // Function to delete product with optimistic updates (similar to bulkUpdateProducts)&#10;  const deleteProduct = async (productId) =&gt; {&#10;    try {&#10;      // OPTIMISTIC UPDATE: Remove the product from dashboard cache immediately&#10;      queryClient.setQueryData(&#10;        [&quot;dashboard&quot;, userIds?.userId, userIds?.userEmail],&#10;        (oldData) =&gt; {&#10;          if (!oldData) return oldData;&#10;&#10;          const updatedProducts = oldData.products.filter(&#10;            (product) =&gt; product._id !== productId &amp;&amp; product.id !== productId,&#10;          );&#10;&#10;          return {&#10;            ...oldData,&#10;            products: updatedProducts,&#10;          };&#10;        },&#10;      );&#10;&#10;      // SYNC WITH UNIFIED PRODUCTS PAGE CACHE: Also remove from unified products cache&#10;      const unifiedProductsQueryKeys = queryClient.getQueryCache().findAll({&#10;        queryKey: [&quot;products&quot;, &quot;all&quot;],&#10;      });&#10;&#10;      unifiedProductsQueryKeys.forEach((query) =&gt; {&#10;        queryClient.setQueryData(query.queryKey, (oldData) =&gt; {&#10;          if (!oldData?.products) return oldData;&#10;&#10;          const filteredProducts = oldData.products.filter(&#10;            (product) =&gt; product._id !== productId &amp;&amp; product.id !== productId,&#10;          );&#10;&#10;          return {&#10;            ...oldData,&#10;            products: filteredProducts,&#10;            meta: {&#10;              ...oldData.meta,&#10;              total: Math.max((oldData.meta?.total || 0) - 1, 0),&#10;            },&#10;          };&#10;        });&#10;      });&#10;&#10;      // Call the API&#10;      const response = await fetch(`/api/products/${productId}`, {&#10;        method: &quot;DELETE&quot;,&#10;      });&#10;&#10;      if (!response.ok) {&#10;        let errorData;&#10;        try {&#10;          errorData = await response.json();&#10;        } catch (jsonError) {&#10;          errorData = {&#10;            error: `HTTP ${response.status}: ${response.statusText}`,&#10;          };&#10;        }&#10;        throw new Error(errorData.error || &quot;Failed to delete product&quot;);&#10;      }&#10;&#10;      const result = await response.json();&#10;&#10;      if (!result.success &amp;&amp; !result.message) {&#10;        throw new Error(result.error || &quot;Failed to delete product&quot;);&#10;      }&#10;&#10;      // Clear API service caches&#10;      if (apiService.clearProductsCache) {&#10;        apiService.clearProductsCache();&#10;      }&#10;&#10;      // Set a delayed background refresh to sync with server data&#10;      setTimeout(async () =&gt; {&#10;        queryClient.invalidateQueries({&#10;          queryKey: [&quot;dashboard&quot;, userIds?.userId, userIds?.userEmail],&#10;          exact: true,&#10;          refetchType: &quot;none&quot;,&#10;        });&#10;&#10;        queryClient.invalidateQueries({&#10;          queryKey: [&quot;products&quot;],&#10;          exact: false,&#10;          refetchType: &quot;none&quot;,&#10;        });&#10;      }, 5000);&#10;&#10;      return { success: true };&#10;    } catch (error) {&#10;      console.error(&quot;❌ [Dashboard] Product deletion failed:&quot;, error);&#10;&#10;      // If API call failed, revert the optimistic update by refetching both caches&#10;      await queryClient.invalidateQueries({&#10;        queryKey: [&quot;dashboard&quot;, userIds?.userId, userIds?.userEmail],&#10;        exact: true,&#10;        refetchType: &quot;active&quot;,&#10;      });&#10;&#10;      await queryClient.invalidateQueries({&#10;        queryKey: [&quot;products&quot;],&#10;        exact: false,&#10;        refetchType: &quot;active&quot;,&#10;      });&#10;&#10;      throw error;&#10;    }&#10;  };&#10;&#10;  // Function to add product with optimistic updates (FIXED VERSION)&#10;  const addProduct = async (productData) =&gt; {&#10;    try {&#10;      // Generate a truly unique temporary ID&#10;      const tempId = `temp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;&#10;      const currentTime = new Date().toISOString();&#10;      const optimisticProduct = {&#10;        ...productData,&#10;        _id: tempId,&#10;        id: tempId,&#10;        createdAt: currentTime,&#10;        updatedAt: currentTime,&#10;        status: &quot;active&quot;,&#10;        averageRating: 0,&#10;        totalReviews: 0,&#10;        reviewCount: 0,&#10;        purchaseCount: 0,&#10;      };&#10;&#10;      // OPTIMISTIC UPDATE: Add the product to dashboard cache immediately&#10;      queryClient.setQueryData(&#10;        [&quot;dashboard&quot;, userIds?.userId, userIds?.userEmail],&#10;        (oldData) =&gt; {&#10;          if (!oldData) return oldData;&#10;&#10;          // FIXED: Check for duplicates before adding&#10;          const productExists = oldData.products.some(&#10;            (p) =&gt;&#10;              p.name === optimisticProduct.name &amp;&amp;&#10;              p.farmerId === optimisticProduct.farmerId &amp;&amp;&#10;              p.createdAt === optimisticProduct.createdAt,&#10;          );&#10;&#10;          if (productExists) {&#10;            console.log(&#10;              &quot;⚠️ Duplicate product detected, skipping optimistic update&quot;,&#10;            );&#10;            return oldData;&#10;          }&#10;&#10;          return {&#10;            ...oldData,&#10;            products: [optimisticProduct, ...oldData.products],&#10;          };&#10;        },&#10;      );&#10;&#10;      // FIXED: Update unified products page cache with proper duplicate checking&#10;      const unifiedProductsQueryKeys = queryClient.getQueryCache().findAll({&#10;        queryKey: [&quot;products&quot;, &quot;all&quot;],&#10;      });&#10;&#10;      unifiedProductsQueryKeys.forEach((query) =&gt; {&#10;        queryClient.setQueryData(query.queryKey, (oldData) =&gt; {&#10;          if (!oldData?.products) return oldData;&#10;&#10;          // FIXED: Check for duplicates in unified products page cache too&#10;          const productExists = oldData.products.some(&#10;            (p) =&gt;&#10;              p.name === optimisticProduct.name &amp;&amp;&#10;              p.farmerId === optimisticProduct.farmerId &amp;&amp;&#10;              p.createdAt === optimisticProduct.createdAt,&#10;          );&#10;&#10;          if (productExists) {&#10;            console.log(&#10;              &quot;⚠️ Product already exists in unified products cache, skipping&quot;,&#10;            );&#10;            return oldData;&#10;          }&#10;&#10;          const updatedProducts = [optimisticProduct, ...oldData.products];&#10;&#10;          return {&#10;            ...oldData,&#10;            products: updatedProducts,&#10;            meta: {&#10;              ...oldData.meta,&#10;              total: (oldData.meta?.total || 0) + 1,&#10;            },&#10;          };&#10;        });&#10;      });&#10;&#10;      // Call the API to create the actual product&#10;      const response = await fetch(&quot;/api/products&quot;, {&#10;        method: &quot;POST&quot;,&#10;        headers: {&#10;          &quot;Content-Type&quot;: &quot;application/json&quot;,&#10;        },&#10;        body: JSON.stringify(productData),&#10;      });&#10;&#10;      if (!response.ok) {&#10;        // ROLLBACK: Remove the optimistic product on API failure&#10;&#10;        queryClient.setQueryData(&#10;          [&quot;dashboard&quot;, userIds?.userId, userIds?.userEmail],&#10;          (oldData) =&gt; {&#10;            if (!oldData) return oldData;&#10;            return {&#10;              ...oldData,&#10;              products: oldData.products.filter((p) =&gt; p._id !== tempId),&#10;            };&#10;          },&#10;        );&#10;&#10;        unifiedProductsQueryKeys.forEach((query) =&gt; {&#10;          queryClient.setQueryData(query.queryKey, (oldData) =&gt; {&#10;            if (!oldData?.products) return oldData;&#10;            return {&#10;              ...oldData,&#10;              products: oldData.products.filter((p) =&gt; p._id !== tempId),&#10;              meta: {&#10;                ...oldData.meta,&#10;                total: Math.max((oldData.meta?.total || 1) - 1, 0),&#10;              },&#10;            };&#10;          });&#10;        });&#10;&#10;        const errorData = await response.json();&#10;        throw new Error(errorData.error || &quot;Failed to create product&quot;);&#10;      }&#10;&#10;      const result = await response.json();&#10;      const realProductId = result.productId;&#10;&#10;      const finalProduct = {&#10;        ...productData,&#10;        _id: realProductId,&#10;        id: realProductId,&#10;        createdAt: currentTime,&#10;        updatedAt: currentTime,&#10;        status: &quot;active&quot;,&#10;        averageRating: 0,&#10;        totalReviews: 0,&#10;        reviewCount: 0,&#10;        purchaseCount: 0,&#10;      };&#10;&#10;      // FIXED: Replace temp product with real product - better logic&#10;      queryClient.setQueryData(&#10;        [&quot;dashboard&quot;, userIds?.userId, userIds?.userEmail],&#10;        (oldData) =&gt; {&#10;          if (!oldData) return oldData;&#10;&#10;          const updatedProducts = oldData.products.map((product) =&gt; {&#10;            // FIXED: Only replace if it's the exact temp product we created&#10;            if (product._id === tempId &amp;&amp; product.id === tempId) {&#10;              return finalProduct;&#10;            }&#10;            return product;&#10;          });&#10;&#10;          // SAFETY CHECK: If temp product wasn't found, add the real product&#10;          const tempProductFound = oldData.products.some(&#10;            (p) =&gt; p._id === tempId,&#10;          );&#10;          if (!tempProductFound) {&#10;            console.log(&#10;              &quot;⚠️ Temp product not found, adding real product directly&quot;,&#10;            );&#10;            return {&#10;              ...oldData,&#10;              products: [finalProduct, ...oldData.products],&#10;            };&#10;          }&#10;&#10;          return {&#10;            ...oldData,&#10;            products: updatedProducts,&#10;          };&#10;        },&#10;      );&#10;&#10;      // FIXED: Update unified products page caches with real product&#10;      unifiedProductsQueryKeys.forEach((query) =&gt; {&#10;        queryClient.setQueryData(query.queryKey, (oldData) =&gt; {&#10;          if (!oldData?.products) return oldData;&#10;&#10;          const updatedProducts = oldData.products.map((product) =&gt; {&#10;            // FIXED: Only replace if it's the exact temp product we created&#10;            if (product._id === tempId &amp;&amp; product.id === tempId) {&#10;              return finalProduct;&#10;            }&#10;            return product;&#10;          });&#10;&#10;          // SAFETY CHECK: If temp product wasn't found, add the real product&#10;          const tempProductFound = oldData.products.some(&#10;            (p) =&gt; p._id === tempId,&#10;          );&#10;          if (!tempProductFound) {&#10;            console.log(&#10;              &quot;⚠️ Temp product not found in products cache, adding real product&quot;,&#10;            );&#10;            return {&#10;              ...oldData,&#10;              products: updatedProducts,&#10;              pagination: oldData.pagination&#10;                ? {&#10;                    ...oldData.pagination,&#10;                    total: (oldData.pagination.total || 0) + 1,&#10;                  }&#10;                : undefined,&#10;            };&#10;          }&#10;&#10;          return {&#10;            ...oldData,&#10;            products: updatedProducts,&#10;          };&#10;        });&#10;      });&#10;&#10;      return {&#10;        success: true,&#10;        productId: realProductId,&#10;        product: finalProduct,&#10;      };&#10;    } catch (error) {&#10;      console.error(&quot;❌ Error in addProduct:&quot;, error);&#10;&#10;      // Additional cleanup on error&#10;      queryClient.invalidateQueries({ queryKey: [&quot;dashboard&quot;] });&#10;      queryClient.invalidateQueries({ queryKey: [&quot;products&quot;] });&#10;&#10;      throw error;&#10;    }&#10;  };&#10;&#10;  return {&#10;    products: data?.products || [],&#10;    orders: data?.orders || [],&#10;    analytics: data?.analytics || {},&#10;    meta: data?.meta || {},&#10;    isLoading,&#10;    error,&#10;    isRefetching,&#10;    refetch: refetchDashboard,&#10;    refreshDashboard,&#10;    bulkUpdateProducts,&#10;    updateOrderInCache,&#10;    updateProductInCache,&#10;    updateBulkProductsInCache,&#10;    deleteProduct,&#10;    addProduct,&#10;  };&#10;}&#10;" />
              <option name="updatedContent" value="&quot;use client&quot;;&#10;&#10;import { useQuery, useQueryClient } from &quot;@tanstack/react-query&quot;;&#10;import { useSession } from &quot;next-auth/react&quot;;&#10;import { apiService } from &quot;@/lib/api-service&quot;;&#10;&#10;export function useDashboardData() {&#10;  const { data: session } = useSession();&#10;  const queryClient = useQueryClient();&#10;&#10;  const getUserIdentifiers = () =&gt; {&#10;    if (!session?.user) return null;&#10;    const user = session.user;&#10;    return {&#10;      userId: user.userId || user.id || user._id,&#10;      userEmail: user.email,&#10;    };&#10;  };&#10;&#10;  const userIds = getUserIdentifiers();&#10;&#10;  const { data, isLoading, error, refetch, isRefetching } = useQuery({&#10;    queryKey: [&quot;dashboard&quot;, userIds?.userId, userIds?.userEmail],&#10;    queryFn: async () =&gt; {&#10;      // FIX: Pass more specific farmer filtering parameters to get only THIS farmer's products AND orders&#10;      const productsParams = {&#10;        includeInactive: true,&#10;        // Pass BOTH farmerId and farmerEmail for precise filtering&#10;        farmerId: userIds?.userId, // This will be null/undefined for hardcoded farmers&#10;        farmerEmail: userIds?.userEmail, // This is the email from session&#10;        // Remove limit to get all farmer's products (not just 12)&#10;        limit: 1000, // High limit to get all farmer's products&#10;      };&#10;&#10;      // FIX: Also filter orders by farmer to get only THIS farmer's orders&#10;      const ordersParams = {&#10;        farmerId: userIds?.userId, // Pass farmerId for orders too&#10;        farmerEmail: userIds?.userEmail,&#10;        limit: 1000, // High limit to get all farmer's orders&#10;      };&#10;&#10;      const [productsData, ordersData] = await Promise.all([&#10;        apiService.getProducts(productsParams),&#10;        apiService.getOrders(ordersParams), // Add farmer filtering to orders too&#10;      ]);&#10;&#10;      const dashboardData = {&#10;        products: productsData?.products || [],&#10;        orders: ordersData?.orders || [],&#10;        analytics: ordersData?.analytics || {},&#10;        meta: productsData?.meta || {},&#10;      };&#10;&#10;      return {&#10;        products: dashboardData.products || [],&#10;        orders: dashboardData.orders || [],&#10;        analytics: dashboardData.analytics || {},&#10;        meta: dashboardData.meta || {},&#10;      };&#10;    },&#10;    staleTime: 30 * 1000, // Keep data fresh for 30 seconds to allow optimistic updates&#10;    gcTime: 5 * 60 * 1000, // Cache for 5 minutes&#10;    refetchOnMount: false, // Don't refetch when component mounts - use cache&#10;    refetchOnWindowFocus: false, // Don't refetch when window gets focus - use cache&#10;    retry: 3,&#10;    retryDelay: 1000,&#10;  });&#10;&#10;  // Function to invalidate and refetch dashboard data&#10;  const refreshDashboard = () =&gt; {&#10;    return queryClient.invalidateQueries({&#10;      queryKey: [&quot;dashboard&quot;, userIds?.userId, userIds?.userEmail],&#10;    });&#10;  };&#10;&#10;  // Function to manually refetch&#10;  const refetchDashboard = () =&gt; {&#10;    return refetch();&#10;  };&#10;&#10;  // Function to update specific order in cache without full refetch&#10;  const updateOrderInCache = (orderId, newStatus, updatedOrder) =&gt; {&#10;    queryClient.setQueryData(&#10;      [&quot;dashboard&quot;, userIds?.userId, userIds?.userEmail],&#10;      (oldData) =&gt; {&#10;        if (!oldData) return oldData;&#10;&#10;        const updatedOrders = oldData.orders.map((order) =&gt;&#10;          order._id === orderId || order.id === orderId&#10;            ? { ...order, status: newStatus, ...updatedOrder }&#10;            : order,&#10;        );&#10;&#10;        return {&#10;          ...oldData,&#10;          orders: updatedOrders,&#10;        };&#10;      },&#10;    );&#10;  };&#10;&#10;  // Function to update specific product in cache without full refetch&#10;  const updateProductInCache = (productId, updatedProduct) =&gt; {&#10;    // Update dashboard cache&#10;    queryClient.setQueryData(&#10;      [&quot;dashboard&quot;, userIds?.userId, userIds?.userEmail],&#10;      (oldData) =&gt; {&#10;        if (!oldData) return oldData;&#10;&#10;        const updatedProducts = oldData.products.map((product) =&gt;&#10;          product._id === productId || product.id === productId&#10;            ? { ...product, ...updatedProduct }&#10;            : product,&#10;        );&#10;&#10;        return {&#10;          ...oldData,&#10;          products: updatedProducts,&#10;        };&#10;      },&#10;    );&#10;&#10;    // CRITICAL FIX: Update ALL products queries with different filter combinations&#10;    const allProductsQueries = queryClient.getQueryCache().findAll({&#10;      queryKey: [&quot;products&quot;],&#10;    });&#10;&#10;    allProductsQueries.forEach((query) =&gt; {&#10;      queryClient.setQueryData(query.queryKey, (oldData) =&gt; {&#10;        if (!oldData?.products) return oldData;&#10;&#10;        const updatedProducts = oldData.products.map((product) =&gt;&#10;          product._id === productId || product.id === productId&#10;            ? { ...product, ...updatedProduct }&#10;            : product,&#10;        );&#10;&#10;        return {&#10;          ...oldData,&#10;          products: updatedProducts,&#10;        };&#10;      });&#10;    });&#10;&#10;    // AGGRESSIVE FIX: Force immediate refetch with multiple strategies&#10;    setTimeout(() =&gt; {&#10;      // Strategy 1: Force refetch all products queries&#10;      allProductsQueries.forEach((query) =&gt; {&#10;        queryClient.refetchQueries({&#10;          queryKey: query.queryKey,&#10;          type: &quot;active&quot;,&#10;        });&#10;      });&#10;&#10;      // Strategy 2: Clear and invalidate&#10;      queryClient.removeQueries({&#10;        queryKey: [&quot;products&quot;],&#10;        exact: false,&#10;      });&#10;&#10;      queryClient.invalidateQueries({&#10;        queryKey: [&quot;products&quot;],&#10;        exact: false,&#10;        refetchType: &quot;active&quot;,&#10;      });&#10;    }, 100); // Small delay to ensure cache updates are complete&#10;  };&#10;&#10;  // Function to update multiple products in cache (bulk update)&#10;  const updateBulkProductsInCache = (productIds, updateData) =&gt; {&#10;    queryClient.setQueryData(&#10;      [&quot;dashboard&quot;, userIds?.userId, userIds?.userEmail],&#10;      (oldData) =&gt; {&#10;        if (!oldData) return oldData;&#10;&#10;        const updatedProducts = oldData.products.map((product) =&gt;&#10;          productIds.includes(product._id || product.id)&#10;            ? { ...product, ...updateData }&#10;            : product,&#10;        );&#10;&#10;        return {&#10;          ...oldData,&#10;          products: updatedProducts,&#10;        };&#10;      },&#10;    );&#10;  };&#10;&#10;  // Simple bulk update function - Fixed to maintain optimistic updates properly&#10;  const bulkUpdateProducts = async (productIds, updateData) =&gt; {&#10;    try {&#10;      // OPTIMISTIC UPDATE: Update the cache immediately to prevent UI flickering&#10;      queryClient.setQueryData(&#10;        [&quot;dashboard&quot;, userIds?.userId, userIds?.userEmail],&#10;        (oldData) =&gt; {&#10;          if (!oldData) return oldData;&#10;&#10;          const updatedProducts = oldData.products&#10;            .map((product) =&gt; {&#10;              const shouldUpdate = productIds.includes(&#10;                product._id || product.id,&#10;              );&#10;              if (!shouldUpdate) return product;&#10;&#10;              const updatedProduct = { ...product, ...updateData };&#10;&#10;              // If product is being deactivated, it should be removed from public products page&#10;              if (updateData.status === &quot;inactive&quot;) {&#10;                return null; // Mark for removal&#10;              }&#10;&#10;              return updatedProduct;&#10;            })&#10;            .filter(Boolean); // Remove null entries (deactivated products)&#10;&#10;          // If a product was activated, we need to check if it should be added&#10;          // This handles the case where an inactive product becomes active&#10;          const shouldAddActivatedProducts = updateData.status === &quot;active&quot;;&#10;&#10;          if (shouldAddActivatedProducts) {&#10;          }&#10;&#10;          return {&#10;            ...oldData,&#10;            products: updatedProducts,&#10;          };&#10;        },&#10;      );&#10;&#10;      // SYNC WITH PRODUCTS PAGE: Update products page cache too - ENHANCED to handle all cases&#10;      const productsQueryKeys = queryClient.getQueryCache().findAll({&#10;        queryKey: [&quot;products&quot;],&#10;      });&#10;&#10;      productsQueryKeys.forEach((query) =&gt; {&#10;        queryClient.setQueryData(query.queryKey, (oldData) =&gt; {&#10;          if (!oldData?.products) return oldData;&#10;&#10;          const updatedProducts = oldData.products&#10;            .map((product) =&gt; {&#10;              const shouldUpdate = productIds.includes(&#10;                product._id || product.id,&#10;              );&#10;              if (!shouldUpdate) return product;&#10;&#10;              const updatedProduct = { ...product, ...updateData };&#10;&#10;              // If product is being deactivated, remove from public products page&#10;              if (updateData.status === &quot;inactive&quot;) {&#10;                return null; // Mark for removal&#10;              }&#10;&#10;              return updatedProduct;&#10;            })&#10;            .filter(Boolean); // Remove null entries (deactivated products)&#10;&#10;          return {&#10;            ...oldData,&#10;            products: updatedProducts,&#10;            pagination: oldData.pagination&#10;              ? {&#10;                  ...oldData.pagination,&#10;                  // Update total count if products were removed&#10;                  total:&#10;                    oldData.pagination.total -&#10;                    (oldData.products.length - updatedProducts.length),&#10;                }&#10;              : undefined,&#10;          };&#10;        });&#10;      });&#10;&#10;      if (updateData.status === &quot;active&quot;) {&#10;        productsQueryKeys.forEach((query) =&gt; {&#10;          queryClient.setQueryData(query.queryKey, (oldData) =&gt; {&#10;            if (!oldData?.products) return oldData;&#10;&#10;            // Get the activated products from dashboard cache&#10;            const dashboardData = queryClient.getQueryData([&#10;              &quot;dashboard&quot;,&#10;              userIds?.userId,&#10;              userIds?.userEmail,&#10;            ]);&#10;&#10;            if (dashboardData?.products) {&#10;              const activatedProducts = dashboardData.products.filter(&#10;                (p) =&gt;&#10;                  productIds.includes(p._id || p.id) &amp;&amp; p.status === &quot;active&quot;,&#10;              );&#10;&#10;              // Add activated products to products page cache if they don't exist&#10;              const existingIds = oldData.products.map((p) =&gt; p._id || p.id);&#10;              const newProducts = activatedProducts.filter(&#10;                (p) =&gt; !existingIds.includes(p._id || p.id),&#10;              );&#10;&#10;              if (newProducts.length &gt; 0) {&#10;                const combinedProducts = [...newProducts, ...oldData.products];&#10;&#10;                return {&#10;                  ...oldData,&#10;                  products: combinedProducts,&#10;                  pagination: oldData.pagination&#10;                    ? {&#10;                        ...oldData.pagination,&#10;                        total:&#10;                          (oldData.pagination.total || 0) + newProducts.length,&#10;                      }&#10;                    : undefined,&#10;                };&#10;              }&#10;            }&#10;&#10;            return oldData;&#10;          });&#10;        });&#10;      }&#10;&#10;      // Call the API&#10;      const result = await apiService.bulkUpdateProducts(&#10;        productIds,&#10;        updateData,&#10;      );&#10;&#10;      // Clear API service caches but keep React Query optimistic updates&#10;      if (apiService.clearProductsCache) {&#10;        apiService.clearProductsCache();&#10;      }&#10;&#10;      // Set a delayed background refresh to sync with server data without disrupting UI&#10;      setTimeout(async () =&gt; {&#10;        // Only invalidate with refetchType: &quot;none&quot; to mark as stale but keep current data&#10;        queryClient.invalidateQueries({&#10;          queryKey: [&quot;dashboard&quot;, userIds?.userId, userIds?.userEmail],&#10;          exact: true,&#10;          refetchType: &quot;none&quot;, // Don't refetch immediately - keep optimistic updates&#10;        });&#10;&#10;        // Invalidate other product queries for consistency across the app&#10;        queryClient.invalidateQueries({&#10;          queryKey: [&quot;products&quot;],&#10;          exact: false,&#10;          refetchType: &quot;none&quot;, // Don't refetch immediately&#10;        });&#10;      }, 5000); // Wait 5 seconds before background sync&#10;      return result;&#10;    } catch (error) {&#10;      console.error(&quot;❌ [Dashboard] Bulk product update failed:&quot;, error);&#10;&#10;      // If API call failed, revert the optimistic update&#10;      await queryClient.invalidateQueries({&#10;        queryKey: [&quot;dashboard&quot;, userIds?.userId, userIds?.userEmail],&#10;        exact: true,&#10;        refetchType: &quot;active&quot;, // Force refetch to get correct data on error&#10;      });&#10;&#10;      // Also revert products page cache&#10;      await queryClient.invalidateQueries({&#10;        queryKey: [&quot;products&quot;],&#10;        exact: false,&#10;        refetchType: &quot;active&quot;,&#10;      });&#10;&#10;      throw error;&#10;    }&#10;  };&#10;&#10;  // Function to delete product with optimistic updates (similar to bulkUpdateProducts)&#10;  const deleteProduct = async (productId) =&gt; {&#10;    try {&#10;      // OPTIMISTIC UPDATE: Remove the product from dashboard cache immediately&#10;      queryClient.setQueryData(&#10;        [&quot;dashboard&quot;, userIds?.userId, userIds?.userEmail],&#10;        (oldData) =&gt; {&#10;          if (!oldData) return oldData;&#10;&#10;          const updatedProducts = oldData.products.filter(&#10;            (product) =&gt; product._id !== productId &amp;&amp; product.id !== productId,&#10;          );&#10;&#10;          return {&#10;            ...oldData,&#10;            products: updatedProducts,&#10;          };&#10;        },&#10;      );&#10;&#10;      // SYNC WITH UNIFIED PRODUCTS PAGE CACHE: Also remove from unified products cache&#10;      const unifiedProductsQueryKeys = queryClient.getQueryCache().findAll({&#10;        queryKey: [&quot;products&quot;, &quot;all&quot;],&#10;      });&#10;&#10;      unifiedProductsQueryKeys.forEach((query) =&gt; {&#10;        queryClient.setQueryData(query.queryKey, (oldData) =&gt; {&#10;          if (!oldData?.products) return oldData;&#10;&#10;          const filteredProducts = oldData.products.filter(&#10;            (product) =&gt; product._id !== productId &amp;&amp; product.id !== productId,&#10;          );&#10;&#10;          return {&#10;            ...oldData,&#10;            products: filteredProducts,&#10;            meta: {&#10;              ...oldData.meta,&#10;              total: Math.max((oldData.meta?.total || 0) - 1, 0),&#10;            },&#10;          };&#10;        });&#10;      });&#10;&#10;      // Call the API&#10;      const response = await fetch(`/api/products/${productId}`, {&#10;        method: &quot;DELETE&quot;,&#10;      });&#10;&#10;      if (!response.ok) {&#10;        let errorData;&#10;        try {&#10;          errorData = await response.json();&#10;        } catch (jsonError) {&#10;          errorData = {&#10;            error: `HTTP ${response.status}: ${response.statusText}`,&#10;          };&#10;        }&#10;        throw new Error(errorData.error || &quot;Failed to delete product&quot;);&#10;      }&#10;&#10;      const result = await response.json();&#10;&#10;      if (!result.success &amp;&amp; !result.message) {&#10;        throw new Error(result.error || &quot;Failed to delete product&quot;);&#10;      }&#10;&#10;      // Clear API service caches&#10;      if (apiService.clearProductsCache) {&#10;        apiService.clearProductsCache();&#10;      }&#10;&#10;      // Set a delayed background refresh to sync with server data&#10;      setTimeout(async () =&gt; {&#10;        queryClient.invalidateQueries({&#10;          queryKey: [&quot;dashboard&quot;, userIds?.userId, userIds?.userEmail],&#10;          exact: true,&#10;          refetchType: &quot;none&quot;,&#10;        });&#10;&#10;        queryClient.invalidateQueries({&#10;          queryKey: [&quot;products&quot;],&#10;          exact: false,&#10;          refetchType: &quot;none&quot;,&#10;        });&#10;      }, 5000);&#10;&#10;      return { success: true };&#10;    } catch (error) {&#10;      console.error(&quot;❌ [Dashboard] Product deletion failed:&quot;, error);&#10;&#10;      // If API call failed, revert the optimistic update by refetching both caches&#10;      await queryClient.invalidateQueries({&#10;        queryKey: [&quot;dashboard&quot;, userIds?.userId, userIds?.userEmail],&#10;        exact: true,&#10;        refetchType: &quot;active&quot;,&#10;      });&#10;&#10;      await queryClient.invalidateQueries({&#10;        queryKey: [&quot;products&quot;],&#10;        exact: false,&#10;        refetchType: &quot;active&quot;,&#10;      });&#10;&#10;      throw error;&#10;    }&#10;  };&#10;&#10;  // Function to add product with optimistic updates (FIXED VERSION)&#10;  const addProduct = async (productData) =&gt; {&#10;    try {&#10;      // Generate a truly unique temporary ID&#10;      const tempId = `temp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;&#10;      const currentTime = new Date().toISOString();&#10;      const optimisticProduct = {&#10;        ...productData,&#10;        _id: tempId,&#10;        id: tempId,&#10;        createdAt: currentTime,&#10;        updatedAt: currentTime,&#10;        status: &quot;active&quot;,&#10;        averageRating: 0,&#10;        totalReviews: 0,&#10;        reviewCount: 0,&#10;        purchaseCount: 0,&#10;      };&#10;&#10;      // OPTIMISTIC UPDATE: Add the product to dashboard cache immediately&#10;      queryClient.setQueryData(&#10;        [&quot;dashboard&quot;, userIds?.userId, userIds?.userEmail],&#10;        (oldData) =&gt; {&#10;          if (!oldData) return oldData;&#10;&#10;          // FIXED: Check for duplicates before adding&#10;          const productExists = oldData.products.some(&#10;            (p) =&gt;&#10;              p.name === optimisticProduct.name &amp;&amp;&#10;              p.farmerId === optimisticProduct.farmerId &amp;&amp;&#10;              p.createdAt === optimisticProduct.createdAt,&#10;          );&#10;&#10;          if (productExists) {&#10;            console.log(&#10;              &quot;⚠️ Duplicate product detected, skipping optimistic update&quot;,&#10;            );&#10;            return oldData;&#10;          }&#10;&#10;          return {&#10;            ...oldData,&#10;            products: [optimisticProduct, ...oldData.products],&#10;          };&#10;        },&#10;      );&#10;&#10;      // FIXED: Update unified products page cache with proper duplicate checking&#10;      const unifiedProductsQueryKeys = queryClient.getQueryCache().findAll({&#10;        queryKey: [&quot;products&quot;, &quot;all&quot;],&#10;      });&#10;&#10;      unifiedProductsQueryKeys.forEach((query) =&gt; {&#10;        queryClient.setQueryData(query.queryKey, (oldData) =&gt; {&#10;          if (!oldData?.products) return oldData;&#10;&#10;          // FIXED: Check for duplicates in unified products page cache too&#10;          const productExists = oldData.products.some(&#10;            (p) =&gt;&#10;              p.name === optimisticProduct.name &amp;&amp;&#10;              p.farmerId === optimisticProduct.farmerId &amp;&amp;&#10;              p.createdAt === optimisticProduct.createdAt,&#10;          );&#10;&#10;          if (productExists) {&#10;            console.log(&#10;              &quot;⚠️ Product already exists in unified products cache, skipping&quot;,&#10;            );&#10;            return oldData;&#10;          }&#10;&#10;          const updatedProducts = [optimisticProduct, ...oldData.products];&#10;&#10;          return {&#10;            ...oldData,&#10;            products: updatedProducts,&#10;            meta: {&#10;              ...oldData.meta,&#10;              total: (oldData.meta?.total || 0) + 1,&#10;            },&#10;          };&#10;        });&#10;      });&#10;&#10;      // Call the API to create the actual product&#10;      const response = await fetch(&quot;/api/products&quot;, {&#10;        method: &quot;POST&quot;,&#10;        headers: {&#10;          &quot;Content-Type&quot;: &quot;application/json&quot;,&#10;        },&#10;        body: JSON.stringify(productData),&#10;      });&#10;&#10;      if (!response.ok) {&#10;        // ROLLBACK: Remove the optimistic product on API failure&#10;&#10;        queryClient.setQueryData(&#10;          [&quot;dashboard&quot;, userIds?.userId, userIds?.userEmail],&#10;          (oldData) =&gt; {&#10;            if (!oldData) return oldData;&#10;            return {&#10;              ...oldData,&#10;              products: oldData.products.filter((p) =&gt; p._id !== tempId),&#10;            };&#10;          },&#10;        );&#10;&#10;        unifiedProductsQueryKeys.forEach((query) =&gt; {&#10;          queryClient.setQueryData(query.queryKey, (oldData) =&gt; {&#10;            if (!oldData?.products) return oldData;&#10;            return {&#10;              ...oldData,&#10;              products: oldData.products.filter((p) =&gt; p._id !== tempId),&#10;              meta: {&#10;                ...oldData.meta,&#10;                total: Math.max((oldData.meta?.total || 1) - 1, 0),&#10;              },&#10;            };&#10;          });&#10;        });&#10;&#10;        const errorData = await response.json();&#10;        throw new Error(errorData.error || &quot;Failed to create product&quot;);&#10;      }&#10;&#10;      const result = await response.json();&#10;      const realProductId = result.productId;&#10;&#10;      const finalProduct = {&#10;        ...productData,&#10;        _id: realProductId,&#10;        id: realProductId,&#10;        createdAt: currentTime,&#10;        updatedAt: currentTime,&#10;        status: &quot;active&quot;,&#10;        averageRating: 0,&#10;        totalReviews: 0,&#10;        reviewCount: 0,&#10;        purchaseCount: 0,&#10;      };&#10;&#10;      // FIXED: Replace temp product with real product - better logic&#10;      queryClient.setQueryData(&#10;        [&quot;dashboard&quot;, userIds?.userId, userIds?.userEmail],&#10;        (oldData) =&gt; {&#10;          if (!oldData) return oldData;&#10;&#10;          const updatedProducts = oldData.products.map((product) =&gt; {&#10;            // FIXED: Only replace if it's the exact temp product we created&#10;            if (product._id === tempId &amp;&amp; product.id === tempId) {&#10;              return finalProduct;&#10;            }&#10;            return product;&#10;          });&#10;&#10;          // SAFETY CHECK: If temp product wasn't found, add the real product&#10;          const tempProductFound = oldData.products.some(&#10;            (p) =&gt; p._id === tempId,&#10;          );&#10;          if (!tempProductFound) {&#10;            console.log(&#10;              &quot;⚠️ Temp product not found, adding real product directly&quot;,&#10;            );&#10;            return {&#10;              ...oldData,&#10;              products: [finalProduct, ...oldData.products],&#10;            };&#10;          }&#10;&#10;          return {&#10;            ...oldData,&#10;            products: updatedProducts,&#10;          };&#10;        },&#10;      );&#10;&#10;      // FIXED: Update unified products page caches with real product&#10;      unifiedProductsQueryKeys.forEach((query) =&gt; {&#10;        queryClient.setQueryData(query.queryKey, (oldData) =&gt; {&#10;          if (!oldData?.products) return oldData;&#10;&#10;          const updatedProducts = oldData.products.map((product) =&gt; {&#10;            // FIXED: Only replace if it's the exact temp product we created&#10;            if (product._id === tempId &amp;&amp; product.id === tempId) {&#10;              return finalProduct;&#10;            }&#10;            return product;&#10;          });&#10;&#10;          // SAFETY CHECK: If temp product wasn't found, add the real product&#10;          const tempProductFound = oldData.products.some(&#10;            (p) =&gt; p._id === tempId,&#10;          );&#10;          if (!tempProductFound) {&#10;            console.log(&#10;              &quot;⚠️ Temp product not found in products cache, adding real product&quot;,&#10;            );&#10;            return {&#10;              ...oldData,&#10;              products: updatedProducts,&#10;              pagination: oldData.pagination&#10;                ? {&#10;                    ...oldData.pagination,&#10;                    total: (oldData.pagination.total || 0) + 1,&#10;                  }&#10;                : undefined,&#10;            };&#10;          }&#10;&#10;          return {&#10;            ...oldData,&#10;            products: updatedProducts,&#10;          };&#10;        });&#10;      });&#10;&#10;      return {&#10;        success: true,&#10;        productId: realProductId,&#10;        product: finalProduct,&#10;      };&#10;    } catch (error) {&#10;      console.error(&quot;❌ Error in addProduct:&quot;, error);&#10;&#10;      // Additional cleanup on error&#10;      queryClient.invalidateQueries({ queryKey: [&quot;dashboard&quot;] });&#10;      queryClient.invalidateQueries({ queryKey: [&quot;products&quot;] });&#10;&#10;      throw error;&#10;    }&#10;  };&#10;&#10;  return {&#10;    products: data?.products || [],&#10;    orders: data?.orders || [],&#10;    analytics: data?.analytics || {},&#10;    meta: data?.meta || {},&#10;    isLoading,&#10;    error,&#10;    isRefetching,&#10;    refetch: refetchDashboard,&#10;    refreshDashboard,&#10;    bulkUpdateProducts,&#10;    updateOrderInCache,&#10;    updateProductInCache,&#10;    updateBulkProductsInCache,&#10;    deleteProduct,&#10;    addProduct,&#10;  };&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/lib/api-service.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/lib/api-service.js" />
              <option name="originalContent" value="import globalCache, { sessionCache } from &quot;./cache&quot;;&#10;&#10;// Request deduplication to prevent multiple identical API calls&#10;const ongoingRequests = new Map();&#10;&#10;// Optimized API service with caching and request deduplication&#10;export class ApiService {&#10;  constructor() {&#10;    this.baseURL = &quot;/api&quot;;&#10;  }&#10;&#10;  // Generic fetch with caching and deduplication&#10;  async fetchWithCache(endpoint, params = {}, options = {}) {&#10;    const {&#10;      ttl = 5 * 60 * 1000, // 5 minutes default&#10;      useSessionCache = true,&#10;      skipCache = false,&#10;      ...fetchOptions&#10;    } = options;&#10;&#10;    // Generate cache key&#10;    const cacheKey = globalCache.generateKey(endpoint, params);&#10;    const sessionKey = sessionCache.generateKey(endpoint, params);&#10;&#10;    // ONLY return cached data if NOT skipping cache&#10;    if (!skipCache) {&#10;      // Try memory cache first (fastest)&#10;      const memoryData = globalCache.get(cacheKey);&#10;      if (memoryData) {&#10;        console.log(` [API Service] Returning cached data for ${endpoint}`);&#10;        return memoryData;&#10;      }&#10;&#10;      // Try session cache (survives page reloads)&#10;      if (useSessionCache) {&#10;        const sessionData = sessionCache.get(sessionKey);&#10;        if (sessionData) {&#10;          // Also store in memory cache for faster subsequent access&#10;          globalCache.set(cacheKey, sessionData, ttl);&#10;          return sessionData;&#10;        }&#10;      }&#10;    } else {&#10;    }&#10;&#10;    // Check if same request is already ongoing&#10;    const requestKey = `${endpoint}_${JSON.stringify(params)}`;&#10;    if (ongoingRequests.has(requestKey)) {&#10;      return ongoingRequests.get(requestKey);&#10;    }&#10;&#10;    // Build URL with params&#10;    const url = new URL(endpoint, window.location.origin);&#10;    Object.entries(params).forEach(([key, value]) =&gt; {&#10;      if (value !== null &amp;&amp; value !== undefined &amp;&amp; value !== &quot;&quot;) {&#10;        url.searchParams.append(key, value);&#10;      }&#10;    });&#10;&#10;    // Create the promise and store it to prevent duplicate requests&#10;    const requestPromise = fetch(url.toString(), {&#10;      method: &quot;GET&quot;,&#10;      headers: {&#10;        &quot;Content-Type&quot;: &quot;application/json&quot;,&#10;        ...fetchOptions.headers,&#10;      },&#10;      ...fetchOptions,&#10;    })&#10;      .then(async (response) =&gt; {&#10;        if (!response.ok) {&#10;          throw new Error(`HTTP error! status: ${response.status}`);&#10;        }&#10;        return response.json();&#10;      })&#10;      .then((data) =&gt; {&#10;        // Cache the successful response&#10;        if (!skipCache) {&#10;          globalCache.set(cacheKey, data, ttl);&#10;          if (useSessionCache) {&#10;            sessionCache.set(sessionKey, data, ttl);&#10;          }&#10;        }&#10;        return data;&#10;      })&#10;      .catch((error) =&gt; {&#10;        console.error(`API Error for ${endpoint}:`, error);&#10;        throw error;&#10;      })&#10;      .finally(() =&gt; {&#10;        // Remove from ongoing requests&#10;        ongoingRequests.delete(requestKey);&#10;      });&#10;&#10;    // Store the ongoing request&#10;    ongoingRequests.set(requestKey, requestPromise);&#10;&#10;    return requestPromise;&#10;  }&#10;&#10;  // Products API methods&#10;  async getProducts(params = {}, options = {}) {&#10;    return this.fetchWithCache(&quot;/api/products&quot;, params, {&#10;      ttl: 1 * 60 * 1000, // Reduced to 1 minute for faster updates&#10;      useSessionCache: false, // DISABLE session cache to prevent large cache buildup&#10;      ...options,&#10;    });&#10;  }&#10;&#10;  async getProduct(id) {&#10;    return this.fetchWithCache(&#10;      `/api/products/${id}`,&#10;      {},&#10;      {&#10;        ttl: 10 * 60 * 1000, // 10 minutes for individual products&#10;        useSessionCache: true,&#10;      },&#10;    );&#10;  }&#10;&#10;  // Categories API&#10;  async getCategories() {&#10;    return this.fetchWithCache(&#10;      &quot;/api/categories&quot;,&#10;      {},&#10;      {&#10;        ttl: 30 * 60 * 1000, // 30 minutes for categories (rarely change)&#10;        useSessionCache: true,&#10;      },&#10;    );&#10;  }&#10;&#10;  // Farmers API methods&#10;  async getFarmers(options = {}) {&#10;    return this.fetchWithCache(&#10;      &quot;/api/farmers&quot;,&#10;      {},&#10;      {&#10;        ttl: 5 * 60 * 1000, // 5 minutes for farmers&#10;        useSessionCache: true,&#10;        ...options,&#10;      },&#10;    );&#10;  }&#10;&#10;  async updateFarmer(farmerId, farmerData) {&#10;    // Step 1: Clear caches BEFORE the update to prevent race conditions&#10;    this.clearCache(); // Use the new comprehensive cache clearing method&#10;&#10;    // Step 2: Use PUT method with cache busting headers&#10;    const response = await fetch(&quot;/api/farmers&quot;, {&#10;      method: &quot;PUT&quot;,&#10;      headers: {&#10;        &quot;Content-Type&quot;: &quot;application/json&quot;,&#10;        &quot;Cache-Control&quot;: &quot;no-cache, no-store, must-revalidate&quot;,&#10;        Pragma: &quot;no-cache&quot;,&#10;        Expires: &quot;0&quot;,&#10;        &quot;x-cache-bust&quot;: Date.now().toString(),&#10;        &quot;x-farmer-update&quot;: &quot;true&quot;, // Flag to identify farmer updates&#10;      },&#10;      body: JSON.stringify(farmerData),&#10;    });&#10;&#10;    if (!response.ok) {&#10;      throw new Error(`Failed to update farmer: ${response.status}`);&#10;    }&#10;&#10;    const result = await response.json();&#10;&#10;    // Step 3: Comprehensive cache clearing after successful update&#10;    this.clearCache(); // Clear all API service caches&#10;&#10;    // Step 4: Force React Query cache invalidation if available&#10;    if (typeof window !== &quot;undefined&quot; &amp;&amp; window.__REACT_QUERY_CLIENT__) {&#10;      const queryClient = window.__REACT_QUERY_CLIENT__;&#10;&#10;      // Remove all cached data (most aggressive approach)&#10;      queryClient.clear();&#10;&#10;      // Then force fresh fetches for critical data&#10;      queryClient.invalidateQueries({&#10;        queryKey: [&quot;farmers&quot;],&#10;        refetchType: &quot;all&quot;,&#10;      });&#10;&#10;      queryClient.invalidateQueries({&#10;        queryKey: [&quot;products&quot;],&#10;        refetchType: &quot;all&quot;,&#10;      });&#10;    }&#10;&#10;    // Step 5: Clear browser caches completely&#10;    if (typeof window !== &quot;undefined&quot;) {&#10;      // Clear all storage that might contain cached data&#10;      try {&#10;        // Clear session storage&#10;        const sessionKeys = Object.keys(sessionStorage);&#10;        sessionKeys.forEach((key) =&gt; {&#10;          if (&#10;            key.includes(&quot;farmer&quot;) ||&#10;            key.includes(&quot;product&quot;) ||&#10;            key.includes(&quot;cache&quot;)&#10;          ) {&#10;            sessionStorage.removeItem(key);&#10;          }&#10;        });&#10;&#10;        // Clear local storage&#10;        const localKeys = Object.keys(localStorage);&#10;        localKeys.forEach((key) =&gt; {&#10;          if (&#10;            key.includes(&quot;farmer&quot;) ||&#10;            key.includes(&quot;product&quot;) ||&#10;            key.includes(&quot;cache&quot;)&#10;          ) {&#10;            localStorage.removeItem(key);&#10;          }&#10;        });&#10;&#10;        // Clear browser cache&#10;        if (&quot;caches&quot; in window) {&#10;          window.caches.keys().then((cacheNames) =&gt; {&#10;            cacheNames.forEach((cacheName) =&gt; {&#10;              window.caches.delete(cacheName);&#10;            });&#10;          });&#10;        }&#10;      } catch (error) {&#10;        console.warn(&quot;⚠️ Some cache clearing operations failed:&quot;, error);&#10;      }&#10;    }&#10;&#10;    console.log(&#10;      &quot;✅ Super aggressive cache clearing completed - farmer names will update immediately across all pages&quot;,&#10;    );&#10;&#10;    return result;&#10;  }&#10;&#10;  // Orders API methods&#10;  async getOrders(params = {}, options = {}) {&#10;    return this.fetchWithCache(&quot;/api/orders&quot;, params, {&#10;      ttl: 3 * 60 * 1000, // 3 minutes for orders (more dynamic data)&#10;      ...options,&#10;    });&#10;  }&#10;&#10;  async createOrder(orderData) {&#10;    const response = await fetch(&quot;/api/orders&quot;, {&#10;      method: &quot;POST&quot;,&#10;      headers: { &quot;Content-Type&quot;: &quot;application/json&quot; },&#10;      body: JSON.stringify(orderData),&#10;    });&#10;&#10;    if (!response.ok) {&#10;      throw new Error(`Failed to create order: ${response.status}`);&#10;    }&#10;&#10;    const result = await response.json();&#10;    this.clearOrdersCache();&#10;    this.clearProductsCache();&#10;&#10;    return result;&#10;  }&#10;&#10;  async getOrderById(orderId, options = {}) {&#10;    return this.fetchWithCache(`/api/orders/${orderId}`, {}, options);&#10;  }&#10;&#10;  async updateOrder(orderId, updateData) {&#10;    const response = await fetch(`/api/orders`, {&#10;      method: &quot;PATCH&quot;,&#10;      headers: { &quot;Content-Type&quot;: &quot;application/json&quot; },&#10;      body: JSON.stringify({ orderId, ...updateData }),&#10;    });&#10;&#10;    if (!response.ok) {&#10;      throw new Error(`Failed to update order: ${response.status}`);&#10;    }&#10;&#10;    // Clear orders cache when updating&#10;    this.clearOrdersCache();&#10;    return response.json();&#10;  }&#10;&#10;  // Cache management for orders&#10;  clearOrdersCache() {&#10;    // Clear all order-related cache entries&#10;    const orderKeys = globalCache&#10;      .getStats()&#10;      .keys.filter((key) =&gt; key.includes(&quot;/api/orders&quot;));&#10;    orderKeys.forEach((key) =&gt; globalCache.delete(key));&#10;&#10;    // Clear session cache&#10;    if (typeof window !== &quot;undefined&quot;) {&#10;      sessionCache.cleanup();&#10;    }&#10;&#10;    // Clear React Query orders cache if available&#10;    if (typeof window !== &quot;undefined&quot; &amp;&amp; window.__REACT_QUERY_CLIENT__) {&#10;      window.__REACT_QUERY_CLIENT__.invalidateQueries({&#10;        queryKey: [&quot;orders&quot;],&#10;        exact: false,&#10;      });&#10;    }&#10;  }&#10;&#10;  // Force clear all product-related cache&#10;  clearProductsCache() {&#10;    console.log(&quot; API Service: Clearing ALL products cache entries...&quot;);&#10;&#10;    // Clear memory cache with more aggressive pattern matching&#10;    globalCache.clearPattern(&quot;products&quot;);&#10;    globalCache.clearPattern(&quot;product&quot;);&#10;    globalCache.clearPattern(&quot;/api/products&quot;); // Clear by endpoint pattern&#10;    globalCache.clearPattern(&quot;dashboard&quot;); // Also clear dashboard cache&#10;&#10;    // Also clear any cache entries that might contain product data with parameters&#10;    if (globalCache.getStats) {&#10;      const stats = globalCache.getStats();&#10;      const productKeys = stats.keys.filter(&#10;        (key) =&gt;&#10;          key.includes(&quot;/api/products&quot;) ||&#10;          key.includes(&quot;products&quot;) ||&#10;          key.includes(&quot;product&quot;) ||&#10;          key.includes(&quot;dashboard&quot;) || // Also clear dashboard-related cache&#10;          key.includes(&quot;farmers&quot;), // Clear farmers cache too as it may contain product data&#10;      );&#10;      console.log(&quot; Clearing specific product cache keys:&quot;, productKeys);&#10;      productKeys.forEach((key) =&gt; globalCache.delete(key));&#10;    }&#10;&#10;    // Clear session cache with same aggressive approach&#10;    sessionCache.clearPattern(&quot;products&quot;);&#10;    sessionCache.clearPattern(&quot;product&quot;);&#10;    sessionCache.clearPattern(&quot;/api/products&quot;);&#10;    sessionCache.clearPattern(&quot;dashboard&quot;);&#10;&#10;    // Force clear browser storage&#10;    if (typeof window !== &quot;undefined&quot;) {&#10;      try {&#10;        sessionStorage.removeItem(&quot;products-cache&quot;);&#10;        sessionStorage.removeItem(&quot;dashboard-cache&quot;);&#10;        sessionStorage.removeItem(&quot;farmfresh-products&quot;);&#10;        sessionStorage.removeItem(&quot;farmfresh-dashboard&quot;);&#10;        localStorage.removeItem(&quot;products-cache&quot;);&#10;        localStorage.removeItem(&quot;dashboard-cache&quot;);&#10;      } catch (e) {&#10;        console.warn(&quot;Storage clearing warning:&quot;, e);&#10;      }&#10;    }&#10;&#10;    // Clear React Query cache if available&#10;    if (typeof window !== &quot;undefined&quot; &amp;&amp; window.__REACT_QUERY_CLIENT__) {&#10;      window.__REACT_QUERY_CLIENT__.invalidateQueries({&#10;        queryKey: [&quot;products&quot;],&#10;        exact: false,&#10;      });&#10;      // Also clear dashboard cache since it contains product data&#10;      window.__REACT_QUERY_CLIENT__.invalidateQueries({&#10;        queryKey: [&quot;dashboard&quot;],&#10;        exact: false,&#10;      });&#10;    }&#10;&#10;    console.log(&quot;✅ API Service: ALL products cache cleared comprehensively&quot;);&#10;  }&#10;&#10;  // Clear farmers cache&#10;  clearFarmersCache() {&#10;    try {&#10;      // Clear memory cache using explicit key deletion (more reliable than clearPattern)&#10;      const stats = globalCache.getStats();&#10;      // Clear all farmer-related keys&#10;      const farmerKeys = stats.keys.filter(&#10;        (key) =&gt;&#10;          key.includes(&quot;/api/farmers&quot;) ||&#10;          key.includes(&quot;farmers&quot;) ||&#10;          key.includes(&quot;farmer&quot;) ||&#10;          key.includes(&quot;/api/products&quot;) || // Also clear products since they contain farmer info&#10;          key.includes(&quot;products&quot;),&#10;      );&#10;      farmerKeys.forEach((key) =&gt; globalCache.delete(key));&#10;&#10;      // Also use clearPattern as backup to ensure all related data is cleared&#10;      globalCache.clearPattern(&quot;farmers&quot;);&#10;      globalCache.clearPattern(&quot;farmer&quot;);&#10;      globalCache.clearPattern(&quot;products&quot;); // Clear products cache too&#10;      globalCache.clearPattern(&quot;product&quot;);&#10;    } catch (error) {&#10;      console.error(&quot;❌ Error clearing memory cache:&quot;, error);&#10;      // Fallback to pattern clearing if stats approach fails&#10;      globalCache.clearPattern(&quot;farmers&quot;);&#10;      globalCache.clearPattern(&quot;farmer&quot;);&#10;      globalCache.clearPattern(&quot;products&quot;);&#10;      globalCache.clearPattern(&quot;product&quot;);&#10;    }&#10;&#10;    // Clear session cache&#10;    if (typeof window !== &quot;undefined&quot;) {&#10;      sessionCache.cleanup(); // Use cleanup instead of clearPattern for more thorough clearing&#10;&#10;      // Also clear products from session cache&#10;      try {&#10;        sessionCache.clearPattern(&quot;products&quot;);&#10;        sessionCache.clearPattern(&quot;product&quot;);&#10;      } catch (error) {}&#10;    }&#10;  }&#10;&#10;  // Force refresh products with cache bypass&#10;  async forceRefreshProducts(params = {}) {&#10;    // Clear cache first&#10;    this.clearProductsCache();&#10;&#10;    // Add timestamp to force cache bypass&#10;    const paramsWithTimestamp = {&#10;      ...params,&#10;      _t: Date.now(),&#10;    };&#10;&#10;    return this.fetchWithCache(&quot;/api/products&quot;, paramsWithTimestamp, {&#10;      skipCache: true,&#10;      useSessionCache: false,&#10;      headers: {&#10;        &quot;Cache-Control&quot;: &quot;no-cache&quot;,&#10;        Pragma: &quot;no-cache&quot;,&#10;      },&#10;    });&#10;  }&#10;&#10;  // Clear all cache&#10;  clearAllCache() {&#10;    globalCache.clear();&#10;    if (typeof window !== &quot;undefined&quot;) {&#10;      sessionCache.clear();&#10;    }&#10;  }&#10;&#10;  // Simple generic cache clearing method - the one you were looking for!&#10;  clearCache() {&#10;    console.log(&quot; API Service: Clearing all cache via clearCache()...&quot;);&#10;&#10;    // Clear all memory cache&#10;    globalCache.clear();&#10;&#10;    // Clear all session cache&#10;    if (typeof window !== &quot;undefined&quot;) {&#10;      sessionCache.clear();&#10;    }&#10;&#10;    // Clear React Query cache if available&#10;    if (typeof window !== &quot;undefined&quot; &amp;&amp; window.__REACT_QUERY_CLIENT__) {&#10;      console.log(&quot; API Service: Invalidating all React Query cache...&quot;);&#10;      window.__REACT_QUERY_CLIENT__.clear();&#10;    }&#10;&#10;    // Clear any ongoing requests&#10;    ongoingRequests.clear();&#10;&#10;    console.log(&quot;✅ API Service: All cache cleared via clearCache()&quot;);&#10;  }&#10;&#10;  // Optimized method for dashboard data - fetch both products and orders efficiently&#10;  async getDashboardData(userId, userEmail, options = {}) {&#10;    const { forceRefresh = false } = options;&#10;&#10;    try {&#10;      // Fetch products and orders in parallel with optimized parameters&#10;      const [productsData, ordersData] = await Promise.all([&#10;        this.getProducts(&#10;          {&#10;            limit: 200, // Reduced limit for dashboard&#10;            farmerId: userId,&#10;            farmerEmail: userEmail,&#10;            dashboard: &quot;true&quot;, // Add dashboard context to show inactive products&#10;          },&#10;          { skipCache: forceRefresh },&#10;        ),&#10;&#10;        this.getOrders(&#10;          {&#10;            limit: 100, // Reduced limit for dashboard&#10;            farmerId: userId,&#10;            farmerEmail: userEmail,&#10;          },&#10;          { skipCache: forceRefresh },&#10;        ),&#10;      ]);&#10;&#10;      return {&#10;        products: productsData.products || [],&#10;        orders: ordersData.orders || [],&#10;        analytics: this.calculateAnalytics(&#10;          productsData.products || [],&#10;          ordersData.orders || [],&#10;        ),&#10;        meta: {&#10;          productsCount: productsData.products?.length || 0,&#10;          ordersCount: ordersData.orders?.length || 0,&#10;          fromCache: !forceRefresh,&#10;        },&#10;      };&#10;    } catch (error) {&#10;      console.error(&quot;Dashboard data fetch error:&quot;, error);&#10;      throw error;&#10;    }&#10;  }&#10;&#10;  // Bulk update products - SIMPLE like farmer updates (no extra cache clearing)&#10;  async bulkUpdateProducts(productIds, updateData) {&#10;    try {&#10;      const response = await fetch(&quot;/api/products/bulk-update&quot;, {&#10;        method: &quot;PUT&quot;,&#10;        headers: {&#10;          &quot;Content-Type&quot;: &quot;application/json&quot;,&#10;          &quot;Cache-Control&quot;: &quot;no-cache, no-store, must-revalidate&quot;,&#10;          Pragma: &quot;no-cache&quot;,&#10;          Expires: &quot;0&quot;,&#10;          &quot;x-cache-bust&quot;: Date.now().toString(),&#10;          &quot;x-bulk-update&quot;: &quot;true&quot;,&#10;        },&#10;        body: JSON.stringify({ productIds, updateData }),&#10;      });&#10;&#10;      if (!response.ok) {&#10;        const errorText = await response.text();&#10;        console.error(&quot;❌ Bulk update failed - Response:&quot;, errorText);&#10;        throw new Error(&#10;          `Failed to bulk update products: ${response.status} - ${errorText}`,&#10;        );&#10;      }&#10;&#10;      const result = await response.json();&#10;      return result;&#10;    } catch (error) {&#10;      console.error(&quot;❌ Bulk update error:&quot;, error);&#10;      throw error;&#10;    }&#10;  }&#10;&#10;  // Calculate basic analytics for dashboard&#10;  calculateAnalytics(products, orders) {&#10;    const validOrders = orders.filter(&#10;      (order) =&gt; order.status !== &quot;cancelled&quot; &amp;&amp; order.status !== &quot;returned&quot;,&#10;    );&#10;&#10;    const totalProducts = products.length;&#10;    const activeProducts = products.filter(&#10;      (p) =&gt; p.stock &gt; 0 &amp;&amp; p.status !== &quot;inactive&quot;,&#10;    ).length;&#10;&#10;    const totalOrders = orders.length;&#10;    const totalRevenue = validOrders.reduce(&#10;      (sum, order) =&gt; sum + (order.farmerSubtotal || order.total || 0),&#10;      0,&#10;    );&#10;&#10;    const averageOrderValue =&#10;      validOrders.length &gt; 0 ? totalRevenue / validOrders.length : 0;&#10;&#10;    return {&#10;      totalProducts,&#10;      activeProducts,&#10;      totalOrders,&#10;      totalRevenue,&#10;      averageOrderValue,&#10;    };&#10;  }&#10;}&#10;&#10;// Global API service instance&#10;export const apiService = new ApiService();&#10;&#10;// Make apiService globally accessible for debugging and cross-component access&#10;if (typeof window !== &quot;undefined&quot;) {&#10;  window.apiService = apiService;&#10;}&#10;&#10;// Hook for React components&#10;export function useApiService() {&#10;  return apiService;&#10;}&#10;" />
              <option name="updatedContent" value="import globalCache, { sessionCache } from &quot;./cache&quot;;&#10;&#10;// Request deduplication to prevent multiple identical API calls&#10;const ongoingRequests = new Map();&#10;&#10;// Optimized API service with caching and request deduplication&#10;export class ApiService {&#10;  constructor() {&#10;    this.baseURL = &quot;/api&quot;;&#10;  }&#10;&#10;  // Generic fetch with caching and deduplication&#10;  async fetchWithCache(endpoint, params = {}, options = {}) {&#10;    const {&#10;      ttl = 5 * 60 * 1000, // 5 minutes default&#10;      useSessionCache = true,&#10;      skipCache = false,&#10;      ...fetchOptions&#10;    } = options;&#10;&#10;    // Generate cache key&#10;    const cacheKey = globalCache.generateKey(endpoint, params);&#10;    const sessionKey = sessionCache.generateKey(endpoint, params);&#10;&#10;    // ONLY return cached data if NOT skipping cache&#10;    if (!skipCache) {&#10;      // Try memory cache first (fastest)&#10;      const memoryData = globalCache.get(cacheKey);&#10;      if (memoryData) {&#10;        console.log(` [API Service] Returning cached data for ${endpoint}`);&#10;        return memoryData;&#10;      }&#10;&#10;      // Try session cache (survives page reloads)&#10;      if (useSessionCache) {&#10;        const sessionData = sessionCache.get(sessionKey);&#10;        if (sessionData) {&#10;          // Also store in memory cache for faster subsequent access&#10;          globalCache.set(cacheKey, sessionData, ttl);&#10;          return sessionData;&#10;        }&#10;      }&#10;    } else {&#10;    }&#10;&#10;    // Check if same request is already ongoing&#10;    const requestKey = `${endpoint}_${JSON.stringify(params)}`;&#10;    if (ongoingRequests.has(requestKey)) {&#10;      return ongoingRequests.get(requestKey);&#10;    }&#10;&#10;    // Build URL with params&#10;    const url = new URL(endpoint, window.location.origin);&#10;    Object.entries(params).forEach(([key, value]) =&gt; {&#10;      if (value !== null &amp;&amp; value !== undefined &amp;&amp; value !== &quot;&quot;) {&#10;        url.searchParams.append(key, value);&#10;      }&#10;    });&#10;&#10;    // Create the promise and store it to prevent duplicate requests&#10;    const requestPromise = fetch(url.toString(), {&#10;      method: &quot;GET&quot;,&#10;      headers: {&#10;        &quot;Content-Type&quot;: &quot;application/json&quot;,&#10;        ...fetchOptions.headers,&#10;      },&#10;      ...fetchOptions,&#10;    })&#10;      .then(async (response) =&gt; {&#10;        if (!response.ok) {&#10;          throw new Error(`HTTP error! status: ${response.status}`);&#10;        }&#10;        return response.json();&#10;      })&#10;      .then((data) =&gt; {&#10;        // Cache the successful response&#10;        if (!skipCache) {&#10;          globalCache.set(cacheKey, data, ttl);&#10;          if (useSessionCache) {&#10;            sessionCache.set(sessionKey, data, ttl);&#10;          }&#10;        }&#10;        return data;&#10;      })&#10;      .catch((error) =&gt; {&#10;        console.error(`API Error for ${endpoint}:`, error);&#10;        throw error;&#10;      })&#10;      .finally(() =&gt; {&#10;        // Remove from ongoing requests&#10;        ongoingRequests.delete(requestKey);&#10;      });&#10;&#10;    // Store the ongoing request&#10;    ongoingRequests.set(requestKey, requestPromise);&#10;&#10;    return requestPromise;&#10;  }&#10;&#10;  // Products API methods&#10;  async getProducts(params = {}, options = {}) {&#10;    return this.fetchWithCache(&quot;/api/products&quot;, params, {&#10;      ttl: 3 * 60 * 1000, // 3 minutes for products&#10;      useSessionCache: true,&#10;      ...options,&#10;    });&#10;  }&#10;&#10;  async getProduct(id) {&#10;    return this.fetchWithCache(&#10;      `/api/products/${id}`,&#10;      {},&#10;      {&#10;        ttl: 10 * 60 * 1000, // 10 minutes for individual products&#10;        useSessionCache: true,&#10;      },&#10;    );&#10;  }&#10;&#10;  // Categories API&#10;  async getCategories() {&#10;    return this.fetchWithCache(&#10;      &quot;/api/categories&quot;,&#10;      {},&#10;      {&#10;        ttl: 30 * 60 * 1000, // 30 minutes for categories (rarely change)&#10;        useSessionCache: true,&#10;      },&#10;    );&#10;  }&#10;&#10;  // Farmers API methods&#10;  async getFarmers(options = {}) {&#10;    return this.fetchWithCache(&#10;      &quot;/api/farmers&quot;,&#10;      {},&#10;      {&#10;        ttl: 5 * 60 * 1000, // 5 minutes for farmers&#10;        useSessionCache: true,&#10;        ...options,&#10;      },&#10;    );&#10;  }&#10;&#10;  async updateFarmer(farmerId, farmerData) {&#10;    // Step 1: Clear caches BEFORE the update to prevent race conditions&#10;    this.clearCache(); // Use the new comprehensive cache clearing method&#10;&#10;    // Step 2: Use PUT method with cache busting headers&#10;    const response = await fetch(&quot;/api/farmers&quot;, {&#10;      method: &quot;PUT&quot;,&#10;      headers: {&#10;        &quot;Content-Type&quot;: &quot;application/json&quot;,&#10;        &quot;Cache-Control&quot;: &quot;no-cache, no-store, must-revalidate&quot;,&#10;        Pragma: &quot;no-cache&quot;,&#10;        Expires: &quot;0&quot;,&#10;        &quot;x-cache-bust&quot;: Date.now().toString(),&#10;        &quot;x-farmer-update&quot;: &quot;true&quot;, // Flag to identify farmer updates&#10;      },&#10;      body: JSON.stringify(farmerData),&#10;    });&#10;&#10;    if (!response.ok) {&#10;      throw new Error(`Failed to update farmer: ${response.status}`);&#10;    }&#10;&#10;    const result = await response.json();&#10;&#10;    // Step 3: Comprehensive cache clearing after successful update&#10;    this.clearCache(); // Clear all API service caches&#10;&#10;    // Step 4: Force React Query cache invalidation if available&#10;    if (typeof window !== &quot;undefined&quot; &amp;&amp; window.__REACT_QUERY_CLIENT__) {&#10;      const queryClient = window.__REACT_QUERY_CLIENT__;&#10;&#10;      // Remove all cached data (most aggressive approach)&#10;      queryClient.clear();&#10;&#10;      // Then force fresh fetches for critical data&#10;      queryClient.invalidateQueries({&#10;        queryKey: [&quot;farmers&quot;],&#10;        refetchType: &quot;all&quot;,&#10;      });&#10;&#10;      queryClient.invalidateQueries({&#10;        queryKey: [&quot;products&quot;],&#10;        refetchType: &quot;all&quot;,&#10;      });&#10;    }&#10;&#10;    // Step 5: Clear browser caches completely&#10;    if (typeof window !== &quot;undefined&quot;) {&#10;      // Clear all storage that might contain cached data&#10;      try {&#10;        // Clear session storage&#10;        const sessionKeys = Object.keys(sessionStorage);&#10;        sessionKeys.forEach((key) =&gt; {&#10;          if (&#10;            key.includes(&quot;farmer&quot;) ||&#10;            key.includes(&quot;product&quot;) ||&#10;            key.includes(&quot;cache&quot;)&#10;          ) {&#10;            sessionStorage.removeItem(key);&#10;          }&#10;        });&#10;&#10;        // Clear local storage&#10;        const localKeys = Object.keys(localStorage);&#10;        localKeys.forEach((key) =&gt; {&#10;          if (&#10;            key.includes(&quot;farmer&quot;) ||&#10;            key.includes(&quot;product&quot;) ||&#10;            key.includes(&quot;cache&quot;)&#10;          ) {&#10;            localStorage.removeItem(key);&#10;          }&#10;        });&#10;&#10;        // Clear browser cache&#10;        if (&quot;caches&quot; in window) {&#10;          window.caches.keys().then((cacheNames) =&gt; {&#10;            cacheNames.forEach((cacheName) =&gt; {&#10;              window.caches.delete(cacheName);&#10;            });&#10;          });&#10;        }&#10;      } catch (error) {&#10;        console.warn(&quot;⚠️ Some cache clearing operations failed:&quot;, error);&#10;      }&#10;    }&#10;&#10;    console.log(&#10;      &quot;✅ Super aggressive cache clearing completed - farmer names will update immediately across all pages&quot;,&#10;    );&#10;&#10;    return result;&#10;  }&#10;&#10;  // Orders API methods&#10;  async getOrders(params = {}, options = {}) {&#10;    return this.fetchWithCache(&quot;/api/orders&quot;, params, {&#10;      ttl: 3 * 60 * 1000, // 3 minutes for orders (more dynamic data)&#10;      ...options,&#10;    });&#10;  }&#10;&#10;  async createOrder(orderData) {&#10;    const response = await fetch(&quot;/api/orders&quot;, {&#10;      method: &quot;POST&quot;,&#10;      headers: { &quot;Content-Type&quot;: &quot;application/json&quot; },&#10;      body: JSON.stringify(orderData),&#10;    });&#10;&#10;    if (!response.ok) {&#10;      throw new Error(`Failed to create order: ${response.status}`);&#10;    }&#10;&#10;    const result = await response.json();&#10;    this.clearOrdersCache();&#10;    this.clearProductsCache();&#10;&#10;    return result;&#10;  }&#10;&#10;  async getOrderById(orderId, options = {}) {&#10;    return this.fetchWithCache(`/api/orders/${orderId}`, {}, options);&#10;  }&#10;&#10;  async updateOrder(orderId, updateData) {&#10;    const response = await fetch(`/api/orders`, {&#10;      method: &quot;PATCH&quot;,&#10;      headers: { &quot;Content-Type&quot;: &quot;application/json&quot; },&#10;      body: JSON.stringify({ orderId, ...updateData }),&#10;    });&#10;&#10;    if (!response.ok) {&#10;      throw new Error(`Failed to update order: ${response.status}`);&#10;    }&#10;&#10;    // Clear orders cache when updating&#10;    this.clearOrdersCache();&#10;    return response.json();&#10;  }&#10;&#10;  // Cache management for orders&#10;  clearOrdersCache() {&#10;    // Clear all order-related cache entries&#10;    const orderKeys = globalCache&#10;      .getStats()&#10;      .keys.filter((key) =&gt; key.includes(&quot;/api/orders&quot;));&#10;    orderKeys.forEach((key) =&gt; globalCache.delete(key));&#10;&#10;    // Clear session cache&#10;    if (typeof window !== &quot;undefined&quot;) {&#10;      sessionCache.cleanup();&#10;    }&#10;&#10;    // Clear React Query orders cache if available&#10;    if (typeof window !== &quot;undefined&quot; &amp;&amp; window.__REACT_QUERY_CLIENT__) {&#10;      window.__REACT_QUERY_CLIENT__.invalidateQueries({&#10;        queryKey: [&quot;orders&quot;],&#10;        exact: false,&#10;      });&#10;    }&#10;  }&#10;&#10;  // Force clear all product-related cache&#10;  clearProductsCache() {&#10;    console.log(&quot; API Service: Clearing ALL products cache entries...&quot;);&#10;&#10;    // Clear memory cache with more aggressive pattern matching&#10;    globalCache.clearPattern(&quot;products&quot;);&#10;    globalCache.clearPattern(&quot;product&quot;);&#10;    globalCache.clearPattern(&quot;/api/products&quot;); // Clear by endpoint pattern&#10;    globalCache.clearPattern(&quot;dashboard&quot;); // Also clear dashboard cache&#10;&#10;    // Also clear any cache entries that might contain product data with parameters&#10;    if (globalCache.getStats) {&#10;      const stats = globalCache.getStats();&#10;      const productKeys = stats.keys.filter(&#10;        (key) =&gt;&#10;          key.includes(&quot;/api/products&quot;) ||&#10;          key.includes(&quot;products&quot;) ||&#10;          key.includes(&quot;product&quot;) ||&#10;          key.includes(&quot;dashboard&quot;) || // Also clear dashboard-related cache&#10;          key.includes(&quot;farmers&quot;), // Clear farmers cache too as it may contain product data&#10;      );&#10;      console.log(&quot; Clearing specific product cache keys:&quot;, productKeys);&#10;      productKeys.forEach((key) =&gt; globalCache.delete(key));&#10;    }&#10;&#10;    // Clear session cache with same aggressive approach&#10;    sessionCache.clearPattern(&quot;products&quot;);&#10;    sessionCache.clearPattern(&quot;product&quot;);&#10;    sessionCache.clearPattern(&quot;/api/products&quot;);&#10;    sessionCache.clearPattern(&quot;dashboard&quot;);&#10;&#10;    // Force clear browser storage&#10;    if (typeof window !== &quot;undefined&quot;) {&#10;      try {&#10;        sessionStorage.removeItem(&quot;products-cache&quot;);&#10;        sessionStorage.removeItem(&quot;dashboard-cache&quot;);&#10;        sessionStorage.removeItem(&quot;farmfresh-products&quot;);&#10;        sessionStorage.removeItem(&quot;farmfresh-dashboard&quot;);&#10;        localStorage.removeItem(&quot;products-cache&quot;);&#10;        localStorage.removeItem(&quot;dashboard-cache&quot;);&#10;      } catch (e) {&#10;        console.warn(&quot;Storage clearing warning:&quot;, e);&#10;      }&#10;    }&#10;&#10;    // Clear React Query cache if available&#10;    if (typeof window !== &quot;undefined&quot; &amp;&amp; window.__REACT_QUERY_CLIENT__) {&#10;      window.__REACT_QUERY_CLIENT__.invalidateQueries({&#10;        queryKey: [&quot;products&quot;],&#10;        exact: false,&#10;      });&#10;      // Also clear dashboard cache since it contains product data&#10;      window.__REACT_QUERY_CLIENT__.invalidateQueries({&#10;        queryKey: [&quot;dashboard&quot;],&#10;        exact: false,&#10;      });&#10;    }&#10;&#10;    console.log(&quot;✅ API Service: ALL products cache cleared comprehensively&quot;);&#10;  }&#10;&#10;  // Clear farmers cache&#10;  clearFarmersCache() {&#10;    try {&#10;      // Clear memory cache using explicit key deletion (more reliable than clearPattern)&#10;      const stats = globalCache.getStats();&#10;      // Clear all farmer-related keys&#10;      const farmerKeys = stats.keys.filter(&#10;        (key) =&gt;&#10;          key.includes(&quot;/api/farmers&quot;) ||&#10;          key.includes(&quot;farmers&quot;) ||&#10;          key.includes(&quot;farmer&quot;) ||&#10;          key.includes(&quot;/api/products&quot;) || // Also clear products since they contain farmer info&#10;          key.includes(&quot;products&quot;),&#10;      );&#10;      farmerKeys.forEach((key) =&gt; globalCache.delete(key));&#10;&#10;      // Also use clearPattern as backup to ensure all related data is cleared&#10;      globalCache.clearPattern(&quot;farmers&quot;);&#10;      globalCache.clearPattern(&quot;farmer&quot;);&#10;      globalCache.clearPattern(&quot;products&quot;); // Clear products cache too&#10;      globalCache.clearPattern(&quot;product&quot;);&#10;    } catch (error) {&#10;      console.error(&quot;❌ Error clearing memory cache:&quot;, error);&#10;      // Fallback to pattern clearing if stats approach fails&#10;      globalCache.clearPattern(&quot;farmers&quot;);&#10;      globalCache.clearPattern(&quot;farmer&quot;);&#10;      globalCache.clearPattern(&quot;products&quot;);&#10;      globalCache.clearPattern(&quot;product&quot;);&#10;    }&#10;&#10;    // Clear session cache&#10;    if (typeof window !== &quot;undefined&quot;) {&#10;      sessionCache.cleanup(); // Use cleanup instead of clearPattern for more thorough clearing&#10;&#10;      // Also clear products from session cache&#10;      try {&#10;        sessionCache.clearPattern(&quot;products&quot;);&#10;        sessionCache.clearPattern(&quot;product&quot;);&#10;      } catch (error) {}&#10;    }&#10;  }&#10;&#10;  // Force refresh products with cache bypass&#10;  async forceRefreshProducts(params = {}) {&#10;    // Clear cache first&#10;    this.clearProductsCache();&#10;&#10;    // Add timestamp to force cache bypass&#10;    const paramsWithTimestamp = {&#10;      ...params,&#10;      _t: Date.now(),&#10;    };&#10;&#10;    return this.fetchWithCache(&quot;/api/products&quot;, paramsWithTimestamp, {&#10;      skipCache: true,&#10;      useSessionCache: false,&#10;      headers: {&#10;        &quot;Cache-Control&quot;: &quot;no-cache&quot;,&#10;        Pragma: &quot;no-cache&quot;,&#10;      },&#10;    });&#10;  }&#10;&#10;  // Clear all cache&#10;  clearAllCache() {&#10;    globalCache.clear();&#10;    if (typeof window !== &quot;undefined&quot;) {&#10;      sessionCache.clear();&#10;    }&#10;  }&#10;&#10;  // Simple generic cache clearing method - the one you were looking for!&#10;  clearCache() {&#10;    console.log(&quot; API Service: Clearing all cache via clearCache()...&quot;);&#10;&#10;    // Clear all memory cache&#10;    globalCache.clear();&#10;&#10;    // Clear all session cache&#10;    if (typeof window !== &quot;undefined&quot;) {&#10;      sessionCache.clear();&#10;    }&#10;&#10;    // Clear React Query cache if available&#10;    if (typeof window !== &quot;undefined&quot; &amp;&amp; window.__REACT_QUERY_CLIENT__) {&#10;      console.log(&quot; API Service: Invalidating all React Query cache...&quot;);&#10;      window.__REACT_QUERY_CLIENT__.clear();&#10;    }&#10;&#10;    // Clear any ongoing requests&#10;    ongoingRequests.clear();&#10;&#10;    console.log(&quot;✅ API Service: All cache cleared via clearCache()&quot;);&#10;  }&#10;&#10;  // Optimized method for dashboard data - fetch both products and orders efficiently&#10;  async getDashboardData(userId, userEmail, options = {}) {&#10;    const { forceRefresh = false } = options;&#10;&#10;    try {&#10;      // Fetch products and orders in parallel with optimized parameters&#10;      const [productsData, ordersData] = await Promise.all([&#10;        this.getProducts(&#10;          {&#10;            limit: 200, // Reduced limit for dashboard&#10;            farmerId: userId,&#10;            farmerEmail: userEmail,&#10;            dashboard: &quot;true&quot;, // Add dashboard context to show inactive products&#10;          },&#10;          { skipCache: forceRefresh },&#10;        ),&#10;&#10;        this.getOrders(&#10;          {&#10;            limit: 100, // Reduced limit for dashboard&#10;            farmerId: userId,&#10;            farmerEmail: userEmail,&#10;          },&#10;          { skipCache: forceRefresh },&#10;        ),&#10;      ]);&#10;&#10;      return {&#10;        products: productsData.products || [],&#10;        orders: ordersData.orders || [],&#10;        analytics: this.calculateAnalytics(&#10;          productsData.products || [],&#10;          ordersData.orders || [],&#10;        ),&#10;        meta: {&#10;          productsCount: productsData.products?.length || 0,&#10;          ordersCount: ordersData.orders?.length || 0,&#10;          fromCache: !forceRefresh,&#10;        },&#10;      };&#10;    } catch (error) {&#10;      console.error(&quot;Dashboard data fetch error:&quot;, error);&#10;      throw error;&#10;    }&#10;  }&#10;&#10;  // Bulk update products - SIMPLE like farmer updates (no extra cache clearing)&#10;  async bulkUpdateProducts(productIds, updateData) {&#10;    try {&#10;      const response = await fetch(&quot;/api/products/bulk-update&quot;, {&#10;        method: &quot;PUT&quot;,&#10;        headers: {&#10;          &quot;Content-Type&quot;: &quot;application/json&quot;,&#10;          &quot;Cache-Control&quot;: &quot;no-cache, no-store, must-revalidate&quot;,&#10;          Pragma: &quot;no-cache&quot;,&#10;          Expires: &quot;0&quot;,&#10;          &quot;x-cache-bust&quot;: Date.now().toString(),&#10;          &quot;x-bulk-update&quot;: &quot;true&quot;,&#10;        },&#10;        body: JSON.stringify({ productIds, updateData }),&#10;      });&#10;&#10;      if (!response.ok) {&#10;        const errorText = await response.text();&#10;        console.error(&quot;❌ Bulk update failed - Response:&quot;, errorText);&#10;        throw new Error(&#10;          `Failed to bulk update products: ${response.status} - ${errorText}`,&#10;        );&#10;      }&#10;&#10;      const result = await response.json();&#10;      return result;&#10;    } catch (error) {&#10;      console.error(&quot;❌ Bulk update error:&quot;, error);&#10;      throw error;&#10;    }&#10;  }&#10;&#10;  // Calculate basic analytics for dashboard&#10;  calculateAnalytics(products, orders) {&#10;    const validOrders = orders.filter(&#10;      (order) =&gt; order.status !== &quot;cancelled&quot; &amp;&amp; order.status !== &quot;returned&quot;,&#10;    );&#10;&#10;    const totalProducts = products.length;&#10;    const activeProducts = products.filter(&#10;      (p) =&gt; p.stock &gt; 0 &amp;&amp; p.status !== &quot;inactive&quot;,&#10;    ).length;&#10;&#10;    const totalOrders = orders.length;&#10;    const totalRevenue = validOrders.reduce(&#10;      (sum, order) =&gt; sum + (order.farmerSubtotal || order.total || 0),&#10;      0,&#10;    );&#10;&#10;    const averageOrderValue =&#10;      validOrders.length &gt; 0 ? totalRevenue / validOrders.length : 0;&#10;&#10;    return {&#10;      totalProducts,&#10;      activeProducts,&#10;      totalOrders,&#10;      totalRevenue,&#10;      averageOrderValue,&#10;    };&#10;  }&#10;}&#10;&#10;// Global API service instance&#10;export const apiService = new ApiService();&#10;&#10;// Make apiService globally accessible for debugging and cross-component access&#10;if (typeof window !== &quot;undefined&quot;) {&#10;  window.apiService = apiService;&#10;}&#10;&#10;// Hook for React components&#10;export function useApiService() {&#10;  return apiService;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/make-visible.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/make-visible.js" />
              <option name="updatedContent" value="// Make the products with reviews visible by marking them as featured&#10;const { MongoClient, ObjectId } = require('mongodb');&#10;&#10;async function makeReviewedProductsVisible() {&#10;  const client = new MongoClient('mongodb://localhost:27017');&#10;  await client.connect();&#10;  const db = client.db('farmfresh');&#10;  &#10;  const productIdsWithReviews = ['6889cb7ab6d22dd651140bee', '688affa63c35c3c0ff9c4925'];&#10;  &#10;  console.log(' Making products with reviews visible...\n');&#10;  &#10;  for (const productId of productIdsWithReviews) {&#10;    try {&#10;      const result = await db.collection('products').updateOne(&#10;        { _id: new ObjectId(productId) },&#10;        { &#10;          $set: { &#10;            featured: true,&#10;            status: 'active',&#10;            stock: Math.max(10, 0) // Ensure they have stock&#10;          } &#10;        }&#10;      );&#10;      &#10;      if (result.matchedCount &gt; 0) {&#10;        console.log(`✅ Updated product ${productId} to be featured and active`);&#10;      } else {&#10;        console.log(`❌ Product ${productId} not found`);&#10;      }&#10;    } catch (error) {&#10;      console.log(`❌ Error updating product ${productId}: ${error.message}`);&#10;    }&#10;  }&#10;  &#10;  console.log('\n Now check your homepage - the products with reviews should appear in the featured section with star ratings!');&#10;  &#10;  await client.close();&#10;}&#10;&#10;makeReviewedProductsVisible().catch(console.error);" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/scripts/create-farmer-users.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/scripts/create-farmer-users.js" />
              <option name="updatedContent" value="const { MongoClient } = require(&quot;mongodb&quot;);&#10;const bcrypt = require(&quot;bcryptjs&quot;);&#10;&#10;// MongoDB connection string - update this with your actual connection string&#10;const MONGODB_URI = process.env.MONGODB_URI || &quot;mongodb://localhost:27017&quot;;&#10;const DB_NAME = &quot;farmfresh&quot;;&#10;&#10;// Default password for all farmers (you can change this)&#10;const DEFAULT_PASSWORD = &quot;farmer123&quot;;&#10;&#10;// Hardcoded farmers data - this should match the structure of your farmer documents&#10;const hardcodedFarmers = [&#10;  {&#10;    _id: &quot;farmer_001&quot;,&#10;    name: &quot;Abdul Rahman&quot;,&#10;    email: &quot;abdul.rahman@farmfresh.com&quot;,&#10;    phone: &quot;+880 1712 345678&quot;,&#10;    location: &quot;Rajshahi, Bangladesh&quot;,&#10;    farmName: &quot;Farm 001&quot;,&#10;    specializations: [&quot;Grains&quot;, &quot;Honey&quot;],&#10;  },&#10;  {&#10;    _id: &quot;farmer_002&quot;,&#10;    name: &quot;Sufia Begum&quot;,&#10;    email: &quot;sufia.begum@farmfresh.com&quot;,&#10;    phone: &quot;+880 1818 901234&quot;,&#10;    location: &quot;Sylhet, Bangladesh&quot;,&#10;    farmName: &quot;Farm 002&quot;,&#10;    specializations: [&quot;Fruits&quot;, &quot;Herbs&quot;],&#10;  },&#10;  {&#10;    _id: &quot;farmer_003&quot;,&#10;    name: &quot;Fatema Begum&quot;,&#10;    email: &quot;fatema.begum@farmfresh.com&quot;,&#10;    phone: &quot;+880 1813 456789&quot;,&#10;    location: &quot;Dhaka, Bangladesh&quot;,&#10;    farmName: &quot;Farm 003&quot;,&#10;    specializations: [&quot;Vegetables&quot;, &quot;Fruits&quot;, &quot;Honey&quot;],&#10;  },&#10;  {&#10;    _id: &quot;farmer_004&quot;,&#10;    name: &quot;Ibrahim Khalil&quot;,&#10;    email: &quot;ibrahim.khalil@farmfresh.com&quot;,&#10;    phone: &quot;+880 1717 890123&quot;,&#10;    location: &quot;Barishal, Bangladesh&quot;,&#10;    farmName: &quot;Farm 004&quot;,&#10;    specializations: [&quot;Fruits&quot;, &quot;Dairy&quot;, &quot;Herbs&quot;],&#10;  },&#10;  {&#10;    _id: &quot;farmer_005&quot;,&#10;    name: &quot;Mizanur Rahman&quot;,&#10;    email: &quot;mizanur.rahman@farmfresh.com&quot;,&#10;    phone: &quot;+880 1521 234567&quot;,&#10;    location: &quot;Tangail, Bangladesh&quot;,&#10;    farmName: &quot;Farm 005&quot;,&#10;    specializations: [&quot;Dairy&quot;, &quot;Vegetables&quot;],&#10;  },&#10;  {&#10;    _id: &quot;farmer_006&quot;,&#10;    name: &quot;Mostafa Kamal&quot;,&#10;    email: &quot;mostafa.kamal@farmfresh.com&quot;,&#10;    phone: &quot;+880 1521 234567&quot;,&#10;    location: &quot;Gazipur, Bangladesh&quot;,&#10;    farmName: &quot;Farm 006&quot;,&#10;    specializations: [&quot;Vegetables&quot;, &quot;Dairy&quot;],&#10;  },&#10;  {&#10;    _id: &quot;farmer_007&quot;,&#10;    name: &quot;Rubina Akter&quot;,&#10;    email: &quot;rubina.akter@farmfresh.com&quot;,&#10;    phone: &quot;+880 1420 123456&quot;,&#10;    location: &quot;Netrokona, Bangladesh&quot;,&#10;    farmName: &quot;Farm 007&quot;,&#10;    specializations: [&quot;Herbs&quot;, &quot;Honey&quot;],&#10;  },&#10;  {&#10;    _id: &quot;farmer_008&quot;,&#10;    name: &quot;Ayesha Siddika&quot;,&#10;    email: &quot;ayesha.siddika@farmfresh.com&quot;,&#10;    phone: &quot;+880 1515 678901&quot;,&#10;    location: &quot;Khulna, Bangladesh&quot;,&#10;    farmName: &quot;Farm 008&quot;,&#10;    specializations: [&quot;Fruits&quot;, &quot;Honey&quot;],&#10;  },&#10;  {&#10;    _id: &quot;farmer_009&quot;,&#10;    name: &quot;Khanzad Ali&quot;,&#10;    email: &quot;khanzad.ali@farmfresh.com&quot;,&#10;    phone: &quot;+880 1919 012345&quot;,&#10;    location: &quot;Sylhet, Bangladesh&quot;,&#10;    farmName: &quot;Farm 009&quot;,&#10;    specializations: [&quot;Honey&quot;, &quot;Vegetables&quot;],&#10;  },&#10;];&#10;&#10;// Function to create farmer users&#10;async function createFarmerUsers() {&#10;  const client = new MongoClient(MONGODB_URI);&#10;&#10;  try {&#10;    await client.connect();&#10;    console.log(&quot;Connected to MongoDB&quot;);&#10;&#10;    const db = client.db(DB_NAME);&#10;    const usersCollection = db.collection(&quot;users&quot;);&#10;&#10;    // Hash the default password&#10;    const hashedPassword = await bcrypt.hash(DEFAULT_PASSWORD, 12);&#10;&#10;    for (const farmer of hardcodedFarmers) {&#10;      try {&#10;        // Check if user already exists&#10;        const existingUser = await usersCollection.findOne({&#10;          email: farmer.email,&#10;        });&#10;&#10;        if (existingUser) {&#10;          console.log(&#10;            `User already exists for ${farmer.name} (${farmer.email})`,&#10;          );&#10;          continue;&#10;        }&#10;&#10;        // Split name into first and last name&#10;        const nameParts = farmer.name.split(&quot; &quot;);&#10;        const firstName = nameParts[0];&#10;        const lastName = nameParts.slice(1).join(&quot; &quot;) || &quot;&quot;;&#10;&#10;        // Create user document&#10;        const userData = {&#10;          _id: farmer._id, // Use the same ID as the farmer&#10;          firstName: firstName,&#10;          lastName: lastName,&#10;          name: farmer.name,&#10;          email: farmer.email,&#10;          phone: farmer.phone,&#10;          address: farmer.location,&#10;          bio: &quot;&quot;,&#10;          password: hashedPassword,&#10;          userType: &quot;farmer&quot;,&#10;          provider: &quot;credentials&quot;,&#10;          emailVerified: true, // Set to true for these hardcoded farmers&#10;          farmDetails: {&#10;            farmName: farmer.farmName,&#10;            specialization: farmer.specializations,&#10;            farmSize: null,&#10;            farmSizeUnit: &quot;acres&quot;,&#10;          },&#10;          profilePicture: null,&#10;          createdAt: new Date(),&#10;          updatedAt: new Date(),&#10;        };&#10;&#10;        // Insert user&#10;        await usersCollection.insertOne(userData);&#10;        console.log(&#10;          `Created user account for ${farmer.name} (${farmer.email})`,&#10;        );&#10;      } catch (error) {&#10;        console.error(`Error creating user for ${farmer.name}:`, error);&#10;      }&#10;    }&#10;&#10;    console.log(&quot;\nFarmer user creation completed!&quot;);&#10;    console.log(`Default password for all farmers: ${DEFAULT_PASSWORD}`);&#10;    console.log(&#10;      &quot;\nYou can now login with any of these farmer accounts using their email and the default password.&quot;,&#10;    );&#10;  } catch (error) {&#10;    console.error(&quot;Error connecting to MongoDB:&quot;, error);&#10;  } finally {&#10;    await client.close();&#10;  }&#10;}&#10;&#10;// Run the script&#10;createFarmerUsers().catch(console.error);" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/scripts/migrate-farmers.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/scripts/migrate-farmers.js" />
              <option name="updatedContent" value="// Script to migrate farmers from users collection to farmers collection&#10;import clientPromise from &quot;../lib/mongodb.js&quot;;&#10;&#10;async function migrateFarmers() {&#10;  try {&#10;    const client = await clientPromise;&#10;    const db = client.db(&quot;farmfresh&quot;);&#10;    const usersCollection = db.collection(&quot;users&quot;);&#10;    const farmersCollection = db.collection(&quot;farmers&quot;);&#10;&#10;    // Find all users with userType &quot;farmer&quot;&#10;    const farmerUsers = await usersCollection.find({ userType: &quot;farmer&quot; }).toArray();&#10;    &#10;    console.log(`Found ${farmerUsers.length} farmer users to migrate`);&#10;&#10;    for (const user of farmerUsers) {&#10;      // Check if farmer already exists in farmers collection&#10;      const existingFarmer = await farmersCollection.findOne({ _id: user._id });&#10;      &#10;      if (!existingFarmer) {&#10;        // Create farmer document&#10;        const farmerData = {&#10;          _id: user._id,&#10;          name: user.name || `${user.firstName} ${user.lastName}`,&#10;          email: user.email,&#10;          phone: user.phone || &quot;&quot;,&#10;          location: user.address || &quot;&quot;,&#10;          farmName: user.farmDetails?.farmName || `${user.name}'s Farm`,&#10;          specializations: user.farmDetails?.specialization ? &#10;            Array.isArray(user.farmDetails.specialization) ? &#10;              user.farmDetails.specialization : &#10;              [user.farmDetails.specialization] : &#10;            [&quot;General Farming&quot;],&#10;          farmSize: user.farmDetails?.farmSize || null,&#10;          farmSizeUnit: user.farmDetails?.farmSizeUnit || &quot;acres&quot;,&#10;          bio: user.bio || &quot;&quot;,&#10;          profilePicture: user.profilePicture || null,&#10;          rating: 0,&#10;          totalReviews: 0,&#10;          verified: false,&#10;          joinedDate: user.createdAt || new Date(),&#10;          products: [],&#10;          orders: [],&#10;          availability: {&#10;            status: &quot;available&quot;,&#10;            schedule: {&#10;              monday: { start: &quot;09:00&quot;, end: &quot;17:00&quot;, available: true },&#10;              tuesday: { start: &quot;09:00&quot;, end: &quot;17:00&quot;, available: true },&#10;              wednesday: { start: &quot;09:00&quot;, end: &quot;17:00&quot;, available: true },&#10;              thursday: { start: &quot;09:00&quot;, end: &quot;17:00&quot;, available: true },&#10;              friday: { start: &quot;09:00&quot;, end: &quot;17:00&quot;, available: true },&#10;              saturday: { start: &quot;09:00&quot;, end: &quot;15:00&quot;, available: true },&#10;              sunday: { start: &quot;10:00&quot;, end: &quot;14:00&quot;, available: false }&#10;            }&#10;          },&#10;          socialMedia: {&#10;            facebook: &quot;&quot;,&#10;            instagram: &quot;&quot;,&#10;            twitter: &quot;&quot;,&#10;            website: &quot;&quot;&#10;          },&#10;          certifications: [],&#10;          deliveryOptions: {&#10;            farmPickup: true,&#10;            localDelivery: false,&#10;            shipping: false,&#10;            deliveryRadius: 0&#10;          },&#10;          createdAt: user.createdAt || new Date(),&#10;          updatedAt: new Date()&#10;        };&#10;&#10;        // Insert farmer&#10;        await farmersCollection.insertOne(farmerData);&#10;        console.log(`✅ Migrated farmer: ${farmerData.name}`);&#10;      } else {&#10;        console.log(`⚠️  Farmer ${user.name} already exists in farmers collection`);&#10;      }&#10;    }&#10;&#10;    console.log(&quot;✅ Migration completed!&quot;);&#10;    &#10;    // Show final count&#10;    const totalFarmers = await farmersCollection.countDocuments();&#10;    console.log(` Total farmers in collection: ${totalFarmers}`);&#10;    &#10;  } catch (error) {&#10;    console.error(&quot;❌ Migration error:&quot;, error);&#10;  }&#10;}&#10;&#10;migrateFarmers();" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/scripts/optimize-atlas-indexes.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/scripts/optimize-atlas-indexes.js" />
              <option name="updatedContent" value="// MongoDB Atlas Performance Optimization Script&#10;// Run this script to create optimized indexes for better Atlas performance&#10;&#10;import clientPromise from &quot;../lib/mongodb.js&quot;;&#10;&#10;async function createAtlasOptimizedIndexes() {&#10;  try {&#10;    const client = await clientPromise;&#10;    const db = client.db(&quot;farmfresh&quot;);&#10;    &#10;    console.log(&quot; Starting MongoDB Atlas index optimization...&quot;);&#10;&#10;    // Products Collection - Optimized for products page performance&#10;    const productsCollection = db.collection(&quot;products&quot;);&#10;    console.log(&quot; Optimizing products collection indexes...&quot;);&#10;    &#10;    await productsCollection.createIndex(&#10;      { status: 1, category: 1, featured: 1, createdAt: -1 },&#10;      { name: &quot;products_main_query_idx&quot;, background: true }&#10;    );&#10;    &#10;    await productsCollection.createIndex(&#10;      { status: 1, featured: 1, averageRating: -1 },&#10;      { name: &quot;products_featured_rating_idx&quot;, background: true }&#10;    );&#10;    &#10;    await productsCollection.createIndex(&#10;      { status: 1, price: 1 },&#10;      { name: &quot;products_price_filter_idx&quot;, background: true }&#10;    );&#10;    &#10;    await productsCollection.createIndex(&#10;      { status: 1, purchaseCount: -1 },&#10;      { name: &quot;products_popularity_idx&quot;, background: true }&#10;    );&#10;&#10;    // Orders Collection - Optimized for farmer dashboard and orders pages&#10;    const ordersCollection = db.collection(&quot;orders&quot;);&#10;    console.log(&quot; Optimizing orders collection indexes...&quot;);&#10;    &#10;    // Critical farmer query indexes&#10;    await ordersCollection.createIndex(&#10;      { &quot;items.farmerId&quot;: 1, status: 1, createdAt: -1 },&#10;      { name: &quot;farmer_orders_main_idx&quot;, background: true }&#10;    );&#10;    &#10;    await ordersCollection.createIndex(&#10;      { &quot;items.farmerEmail&quot;: 1, status: 1, createdAt: -1 },&#10;      { name: &quot;farmer_email_orders_idx&quot;, background: true }&#10;    );&#10;    &#10;    // Customer order indexes&#10;    await ordersCollection.createIndex(&#10;      { userId: 1, createdAt: -1 },&#10;      { name: &quot;customer_orders_idx&quot;, background: true }&#10;    );&#10;    &#10;    // Status filtering&#10;    await ordersCollection.createIndex(&#10;      { status: 1, createdAt: -1 },&#10;      { name: &quot;status_date_idx&quot;, background: true }&#10;    );&#10;&#10;    // Reviews Collection - For faster review loading&#10;    const reviewsCollection = db.collection(&quot;reviews&quot;);&#10;    console.log(&quot;⭐ Optimizing reviews collection indexes...&quot;);&#10;    &#10;    await reviewsCollection.createIndex(&#10;      { productId: 1, createdAt: -1 },&#10;      { name: &quot;product_reviews_idx&quot;, background: true }&#10;    );&#10;    &#10;    await reviewsCollection.createIndex(&#10;      { userId: 1, productId: 1 },&#10;      { name: &quot;user_product_review_idx&quot;, background: true, unique: true }&#10;    );&#10;&#10;    // Favorites Collection - For user favorites&#10;    const favoritesCollection = db.collection(&quot;favorites&quot;);&#10;    console.log(&quot;❤️ Optimizing favorites collection indexes...&quot;);&#10;    &#10;    await favoritesCollection.createIndex(&#10;      { userId: 1, productId: 1 },&#10;      { name: &quot;user_favorites_idx&quot;, background: true, unique: true }&#10;    );&#10;    &#10;    await favoritesCollection.createIndex(&#10;      { userId: 1, createdAt: -1 },&#10;      { name: &quot;user_favorites_date_idx&quot;, background: true }&#10;    );&#10;&#10;    // Carts Collection - For cart operations&#10;    const cartsCollection = db.collection(&quot;carts&quot;);&#10;    console.log(&quot; Optimizing carts collection indexes...&quot;);&#10;    &#10;    await cartsCollection.createIndex(&#10;      { userId: 1 },&#10;      { name: &quot;user_cart_idx&quot;, background: true, unique: true }&#10;    );&#10;&#10;    console.log(&quot;✅ Atlas optimization complete!&quot;);&#10;    console.log(&quot; Performance improvements applied for:&quot;);&#10;    console.log(&quot;   • Products page - faster filtering and sorting&quot;);&#10;    console.log(&quot;   • Farmer dashboard - optimized order queries&quot;);&#10;    console.log(&quot;   • Farmer orders page - improved farmer-specific queries&quot;);&#10;    console.log(&quot;   • Reviews and favorites - faster user interactions&quot;);&#10;    &#10;    return true;&#10;  } catch (error) {&#10;    console.error(&quot;❌ Error optimizing indexes:&quot;, error);&#10;    return false;&#10;  }&#10;}&#10;&#10;// Atlas-specific query optimization hints&#10;async function optimizeAtlasQueries() {&#10;  console.log(&quot; Applying Atlas-specific optimizations...&quot;);&#10;  &#10;  const client = await clientPromise;&#10;  const db = client.db(&quot;farmfresh&quot;);&#10;  &#10;  // Enable collection-level read preferences for better performance&#10;  const collections = ['products', 'orders', 'reviews', 'favorites', 'carts'];&#10;  &#10;  for (const collectionName of collections) {&#10;    const collection = db.collection(collectionName);&#10;    &#10;    // Set read preference to secondary for read-heavy operations&#10;    collection.readPreference = 'secondaryPreferred';&#10;    &#10;    console.log(` Optimized read preference for ${collectionName}`);&#10;  }&#10;  &#10;  console.log(&quot;✅ Query optimizations applied!&quot;);&#10;}&#10;&#10;// Main execution function&#10;async function main() {&#10;  console.log(&quot; MongoDB Atlas Performance Optimization&quot;);&#10;  console.log(&quot;=========================================&quot;);&#10;  &#10;  const indexSuccess = await createAtlasOptimizedIndexes();&#10;  &#10;  if (indexSuccess) {&#10;    await optimizeAtlasQueries();&#10;    console.log(&quot; Your FarmFresh app is now optimized for Atlas!&quot;);&#10;    console.log(&quot; Expected performance improvements:&quot;);&#10;    console.log(&quot;   • Products page: 60-80% faster&quot;);&#10;    console.log(&quot;   • Farmer dashboard: 70-90% faster&quot;); &#10;    console.log(&quot;   • Order queries: 50-70% faster&quot;);&#10;  } else {&#10;    console.log(&quot;❌ Optimization failed. Check your MongoDB connection.&quot;);&#10;  }&#10;}&#10;&#10;// Run if called directly&#10;if (import.meta.url === `file://${process.argv[1]}`) {&#10;  main().catch(console.error);&#10;}&#10;&#10;export { createAtlasOptimizedIndexes, optimizeAtlasQueries };" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/specialization-card.txt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/specialization-card.txt" />
              <option name="updatedContent" value="{/* Dynamic Farm Specializations Card */}&#10;&lt;div className=&quot;group relative overflow-hidden rounded-3xl bg-gradient-to-br from-emerald-50 via-teal-50 to-cyan-50 dark:from-emerald-900/20 dark:via-teal-900/20 dark:to-cyan-900/20 p-8 hover:shadow-2xl transition-all duration-700 border border-emerald-200 dark:border-emerald-800&quot;&gt;&#10;  &lt;div className=&quot;absolute inset-0 bg-gradient-to-br from-emerald-400/10 to-teal-400/10 opacity-0 group-hover:opacity-100 transition-opacity duration-500&quot;&gt;&lt;/div&gt;&#10;  &lt;div className=&quot;absolute top-4 right-4 w-16 h-16 bg-emerald-100 dark:bg-emerald-800/30 rounded-full opacity-20 group-hover:scale-150 group-hover:rotate-180 transition-all duration-700&quot;&gt;&lt;/div&gt;&#10;  &lt;div className=&quot;relative z-10&quot;&gt;&#10;    &lt;div className=&quot;flex items-center justify-between mb-6&quot;&gt;&#10;      &lt;div className=&quot;w-16 h-16 bg-gradient-to-br from-emerald-500 to-teal-600 rounded-2xl flex items-center justify-center transform group-hover:rotate-12 transition-transform duration-500 shadow-lg&quot;&gt;&#10;        &lt;i className=&quot;fas fa-spa text-2xl text-white&quot;&gt;&lt;/i&gt;&#10;      &lt;/div&gt;&#10;      &lt;div className=&quot;text-right&quot;&gt;&#10;        &lt;div className=&quot;text-4xl font-bold text-emerald-600 dark:text-emerald-400 mb-1&quot;&gt;&#10;          {farmer.specializations?.length || stats.categories?.length || 3}&#10;        &lt;/div&gt;&#10;        &lt;div className=&quot;text-emerald-500 dark:text-emerald-300 text-sm font-medium&quot;&gt;&#10;          Specializations&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;    &lt;div className=&quot;space-y-3&quot;&gt;&#10;      &lt;div className=&quot;text-center&quot;&gt;&#10;        &lt;div className=&quot;flex flex-wrap gap-1 justify-center mb-3&quot;&gt;&#10;          {(farmer.specializations?.slice(0, 3) || stats.categories?.slice(0, 3) || ['Organic', 'Fresh', 'Quality']).map((spec, index) =&gt; {&#10;            const icons = {&#10;              'Grains': 'fas fa-seedling',&#10;              'Fruits': 'fas fa-apple-alt',&#10;              'Vegetables': 'fas fa-carrot',&#10;              'Herbs': 'fas fa-leaf',&#10;              'Honey': 'fas fa-bug',&#10;              'Dairy': 'fas fa-glass-whiskey',&#10;              'Organic': 'fas fa-leaf',&#10;              'Fresh': 'fas fa-sun',&#10;              'Quality': 'fas fa-star'&#10;            };&#10;            const colors = ['text-emerald-500', 'text-teal-500', 'text-cyan-500'];&#10;            return (&#10;              &lt;div key={index} className=&quot;flex items-center bg-white/70 dark:bg-emerald-900/30 rounded-full px-2 py-1&quot;&gt;&#10;                &lt;i className={`${icons[spec] || 'fas fa-spa'} ${colors[index % 3]} text-xs mr-1`}&gt;&lt;/i&gt;&#10;                &lt;span className=&quot;text-xs font-medium text-gray-700 dark:text-gray-300&quot;&gt;{spec}&lt;/span&gt;&#10;              &lt;/div&gt;&#10;            );&#10;          })}&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;      &lt;div className=&quot;flex items-center space-x-2&quot;&gt;&#10;        &lt;div className=&quot;flex-1 h-2 bg-emerald-100 dark:bg-emerald-900/30 rounded-full overflow-hidden&quot;&gt;&#10;          &lt;div&#10;            className=&quot;h-full bg-gradient-to-r from-emerald-500 to-teal-500 rounded-full animate-pulse&quot;&#10;            style={{ width: &quot;90%&quot; }}&#10;          &gt;&lt;/div&gt;&#10;        &lt;/div&gt;&#10;        &lt;span className=&quot;text-xs text-emerald-600 dark:text-emerald-400 font-medium&quot;&gt;&#10;          Expert&#10;        &lt;/span&gt;&#10;      &lt;/div&gt;&#10;      &lt;div className=&quot;text-center text-xs text-gray-500 dark:text-gray-400&quot;&gt;&#10;        Premium farm specialties&#10;      &lt;/div&gt;&#10;    &lt;/div&gt;&#10;  &lt;/div&gt;&#10;&lt;/div&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>